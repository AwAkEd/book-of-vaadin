<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="architecture">
	<title>Architecture</title>

	<para>
		This chapter provides an introduction to the architecture of Vaadin at
		somewhat technical level.
	</para>

	<section xml:id="architecture.overview">
		<title>Overview</title>

		<para>
			In <xref linkend="intro"/>, we gave a short introduction to the general
			architecture of Vaadin. Let us now look deeper into it. <xref
			linkend="figure.architecture.detailed"/> gives a basic illustration of the
			architecture.
		</para>

		<figure xml:id="figure.architecture.detailed" float="center" floatstyle="before">
			<title>Vaadin Architecture</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/arch/architecture-detailed-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="60" smallscale="100%" align="center" fileref="img/arch/architecture-detailed-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Vaadin consists of a <emphasis>web application
			API</emphasis>, a horde of <emphasis>user interface
			components</emphasis>, <emphasis>themes</emphasis> for controlling
			the appearance, and a <emphasis>data model</emphasis> that allows
			binding the user interface components directly to data. Behind the
			curtains it also employs a <emphasis>terminal adapter</emphasis> to
			receive requests from web browsers and make responses by rendering the
			pages.
		</para>

		<para>
			An application that uses Vaadin runs as a servlet in a Java web server,
			serving HTTP requests. The terminal adapter receives client requests through
			the web server's Java Servlet API, and inteprets them to user events for a
			particular session. Sessions are tracked using cookies. Events are associated
			with UI components and delivered to the application, which handles them with
			listeners. If the application logic makes changes to the server-side UI
			components, the terminal adapter renders them in the web browser by generating
			a response. The client-side engine running in the browser receives the
			responses and uses them to make any necessary changes to the page in the
			browser.
		</para>

		<para>
			The top level of a user application consists of an application class that
			inherits <classname>com.vaadin.Application</classname>.  It creates the
			UI components (see below) it needs, receives events regarding them,
			and makes necessary changes to the components. For detailed information about
			inheriting the <classname>Application</classname>, see <xref
			linkend="application"/>.
		</para>

		<para>
			The major parts of the architecture and their function are as follows:
		</para>

		<!-- Spacing must be compact for small format book. -->
		<variablelist>
			<varlistentry>
				<term>User Interface Components</term>
				<listitem>
					<para>
						The user interface consists of UI components that are created and
						laid out by the application. Each server-side component has a
						client-side counterpart, with which the user interacts. The
						server-side components can serialize themselves over the client
						connection using a terminal adapter. The client-side components,
						in turn, can serialize user interaction back to the application,
						which is received in the server-side components as events. The
						components relay these events to the application logic. Most
						components are bound to a data source (see below). For a complete
						description of UI component architecture, see <xref
						linkend="components"/>.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Client-Side Engine</term>
				<listitem>
					<para>
                        <indexterm><primary>Client-Side Engine</primary></indexterm>
                        <indexterm><primary>Google Web Toolkit</primary></indexterm>
                        <indexterm><primary>HTTP</primary></indexterm>

						The Client-Side Engine of Vaadin manages the rendering in
						the web browser. It communicates
						user interaction and UI changes with the server-side Terminal
						Adapter. The communications are made using
						asynchronous HTTP or HTTPS requests. See <xref
						linkend="architecture.client-side"/>.
					</para>
				</listitem>
			</varlistentry>
			
			<varlistentry>
				<term>Terminal Adapter</term>
				<listitem>
					<para>
                        <indexterm><primary>Terminal Adapter</primary></indexterm>
                        <indexterm><primary>AJAX</primary></indexterm>

						The UI components do not render themselves directly as a web page,
						but use a <emphasis>Terminal Adapter</emphasis>, which handles the
						client-server communications at the server end. Vaadin currently
						has a GWT terminal adapter.

                        <indexterm><primary>Google Web Toolkit</primary></indexterm>
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Themes</term>
				<listitem>
					<para>
                        <indexterm><primary>theme</primary></indexterm>
                        <indexterm><primary>CSS</primary></indexterm>
                        <indexterm><primary>HTML templates</primary></indexterm>

						The user interface separates between presentation and logic. While
						the UI logic is handled as Java code, the presentation is defined
						in <emphasis>themes</emphasis> as CSS. Vaadin provides a
						default themes. User themes can, in addition to style sheets,
						include HTML templates that define custom layouts and other
						resources, such as images. Themes are discussed in detail in <xref
						linkend="themes"/>.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Events</term>
				<listitem>
					<para>
                        <indexterm><primary>events</primary></indexterm>

						User interaction with UI components creates events, which are first
						processed on the client-side with JavaScript and then passed all the way
						through the HTTP server, terminal adapter, and user component layers to the
						application. See <xref linkend="architecture.events"/>.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Data Model</term>
				<listitem>
					<para>
                        <indexterm><primary>Data Model</primary></indexterm>

						In addition to the user interface model, Vaadin provides a
						<emphasis>data model</emphasis> for interfacing data presented in UI
						components. Using the data model, the user interface components can
						update the application data directly, without the need for any control
						code. All the UI components use this data model internally, but they can
						be bound to a separate data source as well.

                        <indexterm><primary>SQL</primary></indexterm>

                        For example, you can bind a table component to an SQL query
                        response. For a complete overview of the Vaadin Data Model, please
                        refer to <xref linkend="datamodel"/>.
					</para>
				</listitem>
			</varlistentry>

		</variablelist>

	</section>

	<section xml:id="architecture.technology">
		<title>Technological Background</title>

		<para>
            <indexterm><primary>Google Web Toolkit</primary></indexterm>
            <indexterm><primary>Google Web Toolkit</primary></indexterm>

			This section provides an introduction to the various technologies and designs
			on which Vaadin is based: AJAX-based web applications in general and Google
			Web Toolkit. This knowledge is not necessary for using Vaadin, but provides
			some background if you need to make low-level extensions to Vaadin.
		</para>

		<section xml:id="architecture.technology.ajax">
			<title>AJAX</title>
			<para>
                <indexterm significance="preferred"><primary>AJAX</primary></indexterm>
                <indexterm><primary>XML</primary></indexterm>
                <indexterm><primary>JavaScript</primary></indexterm>

				AJAX (Asynchronous JavaScript and XML) is a technique for developing web
				applications with responsive user interaction, similar to traditional
				desktop applications. While conventional JavaScript-enabled HTML pages can
				receive new content only with page updates, AJAX-enabled pages send user
				interaction to the server using an asynchronous request and receive
				updated content in the response. This way, only small parts of the page
				data can be loaded.

                <indexterm><primary>XHTML</primary></indexterm>
                <indexterm><primary>CSS</primary></indexterm>
                <indexterm><primary>DOM</primary></indexterm>
                <indexterm><primary>XMLHttpRequest</primary></indexterm>

                This goal is archieved by the use of a certain set of technologies: XHTML,
                CSS, DOM, JavaScript, XMLHttpRequest, and XML.
			</para>

            <para>
                The  web was originally not built for applications, but for hypertext
                pages that you can view with a browser. The purpose of web pages is
                to provide <emphasis>content</emphasis> for the user. Application
                software has a somewhat different purpose; usually to allow you to
                work on some data or content, much of which is not ever intended to
                be accessible through a web browser as web pages. As the web is
                inherently page-based, conventional web applications had to work with
                page requests and output HTML as response. JavaScript and AJAX have
                made it possible to let go of the pages.
            </para>

            <para>
                Pages are largely an unknown concept to conventional desktop
                applications. At most, desktop applications can open multiple
                windows, but usually they work with a single main window, with an
                occasional dialog window here and there. Same goes usually for web
                applications developed with Vaadin: an application typically
                runs on a single page, changing the layout as needed and popping up
                dialog boxes.
            </para>

            <para>
                Not having to load pages and use hyperlinks to communicate all user
                interaction is a relief for application development. However, they
                are an important feature that ordinary desktop applications
                lack. They allow referencing different functionalities of an
                application or resources managed by the application. They are also
                important for integration with external applications.
            </para>

            <para>
                Certain resources can be identified through a <firstterm>URL</firstterm> or
                <firstterm>Uniform Resource Locator</firstterm>.  A URL can easily be passed
                around or stored as a bookmark. We will see in <xref
                    linkend="advanced.requesthandler"/> how you can retrieve the URL path or query
                parameters of a request.
            </para>

            <para>
                Using URIs or request parameters to access functionalities or content is
                not as straight-forward as in conventional page-based web
                applications. Vaadin, just as any other AJAX framework, uses browser
                cookies not just for tracking users but also for tracking the application
                state. Cookies are unique in a browser, so any two windows share the same
                cookies and therefore also the state. The advantage is that you can close
                your browser and open it again and the application will be in the state
                where you left off (except for components such as text fields which did
                not have the immediate attribute enabled). The disadvantage is that there
                is no good way to distinguish between the windows, so there can usually be
                only a single application window. Even if there were several, you would
                have trouble with synchronization of application data between
                windows. Many conventional page-based web applications simply ignore
                out-of-sync situations, but such situations are risky for application
                platforms that are intended to be stable. Therefore it is safer to work
                with a single browser window. A URI can be used to fetch
                resources that have no particular state or to provide an entry point to
                the application.
            </para>

			<para>
				With all the fuss and pomp it receives, AJAX is essentially made possible
				by a simple API, namely the <methodname>XMLHttpRequest</methodname> class
				in JavaScript. The API is available in all major browsers and, as of 2006,
				the API is under way to become a W3C standard.
			</para>

			<para>
				Communications between the browser and the server usually require some
				sort of <emphasis>serialization</emphasis> (or
				<emphasis>marshalling</emphasis>) of data objects. The Vaadin terminal
				adapter handles serialization of shared state between server and client,
				as well as RPC calls to the other side.
			</para>
		</section>

		<section xml:id="architecture.technology.gwt">
			<title>Google Web Toolkit</title>

			<para>
                <indexterm significance="preferred"><primary>Google Web Toolkit</primary></indexterm>

                Vaadin includes the Google Web Toolkit, which is a user interface
                framework for developing client-side web applications easily, without
                having to use JavaScript or other browser technologies directly. Pure
                client-side Vaadin applications are developed with Java and compiled into
                JavaScript with the GWT Compiler.
			</para>

			<para>
				GWT is essentially a client-side technology, normally used to develop user
				interface logic in the web browser. GWT applications still need to
				communicate with a server using RPC calls and by serializing any
				data. Vaadin effectively hides all client-server communications, allows
				handling user interaction logic in a server application, and allows
				software development in a single server-side application. This makes the
				architecture of an AJAX-based web application much simpler.
			</para>

			<para>
				Vaadin uses GWT to render user interfaces in the web browser and
				handle the low-level tasks of user interaction in the browser. Use of GWT is
				largely invisible in Vaadin for applications that do not need any
				custom GWT components.
			</para>

			<para>
				See <xref linkend="architecture.client-side"/> for a description of how
				GWT is used in the Client-Side Engine of Vaadin. <xref linkend="gwt"/>
				provides information about the client-side development, as well as about
				the integration of client-side widgets with the server-side.
			</para>
		</section>
	</section>

	<section xml:id="architecture.server-side">
		<title>Applications as Java Servlet Sessions</title>

		<para>
			Vaadin framework does basically everything it does on top of the Java
			Servlet API, which lies hidden deep under the hood, with the terminal adapter
			being the lowest level layer for handling requests from the web
			container.
        </para>

        <para>
            When the web container gets the first request for a URL registered for an
            application, it creates an instance of the
            <classname>ApplicationServlet</classname> class in Vaadin framework
            that inherits the <classname>HttpServlet</classname> class defined in Java
            Servlet API. It follows sessions by using <classname>HttpSession</classname>
            interface and associates an <classname>Application</classname> instance with
            each session. During the lifetime of a session, the framework relays user
            actions to the proper application instance, and further to a user interface
            component.
		</para>
    </section>
		
	<section xml:id="architecture.client-side">
		<title>Client-Side Engine</title>

		<para>
            <indexterm significance="preferred"><primary>Client-Side Engine</primary></indexterm>
            
			This section gives an overview of the client-side architecture of
			Vaadin. Knowledge of the client-side technologies is generally not needed
			unless you develop or use custom client-side widgets.

            <indexterm><primary>Google Web Toolkit</primary></indexterm>
            <indexterm><primary>Java</primary></indexterm>

            The client-side engine is based on Google Web Toolkit (GWT) and its GWT
            Compiler, which allows the development of the engine and client-side
            components solely with Java.
		</para>

		<para>
			<xref linkend="gwt"/> provides information about the integration of
			GWT-based user interface components with Vaadin.
		</para>

		<figure xml:id="figure.architecture.client-side">
			<title>Architecture of Vaadin Client-Side Engine</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/arch/clientside-arch-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75"  smallscale="60%" align="center" fileref="img/arch/clientside-arch-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			<xref linkend="figure.architecture.client-side"/> illustrates the architecture
			of the client-side engine using a button component as an example. The user
			interface is managed by the <classname>ApplicationConnection</classname>
			class, which handles AJAX requests to the server and renders the user
			interface according to responses. In the server-side application, the button
			is used with the <classname>Button</classname> class of Vaadin. On the
			client-side, the user interface consists of various GWT components that
			inherit <classname>Widget</classname> class. In the figure above, the GWT
			class <classname>Button</classname> is used to render the button in the
			browser (the inheritance of <classname>Button</classname> is simplified in the
			figure). Vaadin provides an <classname>VButton</classname> class, which
			implements the <classname>Paintable</classname> interface needed for rendering
			the component with GWT.
		</para>

		<para>
			The actual initial web page that is loaded in the browser is an empty page
			that loads the JavaScript code of the Vaadin Client-Side Engine.
			After it is loaded and started, it handles the AJAX requests to the
			server. All server communications are done through the
			<classname>ApplicationConnection</classname> class.
		</para>
	</section>

	<section xml:id="architecture.events">
		<title>Events and Listeners</title>

		<para>
            Vaadin offers an event-driven programming model for handling user interaction.
            When a user does something in the user interface, such as clicks a button or
            selects an item, the application needs to know about it. Many Java-based user
            interface frameworks follow the Event-Listener pattern (also known as the
            Observer design pattern) to communicate user input to the application logic.
            So does Vaadin. The design pattern involves two kinds of elements: an object
            that generates ("fires" or "emits") events and a number of listeners that
            listen for the events. When such an event occurs, the object sends a
            notification about it to all the listeners. In a typical case, there is only
            one listener.
		</para>

		<para>
            Events can serve many kinds of purposes. In Vaadin, the usual purpose of
            events is handling user interaction in a user interface. Session management
            can require special events, such as for time-out, in which case the event
            would actually be the lack of user interaction. Time-out is a special case of
            timed or scheduled events, where an event occurs at a specific date and time
            or when a set time has passed. Database and other asynchronous communications
            can cause events as well.
		</para>

		<para>
            To receive events of a particular type, an application must register a
            listener object with the event source. The listeners are registered in the
            components with the <methodname>addListener()</methodname> method. The method
            has a generic version defined at the level of
            <classname>AbstractComponent</classname>, the base class of all components.
		</para>

		<para>
			Most components that have related events define their own event class and
			corresponding listener classes. For example, the <classname>Button</classname>
			has <classname>Button.ClickEvent</classname> events, which can be listened to
			through the <classname>Button.ClickListener</classname> interface.
        </para>

        <para>
            In the following, we handle button clicks with a listener implemented as an
            anonymous class:
        </para>

		<programlisting><![CDATA[final Button button = new Button("Push it!");

button.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        button.setCaption("You pushed it!");
    }
});]]></programlisting>

		<para>
			<xref linkend="figure.eventlistenerdiagram"/> illustrates the case where an
			application-specific class inherits the
			<classname>Button.ClickListener</classname> interface to be able to listen for
			button click events. The application must instantiate the listener class and
			register it with <methodname>addListener()</methodname>. When an event occurs,
			an event object is instantiated, in this case a
			<classname>ClickEvent</classname>. The event object knows the related UI
			component, in this case the <classname>Button</classname>.
		</para>

        <!-- TODO: No SVG file for this drawing. -->
		<figure xml:id="figure.eventlistenerdiagram">
			<title>Class Diagram of a Button Click Listener</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/arch/events-classdiagram.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75"  smallscale="100%" align="center" fileref="img/arch/events-classdiagram.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			In the ancient times of C programming, <emphasis>callback functions</emphasis>
			filled largely the same need as listeners do now. In object-oriented
			languages, we have only classes and methods, not functions, so the application
			has to give a class interface instead of a callback function pointer to the
			framework. However, Vaadin supports defining a method as a listener as well,
			using the <classname>MethodListener</classname> wrapper.
		</para>

		<para>
			Notice that many listener interfaces inherit the
			<classname>java.util.EventListener</classname> superinterface, but it
			is not generally necessary to inherit it.
		</para>

        <para>
            <xref linkend="application.events"/> goes into details of handling events in
            practice.
        </para>

	</section>

</chapter>
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
