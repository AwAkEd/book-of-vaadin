<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="mobile">
	<title>Mobile Applications with TouchKit</title>

    <indexterm xml:id="term.touchkit" class="startofrange">
        <primary>TouchKit</primary>
    </indexterm>

    <para>
        This chapter describes how to write mobile applications using the Vaadin TouchKit.
    </para>

    <section xml:id="mobile.overview">
        <title>Overview</title>

        <para>
            Web browsing is becoming ever increasingly mobile and web applications need to
            satisfy users with both desktop computers and mobile devices, such as phones
            and tablets. While the mobile browsers can show the pages just like in regular
            browsers, the screen size, finger accuracy, and mobile browser features need
            to be considered to make the experience more pleasant. Vaadin TouchKit gives
            the power of Vaadin for creating mobile user interfaces that complement the
            regular web user interfaces of your applications. Just like the purpose of the
            Vaadin Framework is to make desktop-like web applications, the purpose of
            TouchKit is to allow creation of web applications that give the look and feel
            of native mobile applications.
        </para>

        <figure xml:id="figure.mobile.overview.touchkit">
            <title>The Vornitologist Demo for Vaadin TouchKit</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/vornitologist-maintabsheet-short.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Creating a mobile UI is much like a regular Vaadin UI. You can use all the
            regular Vaadin components and add-ons available from Vaadin Directory, but
            most importantly the special TouchKit components.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[@Theme("mobiletheme")
@Widgetset("com.example.myapp.MyAppWidgetSet")
@Title("My Mobile App")
public class SimplePhoneUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // Use the TouchKit TabBarView for content
        TabBarView mainView = new TabBarView();
        setContent(mainView);
        
        // Create a view - usually a regular class
        class MyView extends VerticalLayout {
            Table table = new Table("Planets", planetData());

            public MyView() {
                addComponent(new Label("This is a view"));
                table.setWidth("100%");
                table.setPageLength(table.size());
                addComponent(table);
                addComponent(new Button("Go"));
                setSpacing(true);
            }
        }
        mainView.addTab(new MyView(), "Planets");

        // Add some more sub-views
        mainView.addTab(new Label("Dummy"), "Map");
        mainView.addTab(new Label("Dummy"), "Settings");
    }
    ...
}]]></programlisting>

        <para>
            The resulting UI is shown in <xref linkend="figure.mobile.overview.example"/>.
        </para>

        <figure xml:id="figure.mobile.overview.example">
            <title>Simple TouchKit UI</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="50%" scale="70" align="center" fileref="img/mobile/simplephoneui.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            TouchKit supports many special mobile browser features, such as geolocation,
            home screen launching, splash screen, and web app mode, especially in iOS.
        </para>

        <para>
            In addition to developing regular server-side UIs, TouchKit allows a special
            <emphasis>offline mode</emphasis>, which is a client-side Vaadin UI that is
            stored in the browser cache and switched to automatically when the network
            connection is not available, either when starting the application or while
            using it. For more information, see <xref linkend="mobile.offline"/>.
        </para>

        <para>
            In this chapter, we first consider some special aspects of mobile
            browsing. Then, we look how to create a project that uses TouchKit. TouchKit
            offers a number of specialized mobile components, which are described in a
            dedicated section. We treat phone and tablet applications separately, and
            discuss testing briefly.
        </para>

        <simplesect xml:id="mobile.overview.examples">
            <title>Vornitologist and Mobile Mail Demos</title>

            <para>
                The Vornitologist is a demo application that showcases most of the
                features in TouchKit. You can try it out at <link
                xlink:href="http://demo.vaadin.com/vornitologist">http://demo.vaadin.com/vornitologist</link>
                with your iOS or Android device. You can read the sources on-line or check
                them out from the repository and import them in Eclipse as described in
                <xref linkend="mobile.installation.vornitologist"/>.
            </para>

            <para>
                The Mobile Mail is another demo application, which shows how to implement
                browsing of deep category trees and make forms.
            </para>
        </simplesect>

        <simplesect xml:id="mobile.overview.license">
            <title>Licensing</title>

            <para>
                Vaadin TouchKit is a commercial product licensed under a dual-licensing
                scheme. The AGPL license allows open-source development, while the CVAL
                license needs to be purchased for closed-source use, including web
                deployments and internal use. Commercial licenses can be purchased from
                the Vaadin Directory, where you can also find the license details and
                download Vaadin TouchKit.
            </para>
        </simplesect>
    </section>

    <section xml:id="mobile.considerations">
        <title>Considerations Regarding Mobile Browsing</title>

        <para>
            When developing web applications that support mobile browsing, you need to
            consider various issues that are different from non-mobile use. TouchKit is
            designed to help with these issues.
        </para>
        
        <section xml:id="mobile.considerations.mobile-hi">
            <title>Mobile Human Interface</title>

            <para>
                Mobile devices use very different human interfaces than regular
                computers. For example, the screen can be rotated easily to switch between
                portrait and landscape views. This does not just change the dimensions of
                the display, but also affects the most useful layout.
            </para>

            <para>
                The user interface is used with a finger instead of a mouse, so there are
                no features such as "right-finger-button". Double-tap is not normally used
                in mobile user interfaces, unlike the double-click with a mouse. Instead,
                a "long tap" usually has the same meaning as the double click. Finger
                gestures also play a large role, such as using a vertical swipe gesture
                for scrolling instead of a scroll bar.
            </para>

            <para>
                There is normally no physical but a virtual keyboard, and the keyboard can
                change depending on the context. You also need to ensure that it does not
                hide the input field to which the user is trying to enter data when it
                pops up. This should be handled by the browser, but is among the issues
                that requires special testing.
            </para>
        </section>

        <section xml:id="mobile.considerations.bandwidth">
            <title>Bandwidth</title>
            
            <para>
                Mobile Internet connections are often significantly slower than with fixed
                lines. With a low-end mobile connection, such as 384 kbps, just loading
                the Vaadin client-side engine can take several seconds. This can be helped
                by compiling a widget set that includes only the widgets for the used
                components, as described in <xref linkend="mobile.optimization"/>.
            </para>

            <para>
                Even with mobile broadband, the latency can be significant factor, especially
                with highly interactive rich applications. The latency is usually almost
                unnoticeable in fixed lines, typically less than 100 ms, while mobile Edge
                connections typically have latency around 500 ms, and sometimes much higher
                during hiccups. You may need to limit the use of the immediate mode, text
                change events, and polling.
            </para>
        </section>

        <section xml:id="mobile.considerations.features">
            <title>Mobile Features</title>

            <para>
                Phones and tablets have many integrated features that are often available in
                the browser interface as well. Location-awareness is one of the most recent
                features. And of course, you can also make phone calls.
            </para>
        </section>

        <section xml:id="mobile.considerations.compatibility">
            <title>Compatibility</title>

            <para>
                The mobile browsing field is currently evolving at fast pace and the
                special conventions that are introduced by leading manufacturers may, in
                the next few years, stabilize as new web standards. The browser support in
                TouchKit concentrates on WebKit, which appears to be emerging as the
                leading mobile browser core. In addition to Apple's products, also the
                default browser in Android uses WebKit as the layout engine. Yet they have
                differences, as the Android's JavaScript engine, which is highly relevant
                for Vaadin, is the Google Chrome's V8 engine.
            </para>

            <para>
                Vaadin TouchKit aims to follow the quickly evolving APIs of these major
                platforms, with the assumption that other browsers will follow their lead
                in standardization. Other platforms will be supported if they rise in
                popularity.
            </para>

            <section xml:id="mobile.considerations.compatibility.backbutton">
                <title>Back Button</title>

                <para>
                    Some mobile devices, especially Android devices, have a dedicated back
                    button, while iOS devices in particular do not. TouchKit does not
                    provide any particular support for the button, but as it is a regular
                    browser back button, you can handle it with URI fragments<phrase condition="web">, as
                    described in <xref linkend="advanced.urifu"/></phrase>. For iOS, the browser
                    back button is hidden if the user adds the application to the home
                    screen, in which case you need to implement application-specific logic
                    for the back-navigation.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="mobile.installation" condition="web">
        <title>Installing Vaadin TouchKit</title>

        <para>
            You can download and install TouchKit from the Vaadin Directory at <link
            xlink:href="https://vaadin.com/addon/vaadin-touchkit">https://vaadin.com/addon/vaadin-touchkit</link>
            as an installation package, or get it with Maven or Ivy. If your project
            requires the use of the CVAL license, licences can be purchased from the
            Directory.
        </para>

        <para>
            Add-on installation is described in detail in <xref linkend="addons"/>. The
            add-on includes a widget set, so you need to compile the widget set for your
            project.
        </para>
        
        <section xml:id="mobile.project.ivy" condition="web">
            <title>Installing as Ivy Dependency</title>

            <para>
                If you use the add-on in an Eclipse project created with the Vaadin Plugin
                for Eclipse, you can define an Ivy dependency to automatically download
                the library. Include the following declaration inside the
                <literal>dependencies</literal> section in the
                <filename>ivy.xml</filename>:
            </para>

            <programlisting>&lt;dependency org="com.vaadin.addon"
               name="vaadin-touchkit-agpl"
               rev="<emphasis role="bold">3.0.0</emphasis>"
               conf="default->default" /&gt;</programlisting>

            <para>
                You can use <literal>latest.release</literal> revision tag to always use
                the latest release. IvyDE should resolve the dependency immediately as you
                save the file. See <xref linkend="addons.eclipse"/> for further details.
            </para>
        </section>

        <section xml:id="mobile.project.downloading" condition="web">
            <title>Installing the Zip Package</title>

            <para>
                Vaadin TouchKit is distributed as a Zip package that contains the TouchKit
                JAR, a JavaDoc JAR, license texts, and other documentation.  You can
                download the Zip package from the Vaadin Directory. A different package is
                provided for each of the two licenses, and the Directory asks for your
                choice.
            </para>

            <para>
                The TouchKit JAR in the package should be put in the
                <filename>WEB-INF/lib</filename> folder of the web application.
            </para>

            <para>
                Please see the <filename>README.html</filename> for more information about
                the package contents.
            </para>

            <section xml:id="mobile.installatin.downloading.dependencies">
                <title>Library Dependencies</title>

                <para>
                    TouchKit requires the Reflections library for compiling the widget
                    set. You can get the JAR from <link
                    xlink:href="http://code.google.com/p/reflections/">http://code.google.com/p/reflections/</link>.
                </para>
            </section>
        </section>

        <section xml:id="mobile.installation.maven" condition="web">
            <title>Installing in Maven</title>

            <para>
                You can install Vaadin TouchKit in a Maven project by adding it a
                dependency, as described first below. <!-- TODO re-enable If you are
                creating a new project, you can use the TouchKit Maven archetype to create
                a project skeleton. -->
            </para>

            <section xml:id="mobile.installation.maven.dependency">
                <title>Defining as a Dependency</title>

                <para>
                    To use TouchKit in a Vaadin project, you need to include the following
                    dependency in the POM. The <literal>artifactId</literal> should be
                    <literal>vaadin-touchkit-agpl</literal> or
                    <literal>vaadin-touchkit-cval</literal>, depending on your choise for
                    the license.
                </para>

                <programlisting>&lt;dependency&gt;
   &lt;groupId&gt;com.vaadin.addon&lt;/groupId&gt;
   &lt;artifactId&gt;vaadin-touchkit-<emphasis role="bold">agpl</emphasis>&lt;/artifactId&gt;
   &lt;version&gt;<emphasis role="bold">LATEST</emphasis>&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

                <para>
                    You can use the <parameter>LATEST</parameter> version as shown above
                    or a specific version by its version number.
                </para>

                <para>
                    You also need to define the repository for the Vaadin add-ons under
                    the <literal>&lt;repositories&gt;</literal> element:
                </para>

                <programlisting><![CDATA[<repository>
   <id>vaadin-addons</id>
   <url>http://maven.vaadin.com/vaadin-addons</url>
</repository>]]></programlisting>

                <para>
                    You also need to enable the widget set compilation in the POM, as
                    described in <xref linkend="addons.maven.widgetset"/>, and compile it.
                </para>
            </section>
            
            <!-- TODO re-enable when available for Vaadin 7
            <simplesect xml:id="mobile.installation.maven.archetype">
                <title>Using the Archetype</title>

                <para>
                    You can create a new TouchKit application project using the Maven
                    <parameter>vaadin-archetype-touchkit</parameter> archetype, as
                    described in <xref linkend="getting-started.maven"/>.
                </para>

                <para>
                    For example, from command-line, you could do:
                </para>

                <screen><prompt>$</prompt> <command>mvn</command> archetype:generate \
  -DarchetypeGroupId=com.vaadin \
  -DarchetypeArtifactId=vaadin-archetype-touchkit \
  -DgroupId=<replaceable>example.com</replaceable> -DartifactId=<replaceable>myproject</replaceable> \
  -Dversion=<replaceable>0.1.0</replaceable> -Dpackaging=war</screen>

            </simplesect> -->
        </section>

        <section xml:id="mobile.installation.vornitologist">
            <title>Importing the Vornitologist Demo</title>

            <para>
                The Vornitologist demo, illustrated in <xref
                linkend="figure.mobile.overview.touchkit"/> in the overview, showcases
                most of the functionality in Vaadin TouchKit. You can try the demo on-line
                with a TouchKit-compatible browser at <link
                xlink:href="http://demo.vaadin.com/vornitologist/">http://demo.vaadin.com/vornitologist/</link>.
            </para>

            <para>
                You can browse the sources on-line or, more conveniently, import the
                project in Eclipse (or other IDE). As the project is Maven-based, eclipse
                users need to install the m2e (or m2eclipse for older versions) plugin to
                be able to import Maven projects, as well as Subclipse for making SVN
                access easier. Once they are installed, you should be able to import
                Vornitologist as follows.
            </para>

            <orderedlist>
                <listitem>Select <menuchoice><guimenu>File</guimenu><guimenuitem>Import</guimenuitem></menuchoice></listitem>
                <listitem>Select <menuchoice><guimenu>Maven</guimenu><guimenuitem>Check out Maven Project from SCM</guimenuitem></menuchoice>, and click <guibutton>Next</guibutton>.</listitem>

                <listitem>
                    In <guilabel>SCM URL</guilabel>, select <guilabel>svn</guilabel> and
                    enter URL for the repository. You can find the current repository URL
                    from the TouchKit add-on page at <link
                    xlink:href="http://dev.vaadin.com/svn/addons/TouchKit">http://dev.vaadin.com/svn/addons/TouchKit</link>.
                </listitem>

                <listitem>Click <guibutton>Finish</guibutton>.</listitem>
            </orderedlist>

            <para>
                Instead of using Subclipse, you can check out the project with another
                Subversion tool and then import it in Eclipse as a Maven project.
            </para>
        </section>
    </section>

    <section xml:id="mobile.project">
        <title>Elements of a TouchKit Application</title>

        <para>
            At minimum, a TouchKit application requires a UI class, which is defined in a
            deployment descriptor, as usual for Vaadin applications. You usually also need
            to have a custom theme. To enable various other features, you may need to
            provide a custom servlet. These and other tasks are described in the following
            subsections.
        </para>
        
        <section xml:id="mobile.project.webxml">
            <title>Deployment Descriptor</title>

            <para>
                The deployment descriptor of a TouchKit application is much like for any
                Vaadin application. However, you need to use the special
                <classname>TouchKitServlet</classname> class instead of the regular
                <classname>VaadinServlet</classname> in the <filename>web.xml</filename>
                deployment descriptor.  Often you need to make some configuration or add
                special logic in a custom servlet, as described in the next section, in
                which case you need to define your servlet in the deployment descriptor.
            </para>

            <programlisting><?pocket-size 65% ?>&lt;servlet&gt;
  &lt;servlet-name&gt;Vaadin UI Servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;
    <emphasis role="bold">com.vaadin.addon.touchkit.server.TouchKitServlet</emphasis>
  &lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;description&gt;Vaadin UI class to start&lt;/description&gt;
    &lt;param-name&gt;ui&lt;/param-name&gt;
    &lt;param-value&gt;<emphasis role="bold">com.example.myapp.MyMobileUI</emphasis>&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;</programlisting>
        </section>

        <section xml:id="mobile.project.servlet">
            <title>Creating a Custom Servlet</title>

            <para>
                Some tasks can only be done in the initial request to the server, before
                the UI is created. You need to make a custom servlet class if you want to
                use the following TouchKit features:
            </para>

            <itemizedlist>
                <listitem>Customize bookmark or home screen icon</listitem>
                <listitem>Customize splash screen image</listitem>
                <listitem>Customize status bar in iOS</listitem>
                <listitem>Use special web app mode in iOS</listitem>
                <listitem>Provide a fallback UI (<xref linkend="mobile.features.fallback"/>)</listitem>
                <listitem>Enable offline mode</listitem>
            </itemizedlist>

            <para>
                A custom servlet should normally extend the
                <classname>TouchKitServlet</classname>. You should place your code in
                <methodname>servletInitialized()</methodname> and call the super method in
                the beginning.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet {
    @Override
    protected void servletInitialized() throws ServletException {
        super.servletInitialized();

        ... customization ...
    }
}]]></programlisting>

            <para>
                If you need to rather extend some other servlet, possibly in another
                add-on, it should be trivial to reimplement the functionality of
                <classname>TouchKitServlet</classname>, which is just to manage the
                TouchKit settings object.
            </para>
        </section>

        <section xml:id="mobile.project.settings">
            <title>TouchKit Settings</title>

            <para>
                TouchKit has a number of settings that you can customize for your
                needs. The <classname>TouchKitSettings</classname> configuration object is
                managed by <classname>TouchKitServlet</classname>, so if you make any
                modifications to it, you need to implement a custom servlet, as described
                earlier.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet {
    @Override
    protected void servletInitialized() throws ServletException {
        super.servletInitialized();

        TouchKitSettings s = getTouchKitSettings();
        ...
    }
}]]></programlisting>

            <para>
                The settings include special settings for iOS devices, which are contained
                in a separate <classname>IosWebAppSettings</classname> object, available
                from the TouchKit settings with
                <methodname>getIosWebAppSettings()</methodname>.
            </para>

            <section xml:id="mobile.project.settings.icons">
                <title>Application Icons</title>

                <para>
                    The location bar, bookmarks, and other places can display an icon for
                    the web application. You can set the icon, or more exactly icons, in
                    an <classname>ApplicationIcons</classname> object, which manages icons
                    for different resolutions. The most properly sized icon for the
                    context is used. iOS devices prefer icons with 57&#215;57,
                    72&#215;72, and 144&#215;144 pixels, and Android devices
                    36&#215;36, 48&#215;48, 72&#215;72, and 96&#215;96 pixels.
                </para>

                <para>
                    You can add an icon to the application icons collection with
                    <methodname>addApplicationIcon()</methodname>.  You
                    can acquire the base URL for your application from the servlet
                    context, as shown in the following example.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();
String contextPath = getServletConfig()
    .getServletContext().getContextPath();
s.getApplicationIcons().addApplicationIcon(
    contextPath + "VAADIN/themes/mytheme/icon.png");]]></programlisting>

                <para>
                    The basic method just takes the icon name, while the other one lets
                    you define its size. It also has a <parameter>preComposed</parameter>
                    parameter, which when true, instructs Safari from adding effects to
                    the icon in iOS.
                </para>
            </section>

            <section xml:id="mobile.project.settings.viewport">
                <title>Viewport Settings</title>

                <para>
                    The <classname>ViewPortSettings</classname> object, which you can get
                    from the TouchKit settings with
                    <methodname>getViewPortSettings()</methodname>, manages settings
                    related to the display, most importantly the scaling limitations.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();
ViewPortSettings vp = s.getViewPortSettings();
vp.setViewPortUserScalable(true);
...]]></programlisting>

                <para>
                    See the <link
                    xlink:href="http://developer.apple.com/library/safari/">Safari
                    Development Library</link> at the Apple developer's site for more
                    details regarding the functionality in the iOS browser.
                </para>
            </section>

            <section xml:id="mobile.project.settings.splash">
                <title>Startup Image for iOS</title>

                <para>
                    iOS browser supports a startup (splash) image that is shown while the
                    application is loading. You can set it in the
                    <classname>IosWebAppSettings</classname> object with
                    <methodname>setStartupImage()</methodname>. You can acquire the base
                    URL for your application from the servlet context, as shown in the
                    following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();
String contextPath = getServletConfig().getServletContext()
    .getContextPath();
s.getIosWebAppSettings().setStartupImage(
    contextPath + "VAADIN/themes/mytheme/startup.png");]]></programlisting>

            </section>

            <section xml:id="mobile.project.settings.webapp">
                <title>Web App Capability for iOS</title>

                <para>
                    iOS supports a special web app mode for bookmarks added and started
                    from the home screen. With the mode enabled, the client may, among
                    other things, hide the browser's own UI to give more space for the web
                    application. The mode is enabled by a header that tells the browser
                    whether the application is designed to be used as a web application
                    rather than a web page.
                </para>

                <programlisting><![CDATA[TouchKitSettings s = getTouchKitSettings();
s.getIosWebAppSettings().setWebAppCapable(true);]]></programlisting>

                <para>
                    See the <link
                    xlink:href="http://developer.apple.com/library/safari/">Safari
                    Development Library</link> at the Apple developer's site for more
                    details regarding the functionality in the iOS browser.
                </para>
            </section>

            <section xml:id="mobile.project.settings.cache">
                <title>Cache Manifest</title>

                <para>
                    The <classname>ApplicationCacheSettings</classname> object manages the
                    cache manifest, which is used to configure how the browser caches the
                    page and other resources for the web app. See <xref
                    linkend="mobile.offline"/> for more details about its use.
                </para>
            </section>
        </section>

        <section xml:id="mobile.project.ui">
            <title>The UI</title>

            <para>
                Mobile UIs extend the <classname>UI</classname> class as usual and
                construct the user interface from components.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[@Theme("mobiletheme")
@Widgetset("com.example.myapp.MyAppWidgetSet")
@Title("My Simple App")
public class SimplePhoneUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // Create the content root layout for the UI
        TabBarView mainView = new TabBarView();
        setContent(mainView);

        ...
    }
}]]></programlisting>

            <para>
                As TouchKit comes with a custom widget set, you need to use a combining
                widget set for your project, defined with the
                <literal>@Widgetset</literal> annotation for the UI. The combining widget
                set descriptor is automatically generated by the Vaadin Plugin for Eclipse
                and in Maven when you install or define the TouchKit add-on.
            </para>

            <para>
                Most commonly, you will use a combination of the major three TouchKit
                components as the basis of the UI: <classname>TabBarView</classname>,
                <classname>NavigationView</classname>, or
                <classname>NavigationManager</classname>.
            </para>

            <para>
                If a offline UI is provided, it needs to be enabled in the initialization
                of the UI, as described in <xref linkend="mobile.offline"/>.
            </para>
        </section>

        <!-- TODO
        <section xml:id="mobile.project.phonevstablet">
            <title>Phone and Tablet UIs</title>

            <para>
                The displays in mobile phones and tablets can have very different sizes,
                so you may want to provide optimized views for each. You can get the
                display size in pixels from the browser info
            </para>
        </section>
        -->

        <section xml:id="mobile.project.widgetset">
            <title>Mobile Widget Set</title>

            <para>
                TouchKit includes a widget set and therefore requires compiling a project
                widget set that includes it, as described in <xref
                linkend="addons"/>. The project widget set descriptor is
                automatically generated during the compilation process, whether you use
                Maven or the Eclipse plugin.
            </para>

            <para>
                With certain TouhcKit tasks, such as when defining an optimized widget set
                as described in <xref linkend="mobile.optimization"/>, you need to provide
                a hand-modified widget set descriptor. In such case, you need to prevent
                the automatic generation of the descriptor with the following line in it:
            </para>

            <programlisting>&lt;!-- WS Compiler: manually edited  --&gt;</programlisting>

            <para>
                Note that if you have a TouchKit UI in a same project as a non-TouchKit
                UI, you probably do not want to compile the TouchKit widget set into its
                widget set. As the automatic generation of the descriptor includes all the
                widget sets that it finds from the class path, the result can be
                unwanted. You can use a manually edited descriptor also in that case.
            </para>
        </section>
    </section>

    <section xml:id="mobile.components">
        <title>Mobile User Interface Components</title>

        <para>
            TouchKit introduces a number of components special to mobile user interfaces
            to give better user interaction and to utilize the special features in mobile
            devices.
        </para>

        <section xml:id="mobile.components.navigationview">
            <title><classname>NavigationView</classname></title>
            
            <para>
                The <classname>NavigationView</classname> is a layout component that consists
                of a navigation bar and a content area. The content area is scrollable, so
                there is no need to use an inner panel component. In addition, there can be an
                optional toolbar component at the bottom of the
                view. A <classname>NavigationView</classname> is often used inside a
                <classname>NavigationManager</classname> to get view change animations.
            </para>

            <figure xml:id="figure.mobile.components.navigationview">
                <title>Layout of the <classname>NavigationView</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/mobile/navigationview-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/navigationview-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <classname>NavigationView</classname> has a full size by default. The content
                area is expanding, so that it takes all the space left over from the navigation
                bar and toolbar.
            </para>

            <section xml:id="mobile.components.navigationview.navigationbar">
                <title>Navigation Bar</title>

                <para>
                    The navigation bar at the top of <classname>NavigationView</classname> is
                    a <classname>NavigationBar</classname> component. It has two component
                    slots, with one on the left and one on the right. The caption is displayed
                    in the middle. The <classname>NavigationBar</classname> can be used elsewhere
                    as well, such as for a view containing a form with save and cancel buttons
                    in the upper right and left corners.
                </para>

                <para>
                    When the <classname>NavigationBar</classname> is used for navigation and you
                    set the previous component with
                    <methodname>setPreviousComponent()</methodname>, the left slot is
                    automatically filled with a <guibutton>Back</guibutton> button. This is
                    done automatically if you use the <classname>NavigationView</classname>
                    inside a <classname>NavigationManager</classname>.
                </para>

                <para>
                    You can get access to the navigation bar component with
                    <methodname>getNavigationBar()</methodname> to use its manipulator methods
                    directly, but <classname>NavigationView</classname> also offers some
                    shorthand methods: <methodname>setLeftComponent()</methodname>,
                    <methodname>setRightComponent()</methodname>, and a setter and a getter
                    for the caption.
                </para>
            </section>

            <section xml:id="mobile.components.navigationview.toolbar">
                <title>Toolbar</title>

                <para>
                    A slot for an optional toolbar is located at the bottom of the
                    <classname>NavigationView</classname>. The toolbar can be any component,
                    but a <classname>Toolbar</classname> component made for this purpose is
                    included in TouchKit. It is described in <xref
                        linkend="mobile.components.toolbar"/>. You could also use a
                    <classname>HorizontalLayout</classname> or
                    <classname>CssLayout</classname>.
                </para>

                <para>
                    You usually fill the tool bar with <classname>Button</classname>
                    components with an icon and no textual caption. You set the toolbar with
                    <methodname>setToolbar()</methodname>.
                </para>
            </section>

            <section xml:id="mobile.components.navigationview.css">
                <title>Styling with CSS</title>
                
                <programlisting><![CDATA[.v-touchkit-navview { }
  .v-touchkit-navview-wrapper {}
  .v-touchkit-navview-toolbar {}
.v-touchkit-navview .v-touchkit-navview-notoolbar {}]]></programlisting>

                <para>
                    The root element has the <literal>v-touchkit-navview</literal> class. The
                    content area is wrapped inside a
                    <literal>v-touchkit-navview-wrapper</literal> element. If the view has a
                    toolbar, the toolbar slot has the
                    <literal>v-touchkit-navview-toolbar</literal> style, but if not, the
                    top-level element has the <literal>v-touchkit-navview-notoolbar</literal>
                    style.
                </para>
            </section>
        </section>

        <!-- TODO <section xml:id="mobile.components.navigationbar">
    <title><classname>NavigationBar</classname></title>

        <para>
            
        </para>
    </section> -->

        <section xml:id="mobile.components.toolbar">
            <title><classname>Toolbar</classname></title>

            <para>
                The <classname>Toolbar</classname> is a layout component that extends
                <classname>CssLayout</classname>, usually containing
                <classname>Button</classname> components. The toolbar has by default 100%
                horizontal width and a fixed height. The components are spread evenly
                in the horizontal direction. <classname>Toolbar</classname> is typically used
                in a <classname>NavigationView</classname>, as described in <xref
                    linkend="mobile.components.navigationview" xrefstyle="select:label"/>.
            </para>

            <para>
                For a description of the inherited features, please refer to <xref
                    linkend="layout.orderedlayout"/>.
            </para>

            <section xml:id="mobile.components.toolbar.css">
                <title>Styling with CSS</title>
                
                <programlisting><![CDATA[.v-touchkit-toolbar { }]]></programlisting>
                
                <para>
                    The component has an overall <literal>v-touchkit-toolbar</literal> style in
                    addition to the <literal>v-csslayout</literal> style of the
                    superclass. Other style names are as for 
                    <classname>CssLayout</classname>.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.navigationpanel">
            <title><classname>NavigationManager</classname></title>
            
            <para>
                The <classname>NavigationManager</classname> is a visual effect component that
                gives sliding animation when switching between views. You can register
                three components: the currently displayed component,
                the previous one on the left, and the next component on the right. You can set
                these components with <methodname>setCurrentComponent()</methodname>,
                <methodname>setPreviousComponent()</methodname>, and
                <methodname>setNextComponent()</methodname>, respectively. 
            </para>

            <para>
                The <classname>NavigationManager</classname> component is illustrated in <xref
                    linkend="figure.mobile.components.navigationpanel"/>.
            </para>

            <figure xml:id="figure.mobile.components.navigationpanel">
                <title><classname>NavigationManager</classname> with Three <classname>NavigationView</classname>s</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/mobile/navigationpanel-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" scale="80" align="center" fileref="img/mobile/navigationpanel-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The navigation manager is important for responsiveness, because the previous and
                next components are cached and the slide animation started before server is
                contacted to load the new next or previous views.
            </para>

            <para>
                Switching between the views is done programmatically according to user
                interaction; swipe gestures are not supported at the moment.
            </para>

            <section xml:id="mobile.components.navigationpanel.viewhandling">
                <title>Handling View Changes</title>

                <para>
                    While you can put any components in the manager, some special features are
                    enabled when using the <classname>NavigationView</classname>. When a view
                    becomes visible, the <methodname>onBecomingVisible()</methodname> method
                    in the view is called. You can override it, just remember to call the
                    superclass method.
                </para>

                <programlisting><![CDATA[@Override
protected void onBecomingVisible() {
    super.onBecomingVisible();

    ...
}]]></programlisting>
            </section>

            <section xml:id="mobile.components.navigationpanel.breadcrump">
                <title>Tracking Breadcrumbs</title>

                <para>
                    <classname>NavigationManager</classname> also handles
                    <emphasis>breadcrumb</emphasis> tracking. The
                    <methodname>navigateTo()</methodname> pushes the current view on the top
                    of the breadcrumb stack and <methodname>navigateBack()</methodname> can be
                    called to return to the previous breadcrumb level.
                </para>

                <para>
                    Notice that calling <methodname>navigateTo()</methodname> with the
                    "previous" component is equivalent to calling
                    <methodname>navigateBack()</methodname>.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.navigationbutton">
            <title><classname>NavigationButton</classname></title>

            <para>
                The <classname>NavigationButton</classname> is a special version of the
                regular <classname>Button</classname> designed for navigation inside a
                <classname>NavigationManager</classname>, as described in <xref
                    linkend="mobile.components.navigationpanel"
                    xrefstyle="select:label"/>. Clicking the button will automatically navigate to
                the defined target view. The view change animation does not need to make a
                server request first, but starts immediately after clicking the button. If you
                leave the target view empty, an empty placeholder view is shown in the
                animation. The view is filled after it gets the content from the server.
            </para>

            <para>
                You can give the target view either in the constructor or with
                <methodname>setTargetView()</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[NavigationView view = new NavigationView("A View");
...
NavigationButton button = new NavigationButton("Click");
button.setTargetView(view);
...]]></programlisting>

            <para>
                Notice that the automatic navigation will only work if the button is inside a
                <classname>NavigationManager</classname> (in a view inside it). If you just
                want to use the button as a visual element, you can use it like a regular
                <classname>Button</classname> and handle the click events with a
                <classname>ClickListener</classname>.
            </para>

            <section xml:id="mobile.components.navigationbutton.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-navbutton { }
  .v-touchkit-navbutton-desc { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-navbutton</literal> style. If
                    the component description is set with
                    <methodname>setDescription()</methodname>, it is shown in a separate
                    <literal>&lt;span&gt;</literal> element with the
                    <literal>v-touchkit-navbutton-desc</literal> style.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.popover">
            <title><classname>Popover</classname></title>

            <para>
                <classname>Popover</classname> is much like a regular Vaadin sub-window,
                useful for quickly displaying some options or a small form related to an
                action. Unlike regular sub-windows, it does not support dragging or
                resizing by the user. As sub-windows usually require a rather large screen
                size, the <classname>Popover</classname> is most useful for tablet
                devices. When used on smaller devices, such as phones, the
                <classname>Popover</classname> automatically fills the entire screen.
            </para>

            <figure xml:id="figure.mobile.components.popover">
                <title><classname>Popover</classname> in a Phone</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="50%" scale="70" align="center" fileref="img/mobile/vornitologist-observations-popup.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                It is customary to use a <classname>NavigationView</classname> to have
                border decorations and caption. In the following, we subclass
                <classname>Popover</classname> to create the content.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[class DetailsPopover extends Popover {
    public DetailsPopover() {
        setWidth("350px");
        setHeight("65%");

        // Have some details to display
        VerticalLayout layout = new VerticalLayout();
        ...

        NavigationView c = new NavigationView(layout);
        c.setCaption("Details");
        setContent(c);
    }
}]]></programlisting>

            <para>
                A <classname>Popover</classname> can be opened relative to a component by
                calling <methodname>showRelativeTo()</methodname>. In the following
                example, we open the popover when a table item is clicked.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[
Table table = new Table("Planets", planetData());
table.addItemClickListener(new ItemClickListener() {
    @Override
    public void itemClick(ItemClickEvent event) {
        DetailsPopover popover = new DetailsPopover();

        // Show it relative to the navigation bar of
        // the current NavigationView.
        popover.showRelativeTo(view.getNavigationBar());
    }
});]]></programlisting>

            <para>
                You can also add the <classname>Popover</classname> to the
                <classname>UI</classname> with <methodname>addWindow()</methodname>.
            </para>

            <section xml:id="mobile.components.popover.close" condition="web">
                <title>Closing a Popover</title>

                <para>
                    When <parameter>closable</parameter> is enabled in a
                    <classname>Popover</classname>, as it is by default, it can be closed
                    by clicking anywhere outside the popup area. This may not be enough if
                    the popover fills the entire screen, in which case the user gets
                    stuck. The popover can be closed programmatically by calling
                    <methodname>close()</methodname>. You can, for example, add a
                    <interfacename>MouseEvents.ClickListener</interfacename> to the
                    popover to allow closing it by clicking anywhere inside it.
                </para>

                <para>
                    If the popover has editable fields, you may want to have a close
                    button in the navigation bar of the
                    <classname>NavigationView</classname>. In the following example, we
                    add a close button to the right slot of the navigation bar (you need
                    to include the icon in your theme).
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[class DetailsPopover extends Popover
      implements Button.ClickListener {
    public DetailsPopover(Table table, Object itemId) {
        setWidth("350px");
        setHeight("65%");
        Layout layout = new FormLayout();
        ... create the content ...

        // Decorate with navigation view
        NavigationView content = new NavigationView(layout);
        content.setCaption("Details");
        setContent(content);

        // Have a close button
        Button close = new Button(null, this);
        close.setIcon(new ThemeResource("close64.png"));
        content.setRightComponent(close);
    }

    public void buttonClick(ClickEvent event) {
        close();
    }
}]]></programlisting>

                <para>
                    Such a popover is shown in a tablet device as illustrated <xref
                    linkend="figure.mobile.components.popover.tablet"/>.
                </para>

                <figure xml:id="figure.mobile.components.popover.tablet">
                    <title><classname>Popover</classname> in a Tablet Device</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/vornitologist-observations-popup-tablet.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>

            <section xml:id="mobile.components.popover.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-popover .v-touchkit-fullscreen { }
  .v-touchkit-popover .v-touchkit-relative { }
  .v-touchkit-popover .v-touchkit-plain { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-popover</literal> style. If
                    full-screen, it also has the <literal>v-touchkit-fullscreen</literal> style, if
                    positioned relatively it has <literal>v-touchkit-relative</literal>, and if not,
                    the <literal>v-touchkit-plain</literal> style.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.switch">
            <title><classname>Switch</classname></title>

            <para>
                The <classname>Switch</classname> component is a
                <classname>CheckBox</classname> that looks like the switch button in Apple
                iOS.
            </para>

            <programlisting><![CDATA[Switch switch = new Switch();
switch.setCaption("Do I look like iOS?");
layout.addComponent(switch);]]></programlisting>

        <section xml:id="mobile.components.switch.css">
            <title>Styling with CSS</title>

            <programlisting><![CDATA[.v-touchkit-switch { }
  .v-touchkit-switch-slider { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-switch</literal> style. The slider
                    element has <literal>v-touchkit-switch-slider</literal> style.
                </para>
            </section>
        </section>
		
		<section xml:id="mobile.components.verticalcomponentgroup">
            <title><classname>VerticalComponentGroup</classname></title>
			<para>
				The <classname>VerticalComponentGroup</classname> is a layout component for grouping
                components in the vertical stack. The most typical use of the 
                <classname>VerticalComponentGroup</classname> is to make vertical navigation menus 
                containing <classname>NavigationButton</classname>s for the mobile application.
				The <classname>VerticalComponentGroup</classname> and 
				<classname>HorizontalComponentGroup</classname> both extend 
				<classname>AbstractComponentGroup</classname> which is inherited from the 
				<classname>AbstractComponentContainer</classname>.
				In the client side both component group widgets are extending the lightweigth 
				<classname>FlowPanel</classname>.
			</para>
			
			<section xml:id="mobile.components.verticalcomponentgroup.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-verticalcomponentgroup { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-verticalcomponentgroup</literal> 
                    style. If the component has a caption, the 
                    <literal>v-touchkit-has-caption</literal> style is added.
                </para>
            </section>
		</section>
		
		<section xml:id="mobile.components.horizontalcomponentgroup">
            <title><classname>HorizontalComponentGroup</classname></title>
			<para>
				The <classname>HorizontalComponentGroup</classname> is mainly intended to group buttons
				 inside the <classname>VerticalComponentGroup</classname> slots.
			</para>
			
			<programlisting><?pocket-size 65% ?><![CDATA[HorizontalComponentGroup horizontalCGroup = new HorizontalComponentGroup();
horizontalCGroup.addComponent(new Button("First"));
horizontalCGroup.addComponent(new Button("Another"));

NavigationButton navButton = new NavigationButton();
button.setIcon(new ThemeResource("../runo/icons/32/ok.png"));
        
VerticalComponentGroup verticalCGroup = new VerticalComponentGroup();
verticalCGroup.setMargin(true);

verticalCGroup.addComponent(horizontalCGroup);
verticalCGroup.addComponent(new Button("Button"));
verticalCGroup.addComponent(new TextField("TF's caption"));
verticalCGroup.addComponent(navButton);]]></programlisting>
			
		</section>

        <section xml:id="mobile.components.tabbarview">
            <title><classname>TabBarView</classname></title>
            
            <para>
                The <classname>TabBarView</classname> is a layout component that consist of
		a tab bar and content area. Each tab will have it's own content area which
		will be displayed when a correspoding tab is selected. TabBarView is inherited
		from the <classname>ComponentContainer</classname> but uses it's own specialized
		API for monipulating tabs. <methodname>removeComponent()</methodname> and
		<methodname>addComponent()</methodname> will throw an 
		<classname>UnsupportedOperationException</classname> if used.
	    </para>

<programlisting><![CDATA[TabBarView bar = new TabBarView();

//Create some Vaadin Component to use as content
Label content = new Label("Really simple content");

//Create a tab for it
Tab tab = bar.addTab(label);

//Set tab name and/or icon
tab.setCaption("tab name");
tab.setIcon(new ThemeResource(...));

//Programmatically modify tab bar
Tab selectedTab = bar.getSelectedTab();
bar.setSelectedTab(selectedTab); //same as user clicking the tab
bar.removeTab(selectedTab);]]></programlisting>

            <section xml:id="mobile.components.tabbarview.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-tabbar {} 
.v-touchkit-tabbar-wrapper {} 
.v-touchkit-tabbar-toolbar {} ]]></programlisting>
		<para>
			The component has overall <literal>v-touchkit-tabbar</literal> style.
			Content area is wrapped inside a <literal>v-touchkit-tabbar-wrapper</literal>
			element. Tab bar control area itself has the <literal>v-touchkit-tabbar-toolbar</literal>
			style.
		</para>
	    </section>

        </section>

        <section xml:id="mobile.components.emailfield">
            <title><classname>EmailField</classname></title>

            <para>
                The <classname>EmailField</classname> is just like the regular
                <classname>TextField</classname>, except that it has automatic capitalization
                and correction turned off. Mobile devices also recognize the field as an email
                field and can offer a virtual keyboard for the purpose, so that it includes
                the at (<literal>@</literal>) and period (<literal>.</literal>) characters,
                and possibly a shorthand for <literal>.com</literal>.
            </para>
        </section>

        <section xml:id="mobile.components.numberfield">
            <title><classname>NumberField</classname></title>
            
            <para>
                The <classname>NumberField</classname> is just like the regular
                <classname>TextField</classname>, except that it is marked as a numeric input
                field for mobile devices, so that they will show a numeric virtual keyboard
                rather than the default alphanumeric.
            </para>
        </section>

        <section xml:id="mobile.components.urlfield">
            <title><classname>UrlField</classname></title>
            
            <para>
                The <classname>UrlField</classname> is just like the regular
                <classname>TextField</classname>, except that it is marked as a URL input
                field for mobile devices, so that they will show a URL input virtual keyboard
                rather than the default alphanumeric. It has convenience methods 
                <methodname>getUrl()</methodname> and <methodname>setUrl(URL url)</methodname>
                for converting input value from and to java.net.URL.
            </para>
        </section>
    </section>

    <section xml:id="mobile.features">
        <title>Advanced Mobile Features</title>

        <section xml:id="mobile.features.fallback">
            <title>Providing a Fallback UI</title>

            <para>
                You may need to use the same URL and hence the same servlet for both the
                mobile TouchKit UI and for regular browsers. In this case, you need to
                recognize the mobile browsers compatible with Vaadin TouchKit and provide
                a fallback UI for any other browsers. The fallback UI can be a regular
                Vaadin UI, a "Sorry!" message, or a redirection to an alternate user
                interface.
            </para>

            <para>
                You can handle the fallback logic in a custom
                <classname>UIProvider</classname> that creates the UIs in the servlet. As
                TouchKit supports only WebKit-based browsers, you can do the recognition
                by checking if the <parameter>user-agent</parameter> string contains the
                sub-string "<literal>webkit</literal>" as follows:
            </para>

            <programlisting><?pocket-size 85% ?><![CDATA[public class MyUIProvider
        extends UIProvider {
    @Override
    public Class<? extends UI> getUIClass(
            UIClassSelectionEvent event) {
        String userAgent = event.getRequest()
                .getHeader("user-agent").toLowerCase();
        if(userAgent.contains("webkit")) {
            return MyMobileUI.class;
        } else {
            return MyFallbackUI.class;
        }
    }
}]]></programlisting>

            <para>
                The custom UI provider has to be added in a custom servlet class, which
                you need to define in the <filename>web.xml</filename>, as described in
                <xref linkend="mobile.project.settings"/>. For example, as follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet {
    private MyUIProvider uiProvider = new MyUIProvider();

    @Override
    protected void servletInitialized() throws ServletException {
        super.servletInitialized();
        
        getService().addSessionInitListener(
                new SessionInitListener() {
            @Override
            public void sessionInit(SessionInitEvent event)
                    throws ServiceException {
                event.getSession().addUIProvider(uiProvider);
            }
        });

        ... other custom servlet settings ...
    }
}]]></programlisting>

            <para>
                See the Vornitologist demo for a working example.
            </para>
        </section>

        <section xml:id="mobile.features.geolocation">
            <title>Geolocation</title>

            <para>
                The geolocation feature in TouchKit allows receiving the geographical
                location from the mobile device. The browser will ask the user to confirm
                that the web site is allowed to get the location information. Tapping
                <guibutton>Share Location</guibutton> gives the permission. The browser
                will give the position acquired by GPS, cellular positioning, or Wi-Fi
                positioning, as enabled in the device.
            </para>

            <para>
                Geolocation is requested by calling the static
                <classname>Geolocator</classname><methodname>.detect()</methodname> method. You
                need to provide a <classname>PositionCallback</classname> handler that
                is called when the device has an answer for your request. If the geolocation 
                request succeeded, <methodname>onSuccess()</methodname> is called. Otherwise, e.g
                . if the user didn't allow sharing of his location, <methodname>
                onFailure</methodname> is called. The geolocation data is provided in a
                <classname>Position</classname> object.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Geolocator.detect(new PositionCallback() {
    public void onSuccess(Position position) {
        double latitude  = position.getLatitude();
        double longitude = position.getLongitude();
        double accuracy  = position.getAccuracy();

        ...
    }

    public void onFailure(int errorCode) {
        ...
    }
});]]></programlisting>

            <para>
                The position is given as degrees with fractions. The longitude is positive
                to East and negative to West of the Prime Meridian passing through
                Greenwich, following the convention for coordinate systems. The accuracy
                is given in meters. In addition to the above data, the following are also
                provided:
            </para>
            <orderedlist>
                <listitem>Altitude</listitem>
                <listitem>Altitude accuracy</listitem>
                <listitem>Heading</listitem>
                <listitem>Speed</listitem>
            </orderedlist>
            <para>
                If any of the position data is unavailable, its value will be zero.
            </para>

            <para>
                The <methodname>onFailure()</methodname> is called if the positioning
                fails for some reason. The <parameter>errorCode</parameter> explains the
                reason. Error 1 is returned if the permission was denied, 2 if the
                position is unavailable, 3 on positioning timeout, and 0 on an unknown
                error.
            </para>

            <para>
                Notice that geolocation can take significant time, depending on the
                location method used by the device. With Wi-Fi and cellular positioning,
                the time is usually less than 30 seconds. With GPS, it can reach minutes
                or longer, especially if the reception is bad. However, once a location fix
                has been made, updates to the location will be faster. If you are making
                navigation software, you need to update the position data fairly frequently by
                calling <classname>Geolocator</classname><methodname>.detect()</methodname>
                multiple times.
            </para>

            <section xml:id="mobile.features.geolocation.map">
                <title>Displaying Position on a Map</title>

                <para>
                    Geographical positions are often visualized with a map. There are
                    countless ways to do that, for example, in Vornitologist we use the
                    <link
                    xlink:href="http://vaadin.com/directory#addon/openlayers-wrapper">OpenLayers
                    Wrapper</link> add-on component.
                </para>

                <para>
                    The OpenLayers Wrapper add-on contains a custom widget set, which
                    needs to be included in the project widget set. In addition, the
                    OpenLayers JavaScript library needs to be referenced in the widget set
                    descriptor. You need to edit it manually and include the following
                    lines:
                </para>


                <programlisting>&lt;!-- WS Compiler: manually edited  --&gt;
&lt;script src="OpenLayers.js"&gt;&lt;/script&gt;
&lt;inherits name="org.vaadin.vol.VolWidgetset" /&gt;</programlisting>

                <para>
                    The <classname>MapView</classname> in Vornitologist populates a vector
                    layer containing markers of the latest observations.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[public class MapView extends NavigationView
   implements PositionCallback, VectorSelectedListener {
    public static StyleMap STYLEMAP_BIRD_MARKER;
    
    private OpenLayersMap openLayersMap;
    private double latestLongitude;
    private double latestLatitude;
    private VectorLayer markerLayer = new VectorLayer();
    ...]]]></programlisting>
            </section>
        </section>
    </section>

    <section xml:id="mobile.offline">
        <title>Offline Mode</title>

        <para>
            While regular Vaadin TouchKit applications are server-side applications, it
            allows a special <emphasis>offline mode</emphasis>, which is a client-side
            Vaadin UI that switched to automatically when the network connection is not
            available. The offline UI is included in the widget set of the regular
            server-side UI and stored in the browser cache. By providing a special cache
            manifest, the browser caches the page so strongly that it persists even after
            browser restart.
        </para>

        <figure xml:id="figure.mobile.offline.vornitologist">
            <title>Offline Mode in Vornitologist</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="50%" scale="70" align="center" fileref="img/mobile/vornitologist-offline.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            During offline operation, the offline UI can store data in the HTML5 local
            storage of the mobile browser and then passed to the server-side application
            when the connection is again available.
        </para>

        <para>
            See the Vornitologist demo and its source code for a complete example of the
            offline mode.
        </para>

        <section xml:id="mobile.offline.cache">
            <title>Enabling the Cache Manifest</title>

            <para>
                HTML5 supports a <emphasis>cache manifest</emphasis>, which makes offline
                web applications possible. It controls how different resources are
                cached. The manifest is generated by TouchKit, but you need to enable it
                in the TouchKit settings. To do so, you need to define a custom servlet,
                as described in <xref linkend="mobile.project.servlet"/>, and call
                <methodname>setCacheManifestEnabled(true)</methodname> for the cache
                settings, as follows:
            </para>

            <programlisting><![CDATA[TouchKitSettings s = getTouchKitSettings();
...
s.getApplicationCacheSettings()
 .setCacheManifestEnabled(true);]]></programlisting>

            <para>
                 You also need to define a MIME type for the manifest in the
                 <filename>web.xml</filename> deployment descriptor as follows:
            </para>

            <programlisting><![CDATA[<mime-mapping>
	<extension>manifest</extension>
	<mime-type>text/cache-manifest</mime-type>
</mime-mapping>]]></programlisting>

        </section>

        <section xml:id="mobile.offline.offlinemodesettings">
            <title>Enabling Offline Mode</title>

            <para>
                To enable the offline mode, you need to add the
                <classname>OfflineModeSettings</classname> extension to the UI.
            </para>

            <programlisting><![CDATA[OfflineModeSettings offline = new OfflineModeSettings();
...
offline.extend(this);]]></programlisting>

            <para>
                You can extend the <classname>OfflineModeSettings</classname> extension to
                to transfer data conveniently from the offline UI to the server-side, as
                described in <xref linkend="mobile.offline.data"/>.
            </para>
        </section>

        <section xml:id="mobile.offline.ui">
            <title>The Offline User Interface</title>

            <para>
                An offline mode is built like any other client-side module, as described
                in <xref linkend="clientside"/>. You can use any GWT, Vaadin, add-on, and
                also TouchKit widgets in the offline user interface.
            </para>

            <para>
                Most typically, a client-side application builds a simplified UI for data
                browsing and entry. It stores the data in the HTML5 local storage. It
                watches if the server connection is restored, and if it is, it sends any
                collected data to the server and suggests to return to the online mode.
            </para>

            <para>
                Please see the Vornitologist source code for an example implementation of
                an offline mode user interface. The
                <filename>com.vornitologist.widgetset.client.VornitologistOfflineMode.java</filename>
                is the main module of the offline application.
            </para>
        </section>

        <section xml:id="mobile.offline.data">
            <title>Sending Data to Server</title>

            <para>
                Once the connection is available, the offline UI can send any collected
                data to the server-side. You can send the data from the offline UI, for
                example, by making a server RPC call to a server-side UI extension, as
                described in <xref linkend="gwt.rpc"/>.
            </para>
        </section>

        <section xml:id="mobile.offline.theme">
            <title>The Offline Theme</title>

            <para>
                Normally, client-side modules have their own stylesheets in the
                <filename>public</filename> folder that is compiled into the client-side
                target, as described in <xref linkend="gwt.styling"/> and <xref
                linkend="clientside.module.stylesheet"/>. However, you may want to have
                the offline mode have the same visual style as the online mode. To use the
                same theme as the server-side application, you need to define the theme
                path in the widget set definition file as follows.
            </para>

            <programlisting><?pocket-size 65% ?>&lt;set-configuration-property
    name='touchkit.manifestlinker.additionalCacheRoot'
    value='src/main/webapp/VAADIN/themes/<replaceable>mytheme</replaceable>:../../../VAADIN/themes/<replaceable>mytheme</replaceable> /&gt;</programlisting>

            <para>
                You need to follow a CSS style structure required by the Vaadin theme in
                your offline application. If you use any Vaadin widgets, as described in
                <xref linkend="widgets.vaadin"/>, they will use the Vaadin theme.
            </para>
        </section>
    </section>

    <section xml:id="mobile.optimization">
        <title>Building an Optimized Widget Set</title>

        <para>
            Mobile networks are generally somewhat slower than DSL Internet
            connections. When starting a Vaadin application, the widget set is the biggest
            resource that needs to be loaded in the browser. As most of the Vaadin
            components are not used by most applications, especially mobile ones, it is
            beneficial to create an optimized version of the widget set.
        </para>

        <para>
            Vaadin supports lazy loading of individual widget implementations when they
            are needed. The <classname>TouchKitWidgetSet</classname> used in TouchKit
            applications optimizes the widgetset to only download the most essential
            widgets first and then load other widget implementation lazily. This is a good
            compromise for most TouchKit applications. Nevertheless, because of the high
            latency of most mobile networks, loading the widget set in small pieces might
            not be the best solution for every case. With custom optimization, you can
            create a monolithic widget set stripped off all unnecessary widgets. Together
            with proper GZip compression, is should be quite light-weight for mobile
            browsers.
        </para>

        <para>
            However, if the application has big components which are rarely used or not on
            the initial views, it may be best to load those widgets eagerly or lazily.
        </para>

        <para>
            You can fine-tune a widget set by using a custom
            <classname>WidgetMapGenerator</classname> implementation. It needs to be
            defined in the <filename>.gwt.xml</filename> widget set definition file as
            follows:
        </para>

        <programlisting>&lt;generate-with class="<replaceable>com.myprj.WidgetLoaderFactory</replaceable>"&gt;
    &lt;when-type-assignable class="com.vaadin.client.metadata.ConnectorBundleLoader" /&gt;
&lt;/generate-with&gt;</programlisting>

        <para>
            The <classname>WidgetMapGenerator</classname> should override
            <classname>TouchKitWidgetMapGenerator</classname> and its
            <methodname>getUsedPaintables()</methodname> method. The method returns an
            array of user interface component classes used by the application. Many
            largeish component implementations can be left out. The list of used
            components can be built manuall. You can also, for example, use a debugger to
            dig into the <classname>CommunicationManager</classname> class in Vaadin,
            which opens all the views of the application. It contains a set of all
            components that have been used. 
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[public class WidgetLoaderFactory
       extends TouchKitBundleLoaderFactory {
    private final ArrayList<Class<? extends ServerConnector>>
        eagerWidgets;

    public WidgetLoaderFactory() {
        eagerWidgets =
            new ArrayList<Class<? extends ServerConnector>>();
        eagerWidgets.add(SwitchConnector.class);
        eagerWidgets.add(EmbeddedConnector.class);
        eagerWidgets.add(NumberFieldConnector.class);
        ...
]]></programlisting>

        <para>
            The <methodname>getLoadStyle()</methodname> method should return the widget
            loading style, which should be <parameter>EAGER</parameter> to get a
            monolithic widgetset.
        </para>


        <programlisting><?pocket-size 65% ?><![CDATA[    @Override
    protected LoadStyle getLoadStyle(JClassType connectorType) {
        if (eagerWidgets.contains(connectorType)) {
            return LoadStyle.EAGER;
        } else {
            return super.getLoadStyle(connectorType);
        }
    }
}]]></programlisting>

        <para>
            You can find a working example in the
            <filename>VornitologistWidgetset.gwt.xml</filename> and
            <filename>WidgetMapGenerator.java</filename> in the Vornitologist sources.
        </para>

        <para>
            Note that you need to enable GZip compression for your deployment if you wish
            to optimize the startup time and minimize the amount of transferred data. The
            best method for doing that highly depends on your hosting setup, so we do not
            cover it here.
        </para>
    </section>

    <section xml:id="mobile.testing">
        <title>Testing and Debugging on Mobile Devices</title>

        <para>
            Testing places special challenges for mobile devices. The mobile browsers may not
            have much debugging features and you may not be able to install third-party
            debugging add-ons, such as Firebug.
        </para>

        <section xml:id="mobile.testing.debugging">
            <title>Debugging</title>

            <para>
                The debug mode, as described in <xref linkend="advanced.debug-production-modes"/>,
                works on mobile browsers as well, even if it is a bit harder to use.
            </para>

            <para>
                The lack of FireBug and similar tools can be helped with simple client-side
                coding. For example, you can dump the HTML content of the page with the
                <parameter>innerHTML</parameter> property in the HTML DOM.
            </para>

            <para>
                TouchKit supports especially WebKit-based browsers, which are used in iOS and
                Android devices. You can therefore reach a good compatibility by using a
                desktop browser based on WebKit. Features such as geolocation are also
                supported by desktop browsers. If you make your phone/tablet-detection and
                orientation detection using screen size, you can easily emulate the modes by
                resizing the browser.
            </para>
        </section>

        <!-- section xml:id="mobile.testing.testing">
        <title>Debugging</title>

        <para>
        </para>
    </section -->
    </section>

    <indexterm startref="term.touchkit" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
