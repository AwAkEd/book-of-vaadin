<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="mobile">
	<title>Mobile Applications with TouchKit</title>

    <indexterm xml:id="term.touchkit" class="startofrange">
        <primary>TouchKit</primary>
    </indexterm>

    <para>
        This chapter describes how to write mobile applications using the Vaadin TouchKit.
    </para>

    <section xml:id="mobile.overview">
        <title>Overview</title>

        <para>
            Web browsing is becoming ever increasingly mobile and web applications need to
            satisfy users with both desktop computers and mobile devices, such as phones
            and tablets. While the mobile browsers can show the pages just like in regular
            browsers, the screen size, finger accuracy, and mobile browser features need
            to be considered to make the experience more pleasant. Vaadin TouchKit gives
            the power of Vaadin for creating mobile user interfaces that complement the
            regular web user interfaces of your applications. Just like the purpose of the
            Vaadin Framework is to make desktop-like web applications, the purpose of
            TouchKit is to allow creation of web applications that give the look and feel
            of native mobile applications.
        </para>

        <figure xml:id="figure.mobile.overview.touchkit">
            <title>The Vornitologist Demo for Vaadin TouchKit</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/vornitologist-maintabsheet-short.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Creating a mobile UI is much like a regular Vaadin UI. You can use all the
            regular Vaadin components and add-ons, as well as the special TouchKit
            components.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[@Theme("mobiletheme")
public class SimplePhoneUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // Set the window or tab title
        getPage().setTitle("Hello Phone!");
        
        // Use the TouchKit TabBarView for content
        TabBarView mainView = new TabBarView();
        setContent(mainView);
        
        // Create a view - usually a regular class
        class MyView extends VerticalLayout {
            Table table = new Table("Planets", planetData());

            public MyView() {
                addComponent(new Label("This is a view"));
                table.setWidth("100%");
                table.setPageLength(table.size());
                addComponent(table);
                addComponent(new Button("Go"));
                setSpacing(true);
            }
        }
        mainView.addTab(new MyView(), "Planets");

        // Add some more sub-views
        mainView.addTab(new Label("Dummy"), "Map");
        mainView.addTab(new Label("Dummy"), "Settings");
    }
    ...
}]]></programlisting>

        <para>
            The resulting UI is shown in <xref linkend="figure.mobile.overview.example"/>.
        </para>

        <figure xml:id="figure.mobile.overview.example">
            <title>The Vornitologist Demo for Vaadin TouchKit</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/vornitologist-maintabsheet-short.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            TouchKit supports many special mobile browser features, such as geolocation,
            home screen launching, splash screen, and web app mode, especially in iOS.
        </para>

        <para>
            In addition to developing regular server-side UIs, TouchKit allows a special
            <emphasis>offline mode</emphasis>, which is a client-side Vaadin UI that is
            stored in the browser cache and switched to automatically when the network
            connection is not available, either when starting the application or while
            using it. For more information, see <xref linkend="mobile.offline"/>.
        </para>

        <para>
            In this chapter, we first consider some special aspects of mobile
            browsing. Then, we look how to create a project that uses TouchKit. TouchKit
            offers a number of specialized mobile components, which are described in a
            dedicated section. We treat phone and tablet applications separately, and
            discuss testing briefly.
        </para>

        <simplesect xml:id="mobile.overview.examples">
            <title>Demos and the Tutorial</title>

            <para>
                The Vornitologist is a demo application that showcases most of the
                features in TouchKit. You can try it out at <link
                xlink:href="http://demo.vaadin.com/vornitologist">http://demo.vaadin.com/vornitologist</link>
                with your iOS or Android device. It comes with a tutorial that gives
                details about how it works.
            </para>

            <para>
                The Mobile Mail is another demo application, which shows how to implement
                browsing of deep category trees and make forms.
            </para>
        </simplesect>

        <simplesect xml:id="mobile.overview.license">
            <title>Licensing</title>

            <para>
                Vaadin TouchKit is a commercial product licensed under a dual-licensing
                scheme. The AGPL license allows open-source development, while the CVAL
                license needs to be purchased for closed-source use, including web
                deployments and internal use. Commercial licenses can be purchased from
                the Vaadin Directory, where you can also find the license details and
                download Vaadin TouchKit.
            </para>
        </simplesect>
    </section>

    <section xml:id="mobile.considerations">
        <title>Considerations Regarding Mobile Browsing</title>

        <para>
            When developing web applications that support mobile browsing, you need to
            consider various issues that are different from non-mobile use. TouchKit is
            designed to help with these issues.
        </para>
        
        <section xml:id="mobile.considerations.mobile-hi">
            <title>Mobile Human Interface</title>

            <para>
                Mobile devices use very different human interfaces than regular
                computers. For example, the screen can be rotated easily to switch between
                portrait and landscape views. This does not just change the dimensions of
                the display, but also affects the most useful layout.
            </para>

            <para>
                The user interface is used with a finger instead of a mouse, so there are
                no features such as "right-finger-button". Double-tap is not normally used
                in mobile user interfaces, unlike the double-click with a mouse. Instead,
                a "long tap" usually has the same meaning as the double click. Finger
                gestures also play a large role, such as using a vertical swipe gesture
                for scrolling instead of a scroll bar.
            </para>

            <para>
                There is normally no physical but a virtual keyboard, and the keyboard can
                change depending on the context. You also need to ensure that it does not
                hide the input field to which the user is trying to enter data when it
                pops up. This should be handled by the browser, but is among the issues
                that requires special testing.
            </para>
        </section>

        <section xml:id="mobile.considerations.bandwidth">
            <title>Bandwidth</title>
            
            <para>
                Mobile Internet connections are often significantly slower than with fixed
                lines. With a low-end mobile connection, such as 384 kbps, just loading
                the Vaadin client-side engine can take several seconds. This can be helped
                by compiling a widget set that includes only the widgets for the used
                components.
            </para>

            <para>
                Even with mobile broadband, the latency can be significant factor, especially
                with highly interactive rich applications. The latency is usually almost
                unnoticeable in fixed lines, typically less than 100 ms, while mobile Edge
                connections typically have latency around 500 ms, and sometimes much higher
                during hiccups. You may need to limit the use of the immediate mode, text
                change events, and polling.
            </para>
        </section>

        <section xml:id="mobile.considerations.features">
            <title>Mobile Features</title>

            <para>
                Phones and tablets have many integrated features that are often available in
                the browser interface as well. Location-awareness is one of the most recent
                features. And of course, you can also make phone calls.
            </para>
        </section>

        <section xml:id="mobile.considerations.compatibility">
            <title>Compatibility</title>

            <para>
                The mobile browsing field is currently evolving at fast pace and the
                special conventions that are introduced by leading manufacturers may, in
                the next few years, stabilize as new web standards. The browser support in
                TouchKit concentrates on WebKit, which appears to be emerging as the
                leading mobile browser core. In addition to Apple's products, also the
                default browser in Android uses WebKit as the layout engine. Yet they have
                differences, as the Android's JavaScript engine, which is highly relevant
                for Vaadin, is the Google Chrome's V8 engine.
            </para>

            <para>
                Vaadin TouchKit aims to follow the quickly evolving APIs of these major
                platforms, with the assumption that other browsers will follow their lead
                in standardization. Other platforms will be supported if they rise in
                popularity.
            </para>

            <section xml:id="mobile.considerations.compatibility.backbutton">
                <title>Back Button</title>

                <para>
                    Some mobile devices, especially Android devices, have a dedicated back
                    button, while iOS devices in particular do not. TouchKit does not
                    provide any particular support for the button, but as it is a regular
                    browser back button, you can handle it with URI fragments, as
                    described in <xref linkend="advanced.urifu"/>. For iOS, the browser
                    back button is hidden if the user adds the application to the home
                    screen, in which case you need to implement application-specific logic
                    for the back-navigation.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="mobile.installation">
        <title>Installing Vaadin TouchKit</title>

        <para>
            You can download and install TouchKit from the Vaadin Directory at <link
            xlink:href="https://vaadin.com/addon/vaadin-touchkit">https://vaadin.com/addon/vaadin-touchkit</link>
            as an installation package or get it with Maven. If your project requires the
            use of the CVAL license, they can be purchased from the Directory.
        </para>

        <para>
            See <xref linkend="addons"/> for details regarding add-on installation. The
            add-on includes a widget set, so you need to compile the widget set for your
            project.
        </para>
        
        <section xml:id="mobile.project.downloading">
            <title>Downloading from Vaadin Directory</title>

            <para>
            
                <!-- TODO: maven dep wrong (agpl/cval etc), also more probls. -->
                <!-- TODO: Reference to the add-on installation. -->
            </para>
        </section>

        <section xml:id="mobile.project.maven">
            <title>Installing in Maven</title>

            <para>
                You can install Vaadin TouchKit in a Maven project by adding it a
                dependency, as described first below. If you are creating a new project,
                you can use the TouchKit Maven archetype to create a project skeleton.
            </para>

            <section xml:id="mobile.project.maven.dependency">
                <title>Defining as a Dependency</title>

                <para>
                    To use TouchKit in a Vaadin project, you need to include the following
                    dependency in the POM. The <literal>artifactId</literal> should be
                    <literal>vaadin-touchkit-agpl</literal> or
                    <literal>vaadin-touchkit-cval</literal>, depending on your choise for
                    the license.
                </para>

                <programlisting>&lt;dependency&gt;
   &lt;groupId&gt;com.vaadin.addon&lt;/groupId&gt;
   &lt;artifactId&gt;vaadin-touchkit-<emphasis role="bold">agpl</emphasis>&lt;/artifactId&gt;
   &lt;version&gt;<emphasis role="bold">LATEST</emphasis>&lt;/version&gt;
&lt;/dependency&gt;</programlisting>

                <para>
                    You can use the <parameter>LATEST</parameter> version as shown above
                    or a specific version by its version number.
                </para>

                <para>
                    You also need to define the repository for the Vaadin add-ons under
                    the <literal>&lt;repositories&gt;</literal> element:
                </para>

                <programlisting><![CDATA[<repository>
   <id>vaadin-addons</id>
   <url>http://maven.vaadin.com/vaadin-addons</url>
</repository>]]></programlisting>
            </section>
                
            <simplesect xml:id="mobile.project.maven.archetype">
                <title>Using the Archetype</title>

                <para>
                    You can create a new TouchKit application project using the Maven
                    archetype.
                </para>

                <para>
                    To Be Done.
                </para>
            </simplesect>
        </section>
    </section>

    <section xml:id="mobile.project">
        <title>Creating a TouchKit Application</title>

        <para>
            At minimum, a TouchKit application requires a UI class, which is defined in a
            deployment descriptor, as usual for Vaadin applications. You usually also need
            to have a custom theme. To enable various other features, you may need to
            provide a custom servlet. These and other tasks are described in the following
            subsections.
        </para>
        
        <section xml:id="mobile.project.webxml">
            <title>Deployment Descriptor</title>

            <para>
                The deployment descriptor of a TouchKit application is much like for any
                Vaadin application. However, you need to use the special
                <classname>TouchKitServlet</classname> class instead of the regular
                <classname>VaadinServlet</classname> in the <filename>web.xml</filename>
                deployment descriptor. 
            </para>

            <para>
                If you need to add special logic in the servlet, such as to provide
                different UIs for different devices or to make certain configuration, you
                can extend the TouchKit servlet to implement the logic.
            </para>

            <para>
                As TouchKit comes with a custom widget set, you need to use a combining
                widget set for your project. The combining widget set descriptor is
                automatically generated by the Vaadin Plugin for Eclipse and in Maven when
                you install or define the TouchKit add-on.
            </para>

            <programlisting><?pocket-size 65% ?>&lt;servlet&gt;
  &lt;servlet-name&gt;Vaadin Application Servlet&lt;/servlet-name&gt;
  &lt;servlet-class&gt;com.vaadin.addon.touchkit.server.TouchKitApplicationServlet&lt;/servlet-class&gt;
  &lt;init-param&gt;
    &lt;description&gt;Vaadin application class to start&lt;/description&gt;
    &lt;param-name&gt;application&lt;/param-name&gt;
    &lt;param-value&gt;<emphasis role="bold">com.vaadin.demo.mobilemail.MobileMailApplication</emphasis>&lt;/param-value&gt;
  &lt;/init-param&gt;
  &lt;init-param&gt;
    &lt;param-name&gt;widgetset&lt;/param-name&gt;
    &lt;param-value&gt;<emphasis role="bold">com.vaadin.demo.mobilemail.gwt.MobileMailWidgetSet</emphasis>&lt;/param-value&gt;
  &lt;/init-param&gt;
&lt;/servlet&gt;</programlisting>
        </section>

        <section xml:id="mobile.project.servlet">
            <title>Creating a Custom Servlet</title>

            <para>
                Some tasks can only be done in the initial request to the server, before
                the UI is created. You need to make a custom servlet class if you want to
                use the following TouchKit features:
            </para>

            <itemizedlist>
                <listitem>Customize bookmark or home screen icon</listitem>
                <listitem>Customize splash screen image</listitem>
                <listitem>Customize status bar in iOS</listitem>
                <listitem>Use special web app mode in iOS</listitem>
                <listitem>Provide a fallback UI</listitem>
                <listitem>Enable offline mode</listitem>
            </itemizedlist>

            <para>
                If you modify the TouchKit settings as described later, which the most
                common task, you can extend the <classname>VaadinServlet</classname>
                directly. If not, such as if you just add a custom UI provider for a
                fallback UI, you should extend the <classname>TouchKitServlet</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class VornitologistServlet extends VaadinServlet {
    @Override
    protected void servletInitialized() throws ServletException {
        super.servletInitialized();

        ... customization ...
    }
}]]></programlisting>

            <para>
                Configuring a fallback UI is covered in <xref
                linkend="mobile.features.fallback"/>.
            </para>

            <section xml:id="mobile.project.servlet.settings">
                <title>TouchKit Settings</title>

                <para>
                    The <classname>TouchKitSettings</classname> is a 
                </para>
            </section>
        </section>

        <section xml:id="mobile.project.ui">
            <title>The UI</title>

            <para>
                Mobile UIs extend the <classname>UI</classname> class as usual. Because
                much of the browser information is not yet available when the
                <methodname>init()</methodname> method is called, you should only set
                basic things like the main window and theme there. The main window must be
                set and must be a <classname>TouchKitWindow</classname>, not a
                <classname>Window</classname> as in regular Vaadin applications.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[@Theme("mobiletheme")
public class SimplePhoneUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        // Set the window or tab title
        getPage().setTitle("Hello Phone!");
        
        // Create the content root layout for the UI
        TabBarView mainView = new TabBarView();
        setContent(mainView);

        ...
    }
}]]></programlisting>

            <para>
                Most initialization has to be be done in
                <methodname>onBrowserDetailsReady()</methodname>, including the decision
                to use a regular or a mobile browser interface. The decision is usually
                made using the user-agent information available in the
                <classname>WebBrowser</classname> class and the width and height of the
                main window.
            </para>

        <programlisting><?pocket-size 65% ?><![CDATA[public void onBrowserDetailsReady() {
    WebBrowser browser = getBrowser();
    float viewPortWidth = getMainWindow().getWidth();

    if (viewPortWidth < 600) {
        getMainWindow().setContent(new SmartphoneMainView());
    } else {
        getMainWindow().setContent(new TabletMainView());
    }
}]]></programlisting>

            <para>
                The demo application does not actually support regular browsers, just notifies
                about the situation. The special mobile components in TouchKit are not
                guaranteed to work at all in regular browsers. It does give separate user
                interfaces for phones and tablets, as described in detail later.
            </para>

            <para>
                If you need to provide a <emphasis>fallback UI</emphasis> for browsers
                that are not compatible with TouchKit, such as most regular browsers, you
                can do so in a custom UI provider, as described in <xref
                linkend="mobile.features.fallback"/>.
            </para>
        </section>
    </section>

    <section xml:id="mobile.components">
        <title>Mobile User Interface Components</title>

        <para>
            TouchKit introduces a number of components special to mobile device user
            interfaces.
        </para>

        <section xml:id="mobile.components.navigationview">
            <title><classname>NavigationView</classname></title>
            
            <para>
                The <classname>NavigationView</classname> is a layout component that consists
                of a navigation bar and a content area. The content area is scrollable, so
                there is no need to use an inner panel component. In addition, there can be an
                optional toolbar component at the bottom of the
                view. A <classname>NavigationView</classname> is often used inside a
                <classname>NavigationManager</classname> to get view change animations.
            </para>

            <figure xml:id="figure.mobile.components.navigationview">
                <title>Layout of the <classname>NavigationView</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/mobile/navigationview-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/navigationview-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <classname>NavigationView</classname> has a full size by default. The content
                area is expanding, so that it takes all the space left over from the navigation
                bar and toolbar.
            </para>

            <section xml:id="mobile.components.navigationview.navigationbar">
                <title>Navigation Bar</title>

                <para>
                    The navigation bar at the top of <classname>NavigationView</classname> is
                    a <classname>NavigationBar</classname> component. It has two component
                    slots, with one on the left and one on the right. The caption is displayed
                    in the middle. The <classname>NavigationBar</classname> can be used elsewhere
                    as well, such as for a view containing a form with save and cancel buttons
                    in the upper right and left corners.
                </para>

                <para>
                    When the <classname>NavigationBar</classname> is used for navigation and you
                    set the previous component with
                    <methodname>setPreviousComponent()</methodname>, the left slot is
                    automatically filled with a <guibutton>Back</guibutton> button. This is
                    done automatically if you use the <classname>NavigationView</classname>
                    inside a <classname>NavigationManager</classname>.
                </para>

                <para>
                    You can get access to the navigation bar component with
                    <methodname>getNavigationBar()</methodname> to use its manipulator methods
                    directly, but <classname>NavigationView</classname> also offers some
                    shorthand methods: <methodname>setLeftComponent()</methodname>,
                    <methodname>setRightComponent()</methodname>, and a setter and a getter
                    for the caption.
                </para>
            </section>

            <section xml:id="mobile.components.navigationview.toolbar">
                <title>Toolbar</title>

                <para>
                    A slot for an optional toolbar is located at the bottom of the
                    <classname>NavigationView</classname>. The toolbar can be any component,
                    but a <classname>Toolbar</classname> component made for this purpose is
                    included in TouchKit. It is described in <xref
                        linkend="mobile.components.toolbar"/>. You could also use a
                    <classname>HorizontalLayout</classname> or
                    <classname>CssLayout</classname>.
                </para>

                <para>
                    You usually fill the tool bar with <classname>Button</classname>
                    components with an icon and no textual caption. You set the toolbar with
                    <methodname>setToolbar()</methodname>.
                </para>
            </section>

            <section xml:id="mobile.components.navigationview.css">
                <title>Styling with CSS</title>
                
                <programlisting><![CDATA[.v-touchkit-navview { }
  .v-touchkit-navview-wrapper {}
  .v-touchkit-navview-toolbar {}
.v-touchkit-navview .v-touchkit-navview-notoolbar {}]]></programlisting>

                <para>
                    The root element has the <literal>v-touchkit-navview</literal> class. The
                    content area is wrapped inside a
                    <literal>v-touchkit-navview-wrapper</literal> element. If the view has a
                    toolbar, the toolbar slot has the
                    <literal>v-touchkit-navview-toolbar</literal> style, but if not, the
                    top-level element has the <literal>v-touchkit-navview-notoolbar</literal>
                    style.
                </para>
            </section>
        </section>

        <!-- TODO <section xml:id="mobile.components.navigationbar">
    <title><classname>NavigationBar</classname></title>

        <para>
            
        </para>
    </section> -->

        <section xml:id="mobile.components.toolbar">
            <title><classname>Toolbar</classname></title>

            <para>
                The <classname>Toolbar</classname> is a layout component that extends
                <classname>CssLayout</classname>, usually containing
                <classname>Button</classname> components. The toolbar has by default 100%
                horizontal width and a fixed height. The components are spread evenly
                in the horizontal direction. <classname>Toolbar</classname> is typically used
                in a <classname>NavigationView</classname>, as described in <xref
                    linkend="mobile.components.navigationview" xrefstyle="select:label"/>.
            </para>

            <para>
                For a description of the inherited features, please refer to <xref
                    linkend="layout.orderedlayout"/>.
            </para>

            <section xml:id="mobile.components.toolbar.css">
                <title>Styling with CSS</title>
                
                <programlisting><![CDATA[.v-touchkit-toolbar { }]]></programlisting>
                
                <para>
                    The component has an overall <literal>v-touchkit-toolbar</literal> style in
                    addition to the <literal>v-csslayout</literal> style of the
                    superclass. Other style names are as for 
                    <classname>CssLayout</classname>.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.navigationpanel">
            <title><classname>NavigationManager</classname></title>
            
            <para>
                The <classname>NavigationManager</classname> is a visual effect component that
                gives sliding animation when switching between views. You can register
                three components: the currently displayed component,
                the previous one on the left, and the next component on the right. You can set
                these components with <methodname>setCurrentComponent()</methodname>,
                <methodname>setPreviousComponent()</methodname>, and
                <methodname>setNextComponent()</methodname>, respectively. 
            </para>

            <para>
                The <classname>NavigationManager</classname> component is illustrated in <xref
                    linkend="figure.mobile.components.navigationpanel"/>.
            </para>

            <figure xml:id="figure.mobile.components.navigationpanel">
                <title><classname>NavigationManager</classname> with Three <classname>NavigationView</classname>s</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/mobile/navigationpanel-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" scale="80" align="center" fileref="img/mobile/navigationpanel-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The navigation manager is important for responsiveness, because the previous and
                next components are cached and the slide animation started before server is
                contacted to load the new next or previous views.
            </para>

            <para>
                Switching between the views is done programmatically according to user
                interaction; swipe gestures are not supported at the moment.
            </para>

            <section xml:id="mobile.components.navigationpanel.viewhandling">
                <title>Handling View Changes</title>

                <para>
                    While you can put any components in the manager, some special features are
                    enabled when using the <classname>NavigationView</classname>. When a view
                    becomes visible, the <methodname>onBecomingVisible()</methodname> method
                    in the view is called. You can override it, just remember to call the
                    superclass method.
                </para>

                <programlisting><![CDATA[@Override
protected void onBecomingVisible() {
    super.onBecomingVisible();

    ...
}]]></programlisting>
            </section>

            <section xml:id="mobile.components.navigationpanel.breadcrump">
                <title>Tracking Breadcrumbs</title>

                <para>
                    <classname>NavigationManager</classname> also handles
                    <emphasis>breadcrumb</emphasis> tracking. The
                    <methodname>navigateTo()</methodname> pushes the current view on the top
                    of the breadcrumb stack and <methodname>navigateBack()</methodname> can be
                    called to return to the previous breadcrumb level.
                </para>

                <para>
                    Notice that calling <methodname>navigateTo()</methodname> with the
                    "previous" component is equivalent to calling
                    <methodname>navigateBack()</methodname>.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.navigationbutton">
            <title><classname>NavigationButton</classname></title>

            <para>
                The <classname>NavigationButton</classname> is a special version of the
                regular <classname>Button</classname> designed for navigation inside a
                <classname>NavigationManager</classname>, as described in <xref
                    linkend="mobile.components.navigationpanel"
                    xrefstyle="select:label"/>. Clicking the button will automatically navigate to
                the defined target view. The view change animation does not need to make a
                server request first, but starts immediately after clicking the button. If you
                leave the target view empty, an empty placeholder view is shown in the
                animation. The view is filled after it gets the content from the server.
            </para>

            <para>
                You can give the target view either in the constructor or with
                <methodname>setTargetView()</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[
NavigationView view = new NavigationView("A View");
...
NavigationButton button = new NavigationButton("Click");
button.setTargetView(view);
...]]></programlisting>

            <para>
                Notice that the automatic navigation will only work if the button is inside a
                <classname>NavigationManager</classname> (in a view inside it). If you just
                want to use the button as a visual element, you can use it like a regular
                <classname>Button</classname> and handle the click events with a
                <classname>ClickListener</classname>.
            </para>

            <section xml:id="mobile.components.navigationbutton.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-navbutton { }
  .v-touchkit-navbutton-desc { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-navbutton</literal> style. If
                    the component description is set with
                    <methodname>setDescription()</methodname>, it is shown in a separate
                    <literal>&lt;span&gt;</literal> element with the
                    <literal>v-touchkit-navbutton-desc</literal> style.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.popover">
            <title><classname>Popover</classname></title>

            <para>
                <classname>Popover</classname> is much like a regular Vaadin sub-window,
                useful for quickly displaying some options or a small form related to an
                action. Unlike regular sub-windows, it does not support dragging or resizing
                by the user. It can have a caption, but usually does not. As sub-windows
                usually require a rather large screen size, the <classname>Popover</classname>
                is mainly applicable to tablet devices. When used on smaller devices, such as
                phones, the <classname>Popover</classname> automatically fills the entire
                screen.
            </para>

            <para>
                In the following example, we extend <classname>Popover</classname> to use it. It
                is modal by default. Notice that the screen size is not available in the
                constructor, so we have to postpone using it to the
                <methodname>attach()</methodname> method.
            </para>

            <para>
                Popover windows are added to an application-level <classname>Window</classname>
                object with <methodname>addWindow()</methodname>, just like sub-windows in a
                regular Vaadin application.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[if (event.getButton() == emailButton) {
    ComposeView composeView = new ComposeView(smartphone);
    getWindow().addWindow(composeView);
    return;
}]]></programlisting>

            <para>
                The resulting user interface in a tablet device is shown in <xref
                    linkend="figure.mobile.components.popover"/>.
            </para>

            <figure xml:id="figure.mobile.components.popover">
                <title><classname>Popover</classname> in a Tablet Device</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" scale="70" align="center" fileref="img/mobile/touchkitsubwindow.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Alternatively, you can call the <methodname>showRelativeTo()</methodname>,
                which displays the sub-window relative to an existing component in the user
                interface.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Popover popover = new Popover();
popover.setContent(mailboxHierarchyView);
popover.setClosable(true);
popover.showRelativeTo(showMailboxHierarchyButton);
popover.setHeight(getParent().getHeight() - 100, UNITS_PIXELS);]]></programlisting>

            <para>
                In this case, you should not call <methodname>addWindow()</methodname>
                explicitly.
            </para>

            <section xml:id="mobile.components.popover.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-popover .v-touchkit-fullscreen { }
  .v-touchkit-popover .v-touchkit-relative { }
  .v-touchkit-popover .v-touchkit-plain { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-popover</literal> style. If
                    full-screen, it also has the <literal>v-touchkit-fullscreen</literal> style, if
                    positioned relatively it has <literal>v-touchkit-relative</literal>, and if not,
                    the <literal>v-touchkit-plain</literal> style.
                </para>
            </section>
        </section>

        <section xml:id="mobile.components.switch">
            <title><classname>Switch</classname></title>

            <para>
                The <classname>Switch</classname> component is a
                <classname>CheckBox</classname> that looks like the switch button in Apple
                iOS.
            </para>

            <programlisting><![CDATA[Switch switch = new Switch();
switch.setCaption("Do I look like iOS?");
layout.addComponent(switch);]]></programlisting>

        <section xml:id="mobile.components.switch.css">
            <title>Styling with CSS</title>

            <programlisting><![CDATA[.v-touchkit-switch { }
  .v-touchkit-switch-slider { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-switch</literal> style. The slider
                    element has <literal>v-touchkit-switch-slider</literal> style.
                </para>
            </section>
        </section>
		
		<section xml:id="mobile.components.verticalcomponentgroup">
            <title><classname>VerticalComponentGroup</classname></title>
			<para>
				The <classname>VerticalComponentGroup</classname> is a layout component for grouping
                components in the vertical stack. The most typical use of the 
                <classname>VerticalComponentGroup</classname> is to make vertical navigation menus 
                containing <classname>NavigationButton</classname>s for the mobile application.
				The <classname>VerticalComponentGroup</classname> and 
				<classname>HorizontalComponentGroup</classname> both extend 
				<classname>AbstractComponentGroup</classname> which is inherited from the 
				<classname>AbstractComponentContainer</classname>.
				In the client side both component group widgets are extending the lightweigth 
				<classname>FlowPanel</classname>.
			</para>
			
			<section xml:id="mobile.components.verticalcomponentgroup.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-verticalcomponentgroup { }]]></programlisting>

                <para>
                    The component has an overall <literal>v-touchkit-verticalcomponentgroup</literal> 
                    style. If the component has a caption, the 
                    <literal>v-touchkit-has-caption</literal> style is added.
                </para>
            </section>
		</section>
		
		<section xml:id="mobile.components.horizontalcomponentgroup">
            <title><classname>HorizontalComponentGroup</classname></title>
			<para>
				The <classname>HorizontalComponentGroup</classname> is mainly intended to group buttons
				 inside the <classname>VerticalComponentGroup</classname> slots.
			</para>
			
			<programlisting><?pocket-size 65% ?><![CDATA[HorizontalComponentGroup horizontalCGroup = new HorizontalComponentGroup();
horizontalCGroup.addComponent(new Button("First"));
horizontalCGroup.addComponent(new Button("Another"));

NavigationButton navButton = new NavigationButton();
button.setIcon(new ThemeResource("../runo/icons/32/ok.png"));
        
VerticalComponentGroup verticalCGroup = new VerticalComponentGroup();
verticalCGroup.setMargin(true);

verticalCGroup.addComponent(horizontalCGroup);
verticalCGroup.addComponent(new Button("Button"));
verticalCGroup.addComponent(new TextField("TF's caption"));
verticalCGroup.addComponent(navButton);]]></programlisting>
			
		</section>

        <section xml:id="mobile.components.tabbarview">
            <title><classname>TabBarView</classname></title>
            
            <para>
                The <classname>TabBarView</classname> is a layout component that consist of
		a tab bar and content area. Each tab will have it's own content area which
		will be displayed when a correspoding tab is selected. TabBarView is inherited
		from the <classname>ComponentContainer</classname> but uses it's own specialized
		API for monipulating tabs. <methodname>removeComponent()</methodname> and
		<methodname>addComponent()</methodname> will throw an 
		<classname>UnsupportedOperationException</classname> if used.
	    </para>

<programlisting><![CDATA[TabBarView bar = new TabBarView();

//Create some Vaadin Component to use as content
Label content = new Label("Really simple content");

//Create a tab for it
Tab tab = bar.addTab(label);

//Set tab name and/or icon
tab.setCaption("tab name");
tab.setIcon(new ThemeResource(...));

//Programmatically modify tab bar
Tab selectedTab = bar.getSelectedTab();
bar.setSelectedTab(selectedTab); //same as user clicking the tab
bar.removeTab(selectedTab);]]></programlisting>

            <section xml:id="mobile.components.tabbarview.css">
                <title>Styling with CSS</title>

                <programlisting><![CDATA[.v-touchkit-tabbar {} 
.v-touchkit-tabbar-wrapper {} 
.v-touchkit-tabbar-toolbar {} ]]></programlisting>
		<para>
			The component has overall <literal>v-touchkit-tabbar</literal> style.
			Content area is wrapped inside a <literal>v-touchkit-tabbar-wrapper</literal>
			element. Tab bar control area itself has the <literal>v-touchkit-tabbar-toolbar</literal>
			style.
		</para>
	    </section>

        </section>

        <section xml:id="mobile.components.emailfield">
            <title><classname>EmailField</classname></title>

            <para>
                The <classname>EmailField</classname> is just like the regular
                <classname>TextField</classname>, except that it has automatic capitalization
                and correction turned off. Mobile devices also recognize the field as an email
                field and can offer a virtual keyboard for the purpose, so that it includes
                the at (<literal>@</literal>) and period (<literal>.</literal>) characters,
                and possibly a shorthand for <literal>.com</literal>.
            </para>
        </section>

        <section xml:id="mobile.components.numberfield">
            <title><classname>NumberField</classname></title>
            
            <para>
                The <classname>NumberField</classname> is just like the regular
                <classname>TextField</classname>, except that it is marked as a numeric input
                field for mobile devices, so that they will show a numeric virtual keyboard
                rather than the default alphanumeric.
            </para>
        </section>

        <section xml:id="mobile.components.urlfield">
            <title><classname>UrlField</classname></title>
            
            <para>
                The <classname>UrlField</classname> is just like the regular
                <classname>TextField</classname>, except that it is marked as a URL input
                field for mobile devices, so that they will show a URL input virtual keyboard
                rather than the default alphanumeric. It has convenience methods 
                <methodname>getUrl()</methodname> and <methodname>setUrl(URL url)</methodname>
                for converting input value from and to java.net.URL.
            </para>
        </section>
    </section>

    <section xml:id="mobile.features">
        <title>Advanced Mobile Features</title>

        <section xml:id="mobile.features.fallback">
            <title>Providing a Fallback UI</title>

            <para>
                You may need to use the same URL and hence the same servlet for both the
                mobile TouchKit UI and for regular browsers. In this case, you need to
                recognize the mobile browsers compatible with Vaadin TouchKit and provide
                a fallback UI for any other browsers. You can do this by having a custom
                <classname>UIProvider</classname> that creates the UIs.
            </para>

            <para>
                As TouchKit supports WebKit-based browsers, you can do the recognition by
                checking if the <parameter>user-agent</parameter> string contains the
                sub-string "<literal>webkit</literal>" as follows:
            </para>

            <programlisting><?pocket-size 85% ?><![CDATA[public class MyUIProvider
        extends UIProvider {
    @Override
    public Class<? extends UI> getUIClass(
            UIClassSelectionEvent event) {
        String userAgent = event.getRequest()
                .getHeader("user-agent").toLowerCase();
        if(userAgent.contains("webkit")) {
            return MyMobileUI.class;
        } else {
            return MyFallbackUI.class;
        }
    }
}]]></programlisting>

            <para>
                The custom UI provider has to be added in a custom servlet class, which
                you need to define in the <filename>web.xml</filename>, for example as
                follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyServlet extends VaadinServlet {
    private MyUIProvider uiProvider = new MyUIProvider();

    @Override
    protected void servletInitialized() throws ServletException {
        super.servletInitialized();
        
        getService().addSessionInitListener(
                new SessionInitListener() {
            @Override
            public void sessionInit(SessionInitEvent event)
                    throws ServiceException {
                event.getSession().addUIProvider(uiProvider);
            }
        });

        ... other custom servlet settings ...
    }
}]]></programlisting>

            <para>
                See the Vornitologist demo for a working example.
            </para>
        </section>

        <section xml:id="mobile.considerations.geolocation">
            <title>Geolocation</title>

            <para>
                The geolocation feature in TouchKit allows receiving the geographical
                location from the mobile device. The browser will ask the user to confirm
                that the web site is allowed to get the location information. Tapping
                <guibutton>Share Location</guibutton> gives the permission. The browser
                will give the position acquired by GPS, cellular positioning, or Wi-Fi
                positioning, as enabled in the device.
            </para>

            <para>
                Geolocation is requested by calling the static
                <classname>Geolocator</classname><methodname>.detect()</methodname> method. You
                need to provide a <classname>PositionCallback</classname> handler that
                is called when the device has an answer for your request. If the geolocation 
                request succeeded, <methodname>onSuccess()</methodname> is called. Otherwise, e.g
                . if the user didn't allow sharing of his location, <methodname>
                onFailure</methodname> is called. The geolocation data is provided in a
                <classname>Position</classname> object.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Geolocator.detect(new PositionCallback() {
    public void onSuccess(Position position) {
        double latitude  = position.getLatitude();
        double longitude = position.getLongitude();
        double accuracy  = position.getAccuracy();

        ...
    }

    public void onFailure(int errorCode) {
        ...
    }
});]]></programlisting>

            <para>
                The position is given as degrees with fractions. The longitude is positive
                to East and negative to West of the Prime Meridian passing through
                Greenwich, following the convention for coordinate systems. The accuracy
                is given in meters. In addition to the above data, the following are also
                provided:
            </para>
            <orderedlist>
                <listitem>Altitude</listitem>
                <listitem>Altitude accuracy</listitem>
                <listitem>Heading</listitem>
                <listitem>Speed</listitem>
            </orderedlist>
            <para>
                If any of the position data is unavailable, its value will be zero.
            </para>

            <para>
                The <methodname>onFailure()</methodname> is called if the positioning
                fails for some reason. The <parameter>errorCode</parameter> explains the
                reason. Error 1 is returned if the permission was denied, 2 if the
                position is unavailable, 3 on positioning timeout, and 0 on an unknown
                error.
            </para>

            <para>
                Notice that geolocation can take significant time, depending on the
                location method used by the device. With Wi-Fi and cellular positioning,
                the time is usually less than 30 seconds. With GPS, it can reach minutes
                or longer, especially if the reception is bad. However, once a location fix
                has been made, updates to the location will be faster. If you are making
                navigation software, you need to update the position data fairly frequently by
                calling <classname>Geolocator</classname><methodname>.detect()</methodname>
                multiple times.
            </para>
        </section>

        <section xml:id="mobile.features.offline">
            <title>Offline Mode</title>

            <para>
                While regular Vaadin TouchKit applications are server-side applications,
                it allows a special <emphasis>offline mode</emphasis>, which is a
                client-side Vaadin UI that switched to automatically when the network
                connection is not available. The offline UI is included in the widget set
                of the regular server-side UI and stored in the browser cache. By
                providing a special cache manifest, the browser caches the page so
                strongly that it persists even after browser restart.
            </para>

            <para>
                During offline operation, the offline UI can store data in the HTML5 local
                storage of the mobile browser and then passed to the server-side
                application when the connection is again available.
            </para>

            <!-- TODO: Offline theme -->

            <para>
                See the Vornitologist demo for a complete example of the offline mode.
            </para>
        </section>
    </section>

    <section xml:id="mobile.testing">
        <title>Testing and Debugging on Mobile Devices</title>

        <para>
            Testing places special challenges for mobile devices. The mobile browsers may not
            have much debugging features and you may not be able to install third-party
            debugging add-ons, such as Firebug.
        </para>

        <section xml:id="mobile.testing.debugging">
            <title>Debugging</title>

            <para>
                The debug mode, as described in <xref linkend="advanced.debug-production-modes"/>,
                works on mobile browsers as well, even if it is a bit harder to use.
            </para>

            <para>
                The lack of FireBug and similar tools can be helped with simple client-side
                coding. For example, you can dump the HTML content of the page with the
                <parameter>innerHTML</parameter> property in the HTML DOM.
            </para>

            <para>
                TouchKit supports especially WebKit-based browsers, which are used in iOS and
                Android devices. You can therefore reach a good compatibility by using a
                desktop browser based on WebKit. Features such as geolocation are also
                supported by desktop browsers. If you make your phone/tablet-detection and
                orientation detection using screen size, you can easily emulate the modes by
                resizing the browser.
            </para>
        </section>

        <!-- section xml:id="mobile.testing.testing">
        <title>Debugging</title>

        <para>
        </para>
    </section -->
    </section>

    <indexterm startref="term.touchkit" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
