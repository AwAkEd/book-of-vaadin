<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="rapid.exception">
    <title>Exception Handling</title>

    <para>
        When something goes wrong in a Vaadin application, a small error indicator icon is
        shown on the control that was interacted with.  When hovering over icon, a tooltip
        containing the entire stacktrace of the exception is shown. No normal person (that
        is, other than a software developer) understands what this means and knows what to
        do.
    </para>

    <para>
        In this section, we will remove the stack traces and replace them with error
        messages in terms that a normal user would understand.
    </para>
    
    <section xml:id="rapid.exception">
        <title>Preventing Stacktraces in the UI</title>

        <para>
            The autogenerated code lets the exceptions fall all the way through to the
            user interface. This can easily be changed by overriding the
            <methodname>terminalError()</methodname> method in the
            <classname>Application</classname> subclass.
        </para>
        
        <programlisting><?pocket-size 65% ?><![CDATA[@Override
public void terminalError(Terminal.ErrorEvent event) {
    Window errorWindow = findWindowForError(event);
    // Shows an error notification
    if (errorWindow != null) {
        errorWindow.showNotification(
            "An internal error has occurred, please " +
                "contact the administrator!",
            Notification.TYPE_ERROR_MESSAGE);
    }

    // print the error
    logger.log(Level.SEVERE,
        "An uncaught exception occurred: ",
        event.getThrowable());
}]]></programlisting>
    </section>

    <section xml:id="rapid.exception.catch">
        <title>Where to Catch Exceptions</title>
        <para>
            The most likely places for errors to occur in the example application are when
            interacting with the database. Validation errors are already handled in the
            generated code, but errors due to constraint violations on the database level
            and communication failures need to be caught and handled correctly.
        </para>
        
        <para>
            Almost all saving and deleting of entities is handled through the
            <classname>AbstractEntityView</classname>, which is the super type of all but
            one view. <classname>CalendarView</classname> is the custom view that does not
            extend <classname>AbstractEntityView</classname>, and thus needs to catch the
            exceptions separately. Almost all exceptions can be handled in a good way by
            handling them in <classname>AbstractEntityView</classname> and
            <classname>CalendarView</classname>. When an exception occurs, an error
            notification should be displayed to the user.
        </para>

        <section xml:id="rapid.exception.catch.abstractentityview">
            <title>Handling Exceptions in AbstractEntityView</title>

            <para>
                The Vaadin plug-in for Spring Roo generates the
                <classname>AbstractEntityView</classname> class for handling CRUD for all
                different entities in the application. This means that the methods that
                handle saving and deleting of entities can be changed to include
                customized exception handling. Roo generates an aspect,
                <classname>AbstractEntityView_Roo_AbstractEntityView</classname>
                containing the <methodname>doCommit()</methodname> and
                <methodname>doDelete()</methodname> methods. These methods can be changed
                by moving them to the <classname>AbstractEntityView</classname>, which
                will cause Roo to stop autogenerating the methods in the
                <classname>AbstractEntityView_Roo_AbstractEntityView</classname> aspect.
            </para>
            
            <para>
                Move the methods to <classname>AbstractEntityView</classname> and surround
                the method contents with a <literal>try...catch</literal> block, catching
                all <classname>Exception</classname>s and showing a notification about
                which operation failed.
            </para>
            
            <programlisting><?pocket-size 65% ?><![CDATA[@Transactional
public void doDelete() {
    try {
        Object id = getIdForEntity(getEntityForItem(
                        getForm().getItemDataSource()));
        if (id != null) {
            getTable().removeItem(id);
        }
    } catch (Exception e) {
        logger.log(Level.SEVERE, "Could not delete entity", e);
        getWindow().showNotification(
            "Deletion of the item failed.",
            Notification.TYPE_ERROR_MESSAGE);
    }
}]]></programlisting>
        </section>
        
        <section xml:id="rapid.exception.catch.calendarview">

            <title>Handling Exceptions in CalendarView</title>
            <para>
                Since <classname>CalendarView</classname> is a custom view which doesn't
                extend <classname>AbstractEntityView</classname>, it also needs to handle
                exceptions. The calendar view does the same things as the other entity
                views, but with a different layout and logic.
            </para>

            <para>
                Exception handling needs to be added to all code that persists or deletes
                data from the database.  The <classname>CalendarView</classname> does this
                in several locations: When creating a new entry, when editing an entry,
                when moving an entry and when resizing an entry. E.g. the range select
                handler, which persists a work entry when it is first created should be
                changed to wrap the call to <methodname>workEntry.persist()</methodname>
                in a <literal>try...catch</literal> block.
            </para>
            
            <programlisting><?pocket-size 65% ?><![CDATA[@Override
public void rangeSelect(RangeSelectEvent event) {

    ...
    // Build a work entry
    ...

    try {
        workEntry.persist();
        showEditorPopup(workEntry, true);
    } catch (Exception e) {
        logger.log(Level.SEVERE, "Could not store entity", e);
        getWindow().showNotification("Could not create a new " +
                work entry due to an internal error.",
                Notification.TYPE_ERROR_MESSAGE);
    }
}]]></programlisting>

            <para>
                In the rest of the code, all calls to <methodname>persist()</methodname>,
                <methodname>merge()</methodname> or <methodname>delete()</methodname> are
                wrapped in <literal>try...catch</literal> blocks and a notification with a
                suitable message for each of the cases is displayed.
            </para>
        </section>
    </section>

</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
