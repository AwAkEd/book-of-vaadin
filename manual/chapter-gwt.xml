<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="gwt">
	<title>Developing New Components</title>

    <indexterm xml:id="term.gwt" class="startofrange" significance="preferred">
        <primary>Google Web Toolkit</primary>
        <secondary>widgets</secondary>
    </indexterm>
    <indexterm><primary>widgets</primary></indexterm>

	<para>
		This chapter describes how you can create custom client-side components as Google
		Web Toolkit (GWT) widgets or JavaScript components and how you integrate them with
		Vaadin. The client-side implementations of all standard user interface components
		in Vaadin use the same client-side interfaces and patterns.
	</para>

	<note>
		<title>On Terminology</title>
		<para>
            <indexterm><primary>widget, definition</primary></indexterm>

            Google Web Toolkit uses the term <emphasis>widget</emphasis> for user
            interface components. In this book, we use the term widget to refer to
            client-side components made with <indexterm><primary>Google Web
            Toolkit</primary></indexterm>Google Web Toolkit, while using the term
            <emphasis>component</emphasis> in a general sense and also in the special
            sense for server-side components.
		</para>
	</note>

    <section xml:id="gwt.overview">
        <title>Overview</title>

        <para>
            Vaadin components consist of two parts: a server-side and a client-side
            component. The latter are also called <emphasis>widgets</emphasis> in Google
            Web Toolkit (GWT) parlance. A Vaadin application uses the API of the
            server-side component, which is "painted" as a client-side widget in the
            browser. As on the server-side, the client-side widgets form a hierarchy of
            layout widgets and regular widgets as the leaves.
        </para>

        <para>
            The communication between a client-side widget and a server-side component is
            managed with a <emphasis>connector</emphasis> that handles syncronizing the
            widget state and events to and from the server-side.

            <indexterm><primary>connector</primary></indexterm>
        </para>

        <para>
            When painting the user interface, a client-side widget is created for each
            server-side component. This mapping is defined in the connector class with a
            <literal>@Connect</literal> annotation.

            <indexterm><primary>@Connect</primary></indexterm>
        </para>

        <para>
            The state of a server-side component is synchronized automatically to the
            client-side widget and back using a <emphasis>shared state</emphasis>
            object. A shared state object implements the
            <interfacename>ComponentState</interfacename> interface and it is used both in
            the server-side and the client-side component. On the client-side, a connector
            always has access to its state instance, as well to the state of its parent
            component state and the states of its children.

            <indexterm><primary>state object</primary></indexterm>
            <indexterm><primary><classname>ComponentState</classname></primary></indexterm>
        </para>

        <para>
            The state sharing assumes that state is defined with standard Java types, such
            as integers, doubles, ...
        </para>

        <para>
            In addition to state, both server- and client-side can make remote procedure
            calls (RPC) on the other side. RPC is used foremost for event
            notifications. For example, when a client-side connector of a button receives
            a click, it sends the event to the server-side using RPC.
        </para>

        <simplesect xml:id="gwt.overview.javascript">
            <title>Integrating JavaScript Components</title>

            <para>
                In addition to the GWT widget integration, Vaadin offers a simplified way
                to integrate pure JavaScript components. The JavaScript connector code is
                published from the server-side. As the JavaScript integration does not
                involve GWT programming, no widget set compilation is needed.

                <indexterm><primary>JavaScript</primary></indexterm>
            </para>
        </simplesect>
    </section>

    <section xml:id="gwt.layout">
        <title>Handling Layouts</title>

        <section xml:id="gwt.sizes">
            <title>Handling Sizes</title>
        </section>

        <section xml:id="gwt.layout.managed">
            <title>Managed Layouts</title>

            <para>
                A <classname>ManagedLayout</classname> is the most versatile, and at the
                same time the heaviest, way to lay out widgets.
            </para>
        </section>
    </section>

    <section xml:id="gwt.addons">
        <title>Creating Add-ons</title>

        <indexterm xml:id="term.gwt.addons" class="startofrange" significance="preferred">
            <primary>add-ons</primary>
            <secondary>creating</secondary>
        </indexterm>

        <para>
        </para>

        <indexterm startref="term.gwt.addons" class="endofrange"/>
    </section>

    <section xml:id="gwt.vaadin-6-migration">
        <title>Migrating from Vaadin 6</title>

        <indexterm xml:id="term.gwt.vaadin-6-migration" class="startofrange" significance="preferred">
            <primary>Vaadin 6 Migration</primary>
            <secondary>add-ons</secondary>
        </indexterm>

        <para>
            The client-side architecture was redesigned almost entirely in Vaadin 7. In
            Vaadin 6, state synchronization was done explicitly by serializing and
            deserializing the state on the server- and client-side. In Vaadin 7, the
            serialization is handled automatically by the framework using state objects.
        </para>
        
        <para>
            In Vaadin 6, a server-side component serialized its state to the client-side
            using the <interfacename>Paintable</interfacename> interface and deserialized
            the state through the <interfacename>VariableOwner</interfacename>
            interface. In Vaadin 7, these are done through the
            <interfacename>ClientConnector</interfacename> interface.
        </para>

        <para>
            On the client-side, a widget deserialized its state through the
            <interfacename>Paintable</interfacename> interface and sent state changes
            through the <interfacename>ApplicationConnection</interfacename> object. In
            Vaadin 7, these are replaced with the
            <interfacename>ServerConnector</interfacename>.
        </para>

        <para>
            In addition to state synchronization, Vaadin 7 has an RPC mechanism that can
            be used for communicating events. They are especially useful for events that
            are not associated with a state change, such as a button click.
        </para>

        <para>
            The framework ensures that the connector hierarchy and states are up-to-date
            when listeners are called.
        </para>

        <section xml:id="gwt.vaadin-6-migration.quick">
            <title>Quick (and Dirty) Migration</title>

            <para>
                Vaadin 7 has a compatibility layer that allows quick conversion of a widget.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Create a connector class, such as
                        <classname>MyConnector</classname>, that extends
                        <classname>Vaadin6Connector</classname>. Implement the
                        <methodname>createWidget()</methodname> method as
                        <literal>GWT.create(MyWidget.class)</literal>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Move the <literal>@ClientWidget(MyWidget.class)</literal> from the
                        server-side component, say <classname>MyComponent</classname>, to
                        the <classname>MyConnector</classname> class and make it
                        <literal>@Connect(MyComponent.class)</literal>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Have the server-side component implement the
                        <interface>Vaadin6Component</interface> interface to enable
                        compatibility handling.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Remove any calls to <literal>super.paintContent()</literal>
                    </para>
                </listitem>
            </orderedlist>
        </section>

        <indexterm startref="term.gwt.vaadin-6-migration" class="endofrange"/>
    </section>

    <section xml:id="gwt.eclipse">
        <title>Starting It Simple With Eclipse</title>

        <indexterm xml:id="term.gwt.eclipse" class="startofrange">
            <primary>Eclipse</primary>
            <secondary>widget development</secondary>
        </indexterm>

		<para>
			While you can develop new widgets with any IDE or even without, you may find
			Eclipse and the Vaadin Plugin for it useful, as it automates all the basic
			routines of widget development, most importantly the creation of new widgets.
		</para>

		<section xml:id="gwt.eclipse.widget">
			<title>Creating a Widget</title>


            <orderedlisting>
                <listitem>
                    <para>
                        Right-click the project in the Project Explorer and select
                        <menuchoice><guimenu>New</guimenu><guimenuitem>Other...</guimenuitem></menuchoice>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        In the wizard selection, select
                        <menuchoice><guimenu>Vaadin</guimenu><guimenuitem>Vaadin
                        Widget</guimenuitem></menuchoice> and click
                        <guibutton>Next</guibutton>.
                    </para>

                    <screenshot>
                        <mediaobject>
                            <imageobject role="html">
                                <imagedata align="center" fileref="img/eclipse/widget-new-select.png"/>
                            </imageobject>
                            <imageobject role="fo">
                                <imagedata scale="100" smallscale="100%" align="center" fileref="img/eclipse/widget-new-select.png"/>
                            </imageobject>
                        </mediaobject>
                    </screenshot>
                </listitem>
                <listitem>
                    <para>
                        In the <guilabel>New Component Wizard</guilabel>, make the following
                        settins.
                    </para>

                    <screenshot>
                        <mediaobject>
                            <imageobject>
                                <imagedata scale="100" smallscale="100%" align="center" fileref="img/eclipse/widget-new-settings.png"/>
                            </imageobject>
                        </mediaobject>
                    </screenshot>
                    
                    <variablelist>
                        <varlistentry>
                            <term><guilabel>Source folder</guilabel></term>
                            <listitem>
                                <para>
                                    The root folder of the entire source tree. The default
                                    value is the default source tree of your project, and
                                    you should normally leave it unchanged unless you have
                                    a different project structure.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><guilabel>Package</guilabel></term>
                            <listitem>
                                <para>
                                    The parent package under which the new server-side
                                    component should be created. If the project does not
                                    already have a widget set, one is created under this
                                    package in <package>widgetset</package>
                                    subpackage. The subpackage will contain the
                                    <filename>.gwt.xml</filename> descriptor that defines
                                    the widget set and the new widget stub under the
                                    <package>widgetset.client</package> subpackage.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Name</guilabel></term>
							<listitem>
								<para>
									The class name of the new <emphasis>server-side
									component</emphasis>. The name of the client-side
									widget stub will be the same but with
									"-<classname>Widget</classname>" suffix, for example,
									<classname>MycomponentWidget</classname>. You can
									rename the classes afterwards.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><guilabel>Superclass</guilabel></term>
							<listitem>
								<para>
									The superclass of the server-side component. It is
									<classname>AbstractComponent</classname> by default,
									but <classname>com.vaadin.ui.AbstractField</classname>
									or <classname>com.vaadin.ui.AbstractSelect</classname>
									are other commonly used superclasses. If you are
									extending an existing component, you should select it
									as the superclass. You can easily change the
									superclass later.
								</para>
							</listitem>
						</varlistentry>
						<varlistentry>
							<term><guilabel>Template</guilabel></term>
							<listitem>
								<para>
									Select which template to use. The default is
									<guilabel>Full fledged</guilabel>, which creates the
									server-side component, the client-side widget, the
									connector, a shared state object, and an RPC
									object. The <guilabel>Connector only</guilabel> leaves
									the shared state and RPC objects out.
								</para>
							</listitem>
						</varlistentry>
					</variablelist>

					<para>
						Finally, click <guibutton>Finish</guibutton> to create the new component.
					</para>
                </listitem>
            </orderedlisting>

			<para>
				The wizard will:
			</para>

			<itemizedlist>
				<listitem>
                    <para>Create a server-side component stub in the base package</para>
                </listitem>

				<listitem>
                    <para>
                        If the project does not already have a widget set, the wizard
                        creates a GWT module descriptor file
                        (<filename>.gwt.xml</filename>) in the base package and modifies
                        the <filename>web.xml</filename> deployment descriptor to specify
                        the widget set class name parameter for the application
                    </para>
                </listitem>

				<listitem>
                    <para>Create a client-side widget stub (along with the connector and
                    shared state and RPC stubs) in the
                    <filename>client.componentname</filename> package under the base
                    package</para>
                </listitem>
			</itemizedlist>

			<para>
				The structure of the server-side component and the client-side widget, and
				the serialization of component state between them, is explained in the
				subsequent sections of this chapter.
			</para>

			<para>
				To compile the widget set, click the <guibutton>Compile widget
				set</guibutton> button in the Eclipse toolbar. See <xref
				linkend="gwt.eclipse.compiling"/> for details. After the compilation
				finishes, you should be able to run your application as before, but using
				the new widget set. The compilation result is written under the
				<filename>WebContent/VAADIN/widgetsets</filename> folder. When you need to
				recompile the widget set in Eclipse, see <xref
				linkend="gwt.eclipse.compiling"/>. For detailed information on compiling
				widget sets, see <xref linkend="gwt.development.compiler"/>.
			</para>

			<para>
				The following setting is inserted in the <filename>web.xml</filename>
				deployment descriptor to enable the widget set:
			</para>

			<programlisting><?pocket-size 65% ?>&lt;init-param&gt;
    &lt;description&gt;Application widgetset&lt;/description&gt;
    &lt;param-name&gt;widgetset&lt;/param-name&gt;
    &lt;param-value&gt;<emphasis mode="bold">com.example.myproject.widgetset.MyprojectApplicationWidgetset</emphasis>&lt;/param-value&gt;
&lt;/init-param&gt;</programlisting>

			<para>
				You can refactor the package structure if you find need for it, but GWT
				compiler requires that the client-side code <emphasis>must</emphasis>
				always be stored under a package named "<filename>client</filename>".
			</para>
        </section>

		<section xml:id="gwt.eclipse.compiling">
			<title>Compiling the Widget Set</title>

			<para>
				After you edit a widget, you need to compile the widget set. The Vaadin
				Plugin for Eclipse automatically suggests to compile the widget set in
				various situations, such as when you save a client-side source file. If
				this gets annoying, you can disable the automatic recompilation in the
				Vaadin category in project settings, by selecting the <guilabel>Suspend
				automatic widgetset builds</guilabel> option.
            </para>

            <para>
                You can compile the widget set manually by clicking the <guibutton>Compile
                widgetset</guibutton> button in the Eclipse toolbar, shown in <xref
                linkend="figure.gwt.eclipse.compiling.toolbar"/>, while the project is
                open and selected. If the project has multiple widget set definition
                files, you need to select the one to compile in the Project Explorer.
			</para>

            <!-- TODO: Better icon as requested in #3692. -->
            <figure xml:id="figure.gwt.eclipse.compiling.toolbar">
				<title>The <guibutton>Compile Widgetset</guibutton> Button in Eclipse Toolbar</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/eclipse/widgetset-compiling-toolbar-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="70%" align="center" fileref="img/eclipse/widgetset-compiling-toolbar-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                The compilation progress is shown in the <guilabel>Console</guilabel>
                panel in Eclipse, illustrated in <xref
                linkend="figure.gwt.eclipse.compiling"/>. You should note especially the
                list of widget sets found in the class path.
            </para>

			<figure xml:id="figure.gwt.eclipse.compiling" float="center" floatstyle="before">
				<title>Compiling a Widget Set</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/eclipse/widgetset-compiling.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="100%" align="center" fileref="img/eclipse/widgetset-compiling.png"/>
					</imageobject>
				</mediaobject>
			</figure>
            
			<para>
				The compilation output is written under the
				<filename>WebContent/VAADIN/widgetsets</filename> folder, in a widget set
				specific folder.
			</para>

            <para>
                You can speed up the compilation significantly by compiling the widget set
                only for your browser during development. The generated
                <filename>.gwt.xml</filename> descriptor stub includes a disabled element
                that specifies the target browser. See <xref linkend="gwt.widgetset"/> for
                more details on setting the <literal>user-agent</literal> property.
            </para>

			<para>
				For more information on compiling widget sets, see <xref
				linkend="gwt.development.compiler"/>. Should you compile a widget set
				outside Eclipse, you need to refresh the project by selecting it in
				<guilabel>Project Explorer</guilabel> and pressing <keycap>F5</keycap>.
			</para>
        </section>

        <indexterm startref="term.gwt.eclipse" class="endofrange"/>
    </section>

    <section xml:id="gwt.javascript">
        <title>Integrating JavaScript Components</title>

        <indexterm xml:id="term.gwt.javascript" class="startofrange">
            <primary>JavaScript integration</primary>
        </indexterm>

        <para>
            Vaadin allows simplified integration of pure JavaScript components. The
            JavaScript connector code is published from the server-side. As the JavaScript
            integration does not involve GWT programming, no widget set compilation is
            needed.
        </para>

        <section xml:id="gwt.javascript.connector">
            <title>Defining a JavaScript Connector</title>

            <para>
                A JavaScript connector is a function that handles communication between
                the server-side code and the integrated JavaScript code. The connector
                functions are added in the <literal>window</literal> object.
            </para>
        </section>

        <indexterm startref="term.gwt.javascript" class="endofrange"/>
    </section>

    <indexterm startref="term.gwt" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

