<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="application">
	<title>Writing a Web Application</title>

    <!-- TODO: Too much stuff in the chapter intro - move to overview. -->

	<para>
        This chapter provides the fundamentals of web application development with Vaadin,
        concentrating on the basic elements of an application from a practical
        point-of-view.
	</para>

	<para>
		If you are a newcomer to AJAX development, you may benefit from <xref
		linkend="architecture.technology.ajax"/>, which explains the role of pages in
		Vaadin.
	</para>

	<section xml:id="application.overview">
		<title>Overview</title>

		<para>
			An application made with Vaadin runs as a Java Servlet in a Servlet
			container. The entry-point is the <emphasis>&root;</emphasis> class, which
			needs to create and manage the user interface components. User input is
			handled with event listeners, which can be simplified by binding user
			interface components directly to data. Visual appearance is defined in themes
			as CSS <!-- TODO Vaadin 7: SASS --> files. Icons, other images, and
			downloadable files are handled as <emphasis>resources</emphasis>, which can be
			external or served by the application server or the application itself.
		</para>
		
		<figure xml:id="figure.application.architecture">
			<title>Application Architecture</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/application/application-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="70" smallscale="100%" align="center" fileref="img/application/application-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			<xref linkend="figure.application.architecture"/> above illustrates the basic
			architecture of an application made with the Vaadin framework, with all the
			major elements, which are introduced below and discussed in detail in this
			chapter.
		</para>

		<para>
			First of all, a Vaadin application must have one or more &root; classes that
			extend the abstract <classname>com.vaadin.ui.&rootclass;</classname> class and
			implement the <methodname>init()</methodname> method.  A custom theme can be
			defined as an annotation for the &root;.
		</para>
		
		<programlisting><![CDATA[@Theme("hellotheme")
public class HelloWorld extends Root {
    protected void init(WrappedRequest request) {
        ... initialization code goes here ...
    }
}]]></programlisting>

        <para>
            A &root; is a viewport to a Vaadin application running in a web page.  A web
            page, represented by the <classname>Page</classname> class, can have multiple
            such &root;s embedded within it. Such situation is typical especially with
            portlets in a portal. An application can run in multiple browser windows, each
            having a <classname>Page</classname> and one or more &root;s.
        </para>

		<para>
            The &root; API may seem similar to Java Servlet API, but that is only
            superficial. Vaadin framework associates requests with sessions so that an
            application instance is really a session object. Because of this, you can
            develop web applications much like you would develop desktop applications.
		</para>
		
        <note>
            <title>Restarting Application Session</title>

            <para>
                When you first open an URL for the application, it creates a new user
                session. The session is preserved even if you reload the page. However, if
                you use Eclipse, it likes to do hot deployment to Tomcat and you may
                experience a problem that the application does not return to its initial
                state after you modify code. As Tomcat likes to persist sessions on server
                shutdown, the application state can remain even if you restart the server.
            </para>

            <para>
                Adding the <uri>?restartApplication</uri> parameter in the URL tells
                the Vaadin servlet to create a new <classname>Application</classname>
                instance on loading the page. If you also include a URI fragment, the
                parameter should be given before the fragment.
            </para>
        </note>

		<para>
			The most important task in the initialization is the creation of the initial
			user interface. This, and the deployment of the application as a Java Servlet
			in the Servlet container, as described in <xref
			linkend="application.environment"/>, are the minimal requirements for an
			application.
		</para>

		<para>
			Below is a short overview of the other basic elements of an application
			besides &root;:
		</para>

		<variablelist>
			<varlistentry>
				<term>&rootclass;</term>
				<listitem>
					<para>
                        A <emphasis>&root;</emphasis> represents a HTML fragment in which
                        a Vaadin application runs in a web page. It typically fills the
                        entire page, but can also be just a part of a page. You normally
                        develop a Vaadin application by extending
                        <classname>&rootclass;</classname> and adding user interface
                        components to it. A &root; is essentially a viewport or window
                        connected to an application, and you can have many such views
                        especially in a multi-window application. Normally, when the user
                        opens a new page with the URL of the Vaadin application, a new
                        <classname>Root</classname> (and the associated
                        <classname>Page</classname> object) is automatically created for
                        it.
                    </para>

                    <para>
                        The current &root; object can be globally accessed with
                        <methodname>Root.getCurrent()</methodname>. The static method
                        returns the thread-local &root; instance for the currently
                        processed request (see <xref
                        linkend="advanced.global.threadlocal"/>).
                    </para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Page</term>
				<listitem>
					<para>
                        A <classname>&rootclass;</classname> is associated with a
                        <classname>Page</classname> object that represents the web page as
                        well as the browser window in which the &root; runs.
					</para>

                    <para>
                        The <classname>Page</classname> object for the currently processed
                        request can be globally accessed from a Vaadin application with
                        <methodname>Page.getCurrent()</methodname>. This is equivalent to
                        calling
                        <methodname>&rootclass;.getCurrent().getPage()</methodname>.
                    </para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Application</term>
				<listitem>
					<para>
						A Vaadin application, as defined by the
						<classname>Application</classname> class, is essentially a user
						session. It can have multiple windows, each represented by a
						<classname>&rootclass;</classname>, which in turn is associated
						with a <classname>Page</classname>.
					</para>

                    <para>
                        You can actually also develop a Vaadin application by extending
                        <classname>Application</classname> instead of
                        <classname>&rootclass;</classname>, and create the &root;s
                        yourself.
                    </para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>User Interface Components</term>
				<listitem>
					<para>
						The user interface consists of components that are created by the
						application. They are laid out hierarchically using special
						<emphasis>layout components</emphasis>, with a &root; at the top
						of the hierarchy. User interaction with the components causes
						<emphasis>events</emphasis> related to the component, which the
						application can handle. <emphasis>Field components</emphasis> are
						intended for inputting values and can be directly bound to data
						using the Vaadin Data Model. You can make your own user interface
						components through either inheritance or composition. For a
						thorough reference of UI components, see <xref
						linkend="components"/>, for layout components, see <xref
						linkend="layout"/>, and for composing components, see <xref
						linkend="components.customcomponent"/>.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Events and Listeners</term>
				<listitem>
					<para>
                        Vaadin follows an event-driven programming paradigm, in which
                        events, and listeners that handle the events, are the basis of
                        handling user interaction in an application. <xref
                        linkend="architecture.events"/> gave an introduction to events and
                        listeners from an architectural point-of-view, while <xref
                        linkend="application.events"/> later in this chapter takes a more
                        practical view.
                    </para>
                </listitem>
            </varlistentry>

			<varlistentry>
				<term>Resources</term>
				<listitem>
					<para>
						A user interface can display images or have links to web pages or
						downloadable documents. These are <emphasis>resources</emphasis>,
						which can be external or provided by the web server or the
						application itself. <xref linkend="application.resources"/> gives
						a practical overview of the different types of resources.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Themes</term>
				<listitem>
					<para>
						The presentation and logic of the user interface are
						separated. While the UI logic is handled as Java code, the
						presentation is defined in <emphasis>themes</emphasis> as CSS<!--
						TODO Vaadin 7: or SASS-->. Vaadin includes some built-in
						themes. User-defined themes can, in addition to style sheets,
						include HTML templates that define custom layouts and other theme
						resources, such as images. Themes are discussed in detail in <xref
						linkend="themes"/>, custom layouts in <xref
						linkend="layout.customlayout"/>, and theme resources in <xref
						linkend="application.resources.theme"/>.
					</para>
				</listitem>
			</varlistentry>

			<varlistentry>
				<term>Data Binding</term>
				<listitem>
					<para>
						Field components are essentially views to data, represented in the
						<emphasis>Vaadin Data Model</emphasis>. Using the data model, the
						components can get their values from and update user input to the
						data model directly, without the need for any control code. A
						field component is always bound to a <emphasis>property</emphasis>
						and a group a fields to an <emphasis>item</emphasis> that holds
						the properties. Items can be collected in a
						<emphasis>container</emphasis>, which can act as a data source for
						some components such as tables or lists. While all the components
						have a default data model, they can be bound to a user-defined
						data source. For example, you can bind a
						<classname>Table</classname> component to an SQL query
						response. For a complete overview of data binding in Vaadin,
						please refer to <xref linkend="datamodel"/>.
					</para>
				</listitem>
			</varlistentry>
        </variablelist>
	</section>

		
    <section xml:id="application.events">
        <title>Handling Events with Listeners</title>

        <para>
            Let us put into practice what we learned of event handling in <xref
            linkend="architecture.events"/>. You can handle events in three basic ways, as
            shown below.
        </para>

		<para>
			The following example follows a typical pattern where you have a
			<classname>Button</classname> component and a listener that handles user
			interaction (clicks) communicated to the application as events. Here we define
			a class that listens click events.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButton implements Button.ClickListener {
    Button thebutton;

    /** Creates button into given container. */
    public TheButton(AbstractComponentContainer container) {
        thebutton = new Button ("Do not push this button");
        thebutton.addListener(this);
        container.addComponent(thebutton);
    }
    
    /** Handle button click events from the button. */
    public void buttonClick (Button.ClickEvent event) {
        thebutton.setCaption ("Do not push this button again");
    }
}]]></programlisting>

		<para>
			As an application often receives events for several components of the
			same class, such as multiple buttons, it has to be able to
			distinguish between the individual components. There are several
			techniques to do this, but probably the easiest is to use the
			property of the received event, which is set to the object sending
			the event. This requires keeping at hand a reference to every object that
			emits events.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButtons implements Button.ClickListener {
    Button thebutton;
    Button secondbutton;

    /** Creates two buttons in given container. */
    public TheButtons(AbstractComponentContainer container) {
        thebutton = new Button ("Do not push this button");
        thebutton.addListener(this);
        container.addComponent(thebutton);
        
        secondbutton = new Button ("I am a button too");
        secondbutton.addListener(this);
        container.addComponent (secondbutton);
    }
    
    /** Handle button click events from the two buttons. */
    public void buttonClick (Button.ClickEvent event) {
        if (event.getButton() == thebutton)
            thebutton.setCaption("Do not push this button again");
        else if (event.getButton() == secondbutton)
            secondbutton.setCaption("I am not a number");
    }
}]]></programlisting>

		<para>
			Another solution to handling multiple events of the same class involves
			attaching an event source to a listener method instead of the class. An event
			can be attached to a method using another version of the
			<methodname>addListener()</methodname> method, which takes the event handler
			method as a parameter. The method can be passed either by the name of the
			method or as a <classname>Method</classname> object. In the example below, we
			use the name of the method, as a string (which is not checked at compile
			time).
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButtons2 {
    Button thebutton;
    Button secondbutton;

    /** Creates two buttons in given container. */
    public TheButtons2(AbstractComponentContainer container) {
        thebutton = new Button ("Do not push this button");
        thebutton.addListener(Button.ClickEvent.class, this,
                              "theButtonClick");
        container.addComponent(thebutton);
        
        secondbutton = new Button ("I am a button too");
        secondbutton.addListener(Button.ClickEvent.class, this,
                                 "secondButtonClick");
        container.addComponent (secondbutton);
    }
    
    public void theButtonClick (Button.ClickEvent event) {
        thebutton.setCaption ("Do not push this button again");
    }

    public void secondButtonClick (Button.ClickEvent event) {
        secondbutton.setCaption ("I am not a number!");
    }
}]]></programlisting>

		<para>
			Adding a listener method with <methodname>addListener()</methodname> is
			really just a wrapper that creates a
			<classname>com.vaadin.event.ListenerMethod</classname>
			listener object, which is an adapter from a listener class to a
			method. It implements the
			<classname>java.util.EventListener</classname> interface and can
			therefore work for any event source using the interface. Notice that
			not all listener classes necessarily inherit the
			<classname>EventListener</classname> interface.
		</para>

		<para>
			The third way, which uses anonymous local class definitions, is often the
			easiest as it does not require cumbering the managing class with new
			interfaces or methods. The following example defines an anonymous class that
			inherits the <classname>Button.ClickListener</classname> interface and
			implements the <methodname>buttonClick()</methodname> method.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButtons3 {
    Button thebutton;
    Button secondbutton;

    /** Creates two buttons in given container. */
    public TheButtons3(AbstractComponentContainer container) {
        thebutton = new Button ("Do not push this button");

        /* Define a listener in an anonymous class. */
        thebutton.addListener(new Button.ClickListener() {
            /* Handle the click. */
            public void buttonClick(ClickEvent event) {
                thebutton.setCaption (
                        "Do not push this button again");
            }
        });
        container.addComponent(thebutton);
        
        secondbutton = new Button ("I am a button too");
        secondbutton.addListener(new Button.ClickListener() {
            public void buttonClick(ClickEvent event) {
                secondbutton.setCaption ("I am not a number!");            
            }
        });
        container.addComponent (secondbutton);
    }
}]]></programlisting>

		<para>
			Other techniques for separating between different sources also exist. They include
			using object properties, names, or captions to separate between
			them. Using captions or any other visible text is generally
			discouraged, as it may create problems for
			internationalization. Using other symbolic strings can also be
			dangerous, because the syntax of such strings is checked only
			runtime.
		</para>

		<para>
			Events are usually emitted by the framework, but applications may need to emit
			them too in some situations, such as when updating some part of the UI is
			required. Events can be emitted programmatically using the
			<methodname>fireEvent(Component.Event)</methodname> method of
			<classname>AbstractComponent</classname>. The event is then relayed to all the
			listeners of the particular event class for the object. Some components have a
			default event type, for example, a <classname>Button</classname> has a nested
			<classname>Button.ClickEvent</classname> class and a corresponding
			<classname>Button.ClickListener</classname> interface. These events can be
			triggered with <methodname>fireComponentEvent()</methodname>.
		</para>
    </section>

	<section xml:id="application.resources">
		<title>Referencing Resources</title>

		<para>
			Web applications work over the web and have various resources, such
			as images or downloadable files, that the web browser has to get from
			the server. These resources are typically used in
			<classname>Embedded</classname> (images) or
			<classname>Link</classname> (downloadable files) user interface
			components. Various components, such as
			<classname>TabSheet</classname>, can also include icons, which are
			also handled as resources.
		</para>

		<para>
			A web server can handle many of such requests for static resources without
			having to ask them from the application, or the
			<classname>Application</classname> object can provide them. For dynamic
			resources, the user application must be able to create them
			dynamically. Vaadin provides resource request interfaces for applications so
			that they can return various kinds of resources, such as files or dynamically
			created resources. These include the <classname>StreamResource</classname>
			class and the <interfacename>RequestHandler</interfacename> described in <xref
			linkend="advanced.requesthandler"/>.
		</para>

		<para>
			Vaadin provides also low-level facilities for retrieving the
			URI and other parameters of a HTTP request. We will first look into
			how applications can provide various kinds of resources and then look
			into low-level interfaces for handling URIs and parameters to provide
			resources and functionalities.
		</para>

		<para>
			Notice that using request handlers to create "pages" is not meaningful in
			Vaadin or in AJAX applications generally. Please see <xref
			linkend="architecture.technology.ajax"/> for a detailed explanation.
		</para>

		<section xml:id="application.resources.api">
			<title>Resource Interfaces and Classes</title>
		
			<para>
				Vaadin has two interfaces for resources: a generic
				<classname>Resource</classname> interface and a more specific
				<classname>ApplicationResource</classname> interface for resources
				provided by the application.
			</para>

			<figure xml:id="figure.resource.classdiagram">
				<title>Resource Interface and Class Diagram</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/resource_classdiagram-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/application/resource_classdiagram-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				<classname>ApplicationResource</classname> resources are managed
				by the <classname>Application</classname> class. When you create
				such a resource, you give the application object to the
				constructor. The constructor registers the resource in the
				application using the <classname>addResource</classname>
				method.
			</para>

			<para>
				<classname>Application</classname> manages requests for the
				resources and allows accessing resources using a URI. The URI
				consists of the base name of the application and a relative name
				of the resource. The relative name is
				<literal>"APP/"+resourceid+"/"+filename</literal>, for example
				<literal>"APP/1/myimage.png"</literal>. The
				<varname>resourceid</varname> is a generated numeric identifier
				to make resources unique, and <varname>filename</varname> is the
				file name of the resource given in the constructor of its
				class. However, the application using a resource does not usually
				need to consider its URI. It only needs to give the resource to
				an appropriate <classname>Embedded</classname> or
				<classname>Link</classname> or some other user interface
				component, which manages the rendering of the URI.
			</para>
		</section>

		<section>
			<title>File Resources</title>

			<para>
				File resources are files stored anywhere in the file system. The
				use of file resources generally falls into two main categories:
				downloadable files and embedded images.
			</para>

			<para>
				A file object that can be accessed as a file resource is defined with the
				standard <classname>java.io.File</classname> class. You can create the
				file either with an absolute or relative path, but the base path of the
				relative path depends on the installation of the web server. For example,
				in Apache Tomcat, the default current directory is the installation path of
				Tomcat.
			</para>

			<!-- programlisting><![CDATA[]]></programlisting -->
		</section>

		<section>
			<title>Class Loader Resources</title>

			<para>
				The <classname>ClassResource</classname> allows resources to be loaded
				from the deployed package of the application using Java Class Loader. <!-- If you
				are using Eclipse, you just need to import the resources, such as images,
				under a package. --> The one-line example below loads an image resource from
				the application package and displays it in an
				<classname>Embedded</classname> component.
			</para>

			<programlisting><?pocket-size 80% ?><![CDATA[mainwindow.addComponent(new Embedded ("",
        new ClassResource("smiley.jpg",
                  mainwindow.getApplication())));]]></programlisting>
		</section>

		<section xml:id="application.resources.theme">
			<title>Theme Resources</title>

			<para>
				Theme resources of <classname>ThemeResource</classname> class are files,
				typically images, included in a theme. A theme is located with path
				<filename>VAADIN/themes/themename</filename> in a web application. Name of
				a theme resource is given as the parameter for the constructor, with a
				path relative to the theme folder.
			</para>

            <book-example id="application.resources.themeresource" style="float: right"></book-example>
<programlisting><?pocket-size 65% ?><![CDATA[// A theme resource in the current theme ("book-examples")
// Located in: VAADIN/themes/book-examples/img/themeimage.png
ThemeResource resource = new ThemeResource("img/themeimage.png");

// Use the resource
Embedded image = new Embedded("My Theme Image", resource);]]></programlisting>

            <para>
                The result is shown in <xref
                linkend="figure.application.resources.theme"/>, illustrating also the
                folder structure for the theme resource file in an Eclipse project.
            </para>

			<figure xml:id="figure.application.resources.theme">
				<title>Theme Resources</title>
				<mediaobject>
					<imageobject>
						<imagedata scale="70" smallscale="70%" align="center" fileref="img/application/resource-themeimage.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                To use theme resources, you must set the theme for the application. See
                <xref linkend="themes"/> for more information regarding themes.
            </para>
		</section>

		<section xml:id="application.resources.stream">
			<title>Stream Resources</title>
		
			<para>
				Stream resources are application resources that allow creating
				dynamic resource content. Charts are typical examples of dynamic
				images. To define a stream resource, you need to implement the
				<classname>StreamResource.StreamSource</classname> interface and
				its <methodname>getStream</methodname> method. The method needs
				to return an <classname>InputStream</classname> from which the
				stream can be read.
			</para>

			<para>
				The following example demonstrates the creation of a simple
				image in PNG image format. 
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[import java.awt.image.*;

public class MyImageSource
             implements StreamResource.StreamSource {
    ByteArrayOutputStream imagebuffer = null;
    int reloads = 0;
    
    /* We need to implement this method that returns
     * the resource as a stream. */
    public InputStream getStream () {
        /* Create an image and draw something on it. */
        BufferedImage image = new BufferedImage (200, 200,
                               BufferedImage.TYPE_INT_RGB);
        Graphics drawable = image.getGraphics();
        drawable.setColor(Color.lightGray);
        drawable.fillRect(0,0,200,200);
        drawable.setColor(Color.yellow);
        drawable.fillOval(25,25,150,150);
        drawable.setColor(Color.blue);
        drawable.drawRect(0,0,199,199);
        drawable.setColor(Color.black);
        drawable.drawString("Reloads="+reloads, 75, 100);
        reloads++;

        try {
            /* Write the image to a buffer. */
            imagebuffer = new ByteArrayOutputStream();
            ImageIO.write(image, "png", imagebuffer);
            
            /* Return a stream from the buffer. */
            return new ByteArrayInputStream(
                         imagebuffer.toByteArray());
        } catch (IOException e) {
            return null;
        }
    }
}]]></programlisting>

			<para>
				The content of the generated image is dynamic, as it updates the
				reloads counter with every call. The
				<classname>ImageIO</classname>.<methodname>write()</methodname>
				method writes the image to an output stream, while we had to
				return an input stream, so we stored the image contents to a
				temporary buffer.
			</para>

			<para>
				You can use resources in various ways. Some user interface components, such as
				<classname>Link</classname> and <classname>Embedded</classname>,
				take their parameters as a resource.
			</para>

			<para>
				Below we display the image with the
				<classname>Embedded</classname> component.  The
				<classname>StreamResource</classname> constructor gets a
				reference to the application and registers itself in the
				application's resources. Assume that <varname>main</varname> is a
				reference to the main window and <varname>this</varname> is the
				application object.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create an instance of our stream source.
StreamResource.StreamSource imagesource = new MyImageSource ();
	
// Create a resource that uses the stream source and give it a name.
// The constructor will automatically register the resource in
// the application.
StreamResource imageresource =
        new StreamResource(imagesource, "myimage.png", this);
	
// Create an embedded component that gets its contents
// from the resource.
main.addComponent(new Embedded("Image title", imageresource));]]></programlisting>

			<para>
				The image will look as follows:
			</para>

			<figure xml:id="figure.resource.streamresource">
				<title>Screenshot of the stream resource example with an embedded image</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/application_streamresource.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="80%" align="center" fileref="img/application/application_streamresource.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				We named the resource as <filename>myimage.png</filename>. The
				application adds a resource key to the file name of the resource
				to make it unique.  The full URI will be like
				<uri>http://localhost:8080/testbench/APP/1/myimage.png</uri>. The
				end <uri>APP/1/myimage.png</uri> is the
				<emphasis>relative</emphasis> part of the URI. You can get the
				relative part of a resource's URI from the application with
				<methodname>Application.getRelativeLocation()</methodname>.
			</para>

			<para>
				Another way to create dynamic content is a request handler, described in
				<xref linkend="advanced.requesthandler"/>.
			</para>
		</section>
	</section>

	<!-- section>
		<title>Application Life-Cycle</title>
		<para>
		</para>
	</section -->

    <!-- TODO Vaadin 7: Verify and re-enable if possible -->
    <!--
	<section xml:id="application.close">
		<title>Shutting Down an Application</title>

		<para>
			A user can log out or close the web page or browser, so a session and the
			associated application instance can end. Ending an application can be
			initiated by the application logic. Otherwise, it will be ended automatically
			when the Servlet session times out.
		</para>

		<section>
			<title>Closing an Application</title>

			<para>
				If the user quits the application through the user interface, an event handler
				should call the <methodname>close()</methodname> method in the
				<classname>Application</classname> class to shutdown the session.
			</para>

			<para>
				In the following example, we have a <guibutton>Logout</guibutton> button,
				which ends the user session.
			</para>

			<programlisting><![CDATA[Button closeButton = new Button("Logout");

closeButton.addListener(new Button.ClickListener() {
    @Override
    public void buttonClick(ClickEvent event) {
        getMainWindow().getApplication().close();
    } 
});

main.addComponent(closeButton);]]></programlisting>

			<para>
				You will soon notice that closing the application simply reloads the
				application with a new <classname>Application</classname> instance. You
				can set the window to redirect to a different URL (that does not reload
				the application) with <methodname>setLogoutURL</methodname>. In your
				application class, write:
			</para>

			<programlisting><![CDATA[setLogoutURL("/logout.html");]]></programlisting>

		</section>
        -->
        <!-- TODO: Update if #2752 is fixed. -->

        <!--
		<section>
			<title>Handling the Closing of a Window</title>

			<para>
				Closing the main window (or all application-level windows) does not close
				session and the application instance will be left hanging. You need to
				program such behaviour by handling the close events of the windows.
			</para>

			<para>
				If the user closes a browser window, such as the main window or any other
				application-level window, the window will send a final AJAX request to the
				server, which will fire a <classname>Window.CloseEvent</classname> for the
				closed window. You can handle the event with a
				<classname>Window.CloseListener</classname>. In case the user closes the
				browser, the event is fired for every open window.
			</para>

			<programlisting><![CDATA[// Close the application if the main window is closed.
main.addListener(new Window.CloseListener(){
   @Override
    public void windowClose(CloseEvent e) {
       System.out.println("Closing the application");
       getMainWindow().getApplication().close();
    } 
});]]></programlisting>

			<para>
				Notice that <emphasis>refreshing a window means closing and reopening
				it</emphasis>. Therefore, if you have a close handler as above, the user
				loses the possibility to refresh the browser window.
			</para>

			<para>
				In the likely case that the browser crashes, no close event is communicated to
				the server. As the server has no way of knowing about the problem, and the
				session will be left hanging until the session timeout expires. During this
				time, the user can restart the browser, open the application URL, and the main
				window will be rendered where the user left off. This can be desired behaviour
				in many cases, but sometimes it is not and can create a security problem.
			</para>
		</section>
	</section> -->
	
	<section xml:id="application.errors">
		<title>Handling Errors</title>

		<section xml:id="application.errors.error-indicator">
			<title>Error Indicator and message</title>

			<para>
				All components have a built-in error indicator that can be set explicitly
				with <methodname>setComponentError()</methodname> or can be turned on
				implicitly if validating the component fails. As with component caption,
				the placement of the indicator is managed by the layout in which the
				component is contained. Usually, the error indicator is placed right of
				the caption text. Hovering the mouse pointer over the field displays the
				error message.
			</para>

			<para>
				The following example shows how you can set the component error
				explicitly. The example essentially validates field value without using an
				actual validator.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create a field.
final TextField textfield = new TextField("Enter code");
main.addComponent(textfield);

// Let the component error be initially clear.
textfield.setComponentError(null); // (actually the default)

// Have a button right of the field (and align it properly).
final Button button = new Button("Ok!");
main.addComponent(button);
((VerticalLayout)main.getLayout())
        .setComponentAlignment(button, Alignment.BOTTOM_LEFT);

// Handle button clicks
button.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        // If the field value is bad, set its error.
        // (Allow only alphanumeric characters.)
        if (! ((String) textfield.getValue()).matches("^\\w*$")) {
            // Put the component in error state and
            // set the error message.
            textfield.setComponentError(
                new UserError("Must be letters and numbers"));
        } else {
            // Otherwise clear it.
            textfield.setComponentError(null);
        }
    }
});]]></programlisting>

			<figure xml:id="figure.error-indicator.example1">
				<title>Error indicator active</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/errorindicator-example2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="80%" align="center" fileref="img/application/errorindicator-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <!-- TODO Vaadin 7: Is there anything to say about errors in forms? -->
		</section>

		<section xml:id="application.errors.systemmessages">
			<title>Customizing System Messages</title>

            <para>
                System messages are notifications that indicate a major invalid state in
                an application that usually requires restarting the application. Session
                timeout is perhaps the most typical such state.
            </para>

            <para>
                System messages are strings managed in
                <classname>SystemMessages</classname> class.
            </para>

            <variablelist>
                <varlistentry>
                    <term>sessionExpired</term>
                    <listitem>
                        <para>
                            Application servlet session expired. A session expires if no
                            server requests are made during the session timeout
                            period. The session timeout can be configured with the
                            <parameter>session-timeout</parameter> parameter in
                            <filename>web.xml</filename>, as described in <xref
                            linkend="application.environment.web-xml"/>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>communicationErrorURL</term>
                    <listitem>
                        <para>
                            An unspecified communication problem between the Vaadin
                            Client-Side Engine and the application server. The server may
                            be unavailable or there is some other problem.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>authenticationError</term>
                    <listitem>
                        <para>
                            This error occurs if 401 (Unauthorized) response to a request
                            is received from the server.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>internalError</term>
                    <listitem>
                        <para>
                            A serious internal problem, possibly indicating a bug in
                            Vaadin Client-Side Engine or in some custom client-side code.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>outOfSync</term>
                    <listitem>
                        <para>
                            The client-side state is invalid with respect to server-side
                            state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>cookiesDisabled</term>
                    <listitem>
                        <para>
                            Informs the user that cookies are disabled in the browser and
                            the application does not work without them.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Each message has four properties: a short caption, the actual message, a
                URL to which to redirect after displaying the message, and property
                indicating whether the notification is enabled.
            </para>

            <para>
                Additional details may be written (in English) to the debug console window
                described in <xref linkend="advanced.debug-production-modes"/>.
            </para>

            <para>
                You can override the default system messages by implementing the
                <methodname>getSystemMessages()</methodname> method in the application
                class. The method should return a
                <classname>Application.SystemMessages</classname> object. The easiest way
                to customize the messages is to use a
                <classname>CustomizedSystemMessages</classname> object as follows:
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Override the default implementation
public static SystemMessages getSystemMessages() {
    CustomizedSystemMessages messages =
            new CustomizedSystemMessages();
    messages.setSessionExpiredCaption("Ohno, session expired!");
    messages.setSessionExpiredMessage("Don't idle!");
    messages.setSessionExpiredNotificationEnabled(true);
    messages.setSessionExpiredURL("http://vaadin.com/");
    return messages;
}]]></programlisting>

            <para>
                Notice that the special <methodname>getSystemMessages()</methodname>
                method is not defined in an interface nor does it exist in the
                <classname>Application</classname> superclass.
            </para>
        </section>
		
		<section xml:id="application.errors.unchecked-exceptions">
			<title>Handling Uncaught Exceptions </title>

			<para>
				Application development with Vaadin follows the event-driven programming
				model. Mouse and keyboard events in the client cause (usually
				higher-level) events on the server-side, which can be handled with
				listeners, and that is how most of the application logic works. Handling
				the events can result in exceptions either in the application logic or in
				the framework itself, but some of them may not be caught properly.
            </para>

            <para>
                For example, in the following code excerpt, we throw an error in an event
                listener but do not catch it, so it falls to the framework.
            </para>

            <programlisting><?pocket-size 70% ?><![CDATA[final Button button = new Button ("Fail Me");

button.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        // Throw some exception.
        throw new RuntimeException("You can't catch this.");
    }
});]]></programlisting>

			<para>
                Any such exceptions that occur in the call chain, but are not caught at
                any other level, are eventually caught by the terminal adapter in
                <classname>ApplicationServlet</classname>, the lowest-level component that
                receives client requests. The terminal adapter passes all such caught
                exceptions as events to the error listener of the
                <classname>Application</classname> instance through the
                <classname>Terminal.ErrorListener</classname> interface. The
                <classname>Application</classname> class does not, by default, throw such
                exceptions forward.
			</para>

            <para>
                The reason for this error-handling logic lies in the logic that handles
                component state synchronization between the client and the server. We want
                to handle <emphasis>all</emphasis> the serialized variable changes in the
                client request, because otherwise the client-side and server-side
                component states would become unsynchronized very easily, which could put
                the entire application in an invalid state.
            </para>
			
			<para>
				The default implementation of the
				<classname>Terminal.ErrorListener</classname> interface in the
				<classname>Application</classname> class simply prints the error to
				console. It also tries to find out a component related to the error. If
				the exception occurred in a listener attached to a component, that
				component is considered as the component related to the exception. If a
				related component is found, the error handler sets the <emphasis>component
				error</emphasis> for it, the same attribute which you can set with
				<methodname>setComponentError()</methodname>.
			</para>

            <para>
                In UI, the component error is shown with a small red "!" -sign (in the
                default theme). If you hover the mouse pointer over it, you will see the
                entire backtrace of the exception in a large tooltip box, as illustrated
                in <xref linkend="figure.application.errors.unchecked-exceptions"/> for
                the above code example.
            </para>

			<figure xml:id="figure.application.errors.unchecked-exceptions">
				<title>Uncaught Exception in Component Error Indicator</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/errorindicator-exception.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/application/errorindicator-exception.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can change the logic of handling the terminal errors easily by
				overriding the <methodname>terminalError()</methodname> method in your
				application class (the one that inherits
				<classname>Application</classname>) or by setting a custom error listener
				with the <methodname>setErrorHandler</methodname> method. You can safely
				discard the default handling or extend its usage with your custom error
				handling or logging system. In the example code below, the exceptions are
				also reported as notifications in the main window.
			</para>
			
			<programlisting><?pocket-size 75% ?><![CDATA[@Override
public void terminalError(Terminal.ErrorEvent event) {
    // Call the default implementation.
    super.terminalError(event);

    // Some custom behaviour.
    new Notification(
        "An unchecked exception occured!",
        event.getThrowable().toString(),
        Notification.TYPE_ERROR_MESSAGE)
            .show(Page.getCurrent());
}]]></programlisting>

			<para>
				Handling other exceptions works in the usual way for Java
				Servlets. Uncaught exceptions are finally caught and handled by the
				application server.
			</para>

		</section>
	</section>

    <section xml:id="application.notifications">
        <title>Notifications</title>

        <para>
            Notifications are error or information boxes that appear briefly, typically at
            the center of the screen. A notification box has a caption and an optional
            description and icon. The box stays on the screen either for a preset time or
            until the user clicks it. The notification type defines the default appearance
            and behaviour of a notification.
        </para>

        <para>
            There are two ways to create a notification. The easiest is to use a static
            shorthand <methodname>Notification.show()</methodname> method, which takes the
            caption of the notification as a parameter and displays it in the current
            page.
        </para>

        <programlisting><![CDATA[Notification.show("This is a warning");]]></programlisting>

        <figure xml:id="figure.notification.example1">
            <title>Notification</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/application/notification-example2.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="70" smallscale="100%" align="center" fileref="img/application/notification-example2.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            For more control, you can create a <classname>Notification</classname>
            object. Different constructors exist for taking just the caption, or also
            the description, notification type, and whether HTML is allowed or
            not. Notifications are shown in a <classname>Page</classname>, typically
            the current page.
        </para>

        <programlisting><![CDATA[new Notification("This is a warning",
    "<br/>This is the <i>last</i> warning",
    Notification.TYPE_WARNING_MESSAGE, true)
    .show(Page.getCurrent());]]></programlisting>

        <para>
            The caption and description are by default written on the same line. If you
            want to have a line break between them, use the XHTML line break markup
            "<literal>&lt;br/&gt;</literal>" if HTML is enabled, or
            "<literal>\n</literal>" if not. When HTML is enabled (it is by default), you
            can use any XHTML markup in the caption and description of a notification. If
            it is possible to get the notification content from user input, you should
            either disallow HTML with
            <methodname>setHtmlContentAllowed(false)</methodname> or sanitize the content
            carefully, as noted in <xref linkend="advanced.security.sanitizing"/>.
        </para>

        <figure xml:id="figure.notification.example2">
            <title>Notification with HTML Formatting</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/application/notification-example3.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="70" smallscale="130" align="center" fileref="img/application/notification-example3.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <section xml:id="application.notifications.type">
            <title>Notification Type</title>

            <para>
                The notification type defines the overall default style and behaviour of a
                notification. If no notification type is given, the "humanized" type is
                used as the default. The notification types, listed below, are defined in
                the <classname>Notification</classname> class.
            </para>
                
            <variablelist>
                <varlistentry>
                    <term>
                        <parameter>TYPE_HUMANIZED_MESSAGE</parameter>
                        <inlinemediaobject>
                            <imageobject role="html">
                                <imagedata align="center" fileref="img/application/notification-humanized.png"/>
                                </imageobject>
                            <imageobject role="fo">
                                <imagedata scale="70" align="center" fileref="img/application/notification-humanized.png"/>
                            </imageobject>
                        </inlinemediaobject>
                    </term>
                    <listitem>
                        <para>
                            A user-friendly message that does not annoy too much: it does
                            not require confirmation by clicking and disappears
                            quickly. It is centered and has a neutral gray color.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>TYPE_WARNING_MESSAGE</parameter>
                        <inlinemediaobject>
                            <imageobject role="html">
                                <imagedata align="center" fileref="img/application/notification-warning.png"/>
                            </imageobject>
                            <imageobject role="fo">
                                <imagedata scale="70" align="center" fileref="img/application/notification-warning.png"/>
                            </imageobject>
                        </inlinemediaobject>
                    </term>
                    <listitem>
                        <para>
                            Warnings are messages of medium importance. They are displayed
                            with colors that are neither neutral nor too distractive. A
                            warning is displayed for 1.5 seconds, but the user can click
                            the message box to dismiss it. The user can continue to
                            interact with the application while the warning is displayed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>TYPE_ERROR_MESSAGE</parameter>
                        <inlinemediaobject>
                            <imageobject role="html">
                                <imagedata align="center" fileref="img/application/notification-error.png"/>
                            </imageobject>
                            <imageobject role="fo">
                                <imagedata scale="70" align="center" fileref="img/application/notification-error.png"/>
                            </imageobject>
                        </inlinemediaobject>
                    </term>
                    <listitem>
                        <para>
                            Error messages are notifications that require the highest user
                            attention, with alert colors and by requiring the user to
                            click the message to dismiss it. The error message box does
                            not itself include an instruction to click the message,
                            although the close box in the upper right corner indicates it
                            visually. Unlike with other notifications, the user can not
                            interact with the application while the error message is
                            displayed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>TYPE_TRAY_NOTIFICATION</parameter>
                        <inlinemediaobject>
                            <imageobject role="html">
                                <imagedata align="center" fileref="img/application/notification-tray.png"/>
                            </imageobject>
                            <imageobject role="fo">
                                <imagedata scale="70" align="center" fileref="img/application/notification-tray.png"/>
                            </imageobject>
                        </inlinemediaobject>
                    </term>
                    <listitem>
                        <para>
                            Tray notifications are displayed in the "system tray" area,
                            that is, in the lower-right corner of the browser view. As
                            they do not usually obsure any user interface, they are
                            displayed longer than humanized or warning messages, 3 seconds
                            by default. The user can continue to interact with the
                            application normally while the tray notification is displayed.
                        </para>
                        </listitem>
                </varlistentry>
            </variablelist>
        </section>
        
        <section xml:id="application.notifications.customization">
            <title>Customizing Notifications</title>
            
            <para>
                All of the features of specific notification types can be controlled with
                the <classname>Notification</classname> properties. Once configured, you
                need to show it in the current page.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Notification with default settings for a warning
Notification notif = new Notification(
    "Warning",
    "<br/>Area of reindeer husbandry",
    Notification.TYPE_WARNING_MESSAGE);

// Customize it
notif.setDelayMsec(20000);
notif.setPosition(Notification.POSITION_BOTTOM_RIGHT);
notif.setStyleName("mystyle");
notif.setIcon(new ThemeResource("img/reindeer.png"));
                
// Show it in the page
notif.show(Page.getCurrent());]]></programlisting>

            <para>
                The <methodname>setPosition()</methodname> method allows setting the
                positioning of the notification. The method takes as its parameter any of
                the constants:
            </para>

            <informaltable frame="none">
                <tgroup cols="1" align="left">
                    <tbody>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_CENTERED</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_CENTERED_TOP</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_CENTERED_BOTTOM</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_TOP_LEFT</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_TOP_RIGHT</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_BOTTOM_LEFT</parameter></entry></row>
                        <row valign="top" rowsep="0"><entry colsep="0"><parameter>Notification.POSITION_BOTTOM_RIGHT</parameter></entry></row>
                    </tbody>
                </tgroup>
            </informaltable>

            <para>
                The <methodname>setDelayMSec()</methodname> allows you to set the time in
                milliseconds for how long the notification is displayed. Parameter value
                <literal>-1</literal> means that the message is displayed until the user
                clicks the message box. It also prevents interaction with other parts of
                the application window, as is default behaviour for error messages. It
                does not, however, add a close box that the error notification has.
            </para>
        </section>

        <section xml:id="application.notifications.css">
            <title>Styling with CSS</title>

            <programlisting><?pocket-size 65% ?><![CDATA[.v-Notification {}
  .popupContent {}
    .gwt-HTML {}
      h1 {}
      p  {}]]></programlisting>

            <para>
                The notification box is a floating <literal>div</literal> element under
                the <literal>body</literal> element of the page. It has an overall
                <literal>v-Notification</literal> style. The content is wrapped inside an
                element with <literal>popupContent</literal> style. The caption is
                enclosed within an <literal>h1</literal> element and the description in a
                <literal>p</literal> element.
            </para>

            <para>
                To customize it, add a style for the <classname>Notification</classname>
                object with <methodname>setStyleName("mystyle")</methodname>, and make the
                settings in the theme, for example as follows:
            </para>

            <programlisting><![CDATA[.v-Notification.mystyle {
    background: #FFFF00;
    border: 10px solid #C00000;
    color: black;
}]]></programlisting>

            <para>
                The result is shown, with the icon set earlier in the customization
                example, in <xref
                    linkend="figure.application.errors.notifications.css"/>.
            </para>

            <figure xml:id="figure.application.errors.notifications.css">
                <title>Styled Notification</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/notification-customization.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="130" align="center" fileref="img/application/notification-customization.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </section>

	<section xml:id="application.environment">
		<title>Setting Up the Application Environment</title>
		
		<para>
			Vaadin applications are deployed as <emphasis>Java web
			applications</emphasis>. A Java "web application" can contain a number of
			servlets, each of which can be a Vaadin application or some other servlet, and
			static resources such as HTML files. Such a web application is normally
			packaged as WAR (Web application ARchive) file, which can be deployed to a
			Java application server (or a servlet container to be exact).
        </para>

        <para>
            For a detailed tutorial on how web applications are packaged, please refer to
            any Java book that discusses Java Servlets. Sun has an excellent reference
            online at
			<link
				xlink:href="http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html">
				http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html
			</link>.
        </para>

        <para>
            Remember that, in the Java Servlet parlance, "web application" means a
            collection of Java servlets or portlets, JSP and static HTML pages, and
            various other resources that form an application. Such a Java web application
            is typically packaged as a WAR package for deployment. Vaadin applications, on
            the other hand, run as servlets within such a Java web application. There
            exists also other kinds of web applications. To avoid confusion with the
            general meaning of "web application", we often refer to Java web application
            as "WAR" in this book.

            <!-- TODO Vaadin 7: What is the relationship between servlet and application? -->
		</para>
		
		<section xml:id="application.environment.war-eclipse">
			<title>Creating Deployable WAR in Eclipse</title>

			<para>
				To deploy an application to a web server, you need to create a WAR
				package. Here we give the instructions for Eclipse.
			</para>

            <orderedlist>
                <listitem>
                    <para>
                        Select
                        <menuchoice><guimenu>File</guimenu><guimenuitem>Export</guimenuitem></menuchoice>
                        and then <menuchoice><guimenu>Web</guimenu><guimenuitem>WAR
                        File</guimenuitem></menuchoice>. Or, right-click the project in
                        the Project Explorer and select
                        <menuchoice><guimenu>Web</guimenu><guimenuitem>WAR
                        File</guimenuitem></menuchoice>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Select the <guilabel>Web project</guilabel> to export. Enter
                        <guilabel>Destination</guilabel> file name
                        (<filename>.war</filename>).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Make any other settings in the dialog, and click
                        <guibutton>Finish</guibutton>.
                    </para>
                </listitem>
            </orderedlist>
		</section>
		
		<section xml:id="application.environment.war">
			<title>Web Application Contents</title>

			<para>
				The following files are required in a web application in order to
				run it.
			</para>

			<variablelist>
				<title>Web application organization</title>

				<varlistentry>
					<term>
						<filename>WEB-INF/web.xml</filename>
					</term>
					<listitem>
						<para>
							This is the standard web application
							descriptor that defines how the
							application is organized. You can refer
							to any Java book about the contents of
							this file. Also see an example in
							<xref linkend="ex.web.xml" />.
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>
						<filename>
							WEB-INF/lib/vaadin-7.x.x.jar
						</filename>
					</term>
					<listitem>
						<para>
							This is the Vaadin library. It
							is included in the product package in
							<filename>lib</filename>
							directory.
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>Your application classes</term>
					<listitem>
						<para>
							You must include your application
							classes either in a JAR file in
							<filename>WEB-INF/lib</filename>
							or as classes in
							<filename>WEB-INF/classes</filename>
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>Your own theme files (OPTIONAL)</term>
					<listitem>
						<para>
							If your application uses a special theme
							(look and feel), you must include it in
							<filename>VAADIN/themes/themename</filename>
							directory.
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>Widget sets (OPTIONAL)</term>
					<listitem>
						<para>
							If your application uses a project-specific widget set, it
							must be compiled in the
							<filename>VAADIN/widgetset/</filename> directory.
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>

		<section xml:id="application.environment.web-xml">
			<title>Deployment Descriptor <filename>web.xml</filename></title>

			<para>
				The deployment descriptor is an XML file with the name
				<filename>web.xml</filename> in the <filename>WEB-INF</filename> directory
				of a web application. It is a standard component in Java EE describing how
				a web application should be deployed. The structure of the deployment
				descriptor is illustrated by the following example. You simply deploy
				applications as servlets implemented by the special
				<methodname>com.vaadin.terminal.gwt.server.ApplicationServlet</methodname>
				wrapper class.
            </para>

            <para>
                If your application has a single &root;, you simply specify the &root;
                class by giving the <parameter>&root;</parameter> parameter with the name
                of the specific root class for the servlet. The servlet is then connected
                to a URL in a standard way for Java Servlets.
			</para>

			<example xml:id="ex.web.xml">
				<title>web.xml</title>
				<programlisting><?pocket-size 75% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;web-app
  id="WebApp_ID" version="2.4"
  xmlns="http://java.sun.com/xml/ns/j2ee" 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
     http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;

  &lt;servlet&gt;
    &lt;servlet-name&gt;<emphasis role="strong">myservlet</emphasis>&lt;/servlet-name&gt;
    &lt;servlet-class&gt;
        com.vaadin.terminal.gwt.server.ApplicationServlet
    &lt;/servlet-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;&root;&lt;/param-name&gt;
      &lt;param-value&gt;<emphasis role="strong">My&rootclass;</emphasis>&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/servlet&gt;

  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;<emphasis role="strong">myservlet</emphasis>&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;
&lt;/web-app&gt;</programlisting>
			</example>

            <para>
                The descriptor defines a servlet with name <filename>myservlet</filename>.
                The servlet class,
                <classname>com.vaadin.terminal.gwt.server.ApplicationServlet</classname>,
                is provided by Vaadin framework and is normally the same for all Vaadin
                projects. For some purposes, you may need to use a custom servlet class.
            </para>

			<section>
				<title>&rootclass; or Application Class</title>

                <para>
                    The servlet can take either an application class or the &root; class
                    of an application as a parameter. A &root; class is normally given in
                    applications with a single &root; inside a page, while using an
                    application class as the entry-point allows multiple &root;s.
                </para>
                    
                <para>
                    If the <literal>&root;</literal> parameter is given, its value must be
                    the class name of the &root; class, such as
                    <classname>com.example.My&rootclass;</classname>, including the full
                    package path to the class. If the class is in the default package, the
                    package path is obviously not used.
                </para>

                <para>
                    If your application has multiple &root;s in one page, or for other
                    purposes, you can extend the <classname>Application</classname> class
                    instead of <classname>&rootclass;</classname> and define your
                    application class with the <literal>application</literal> parameter
                    for the servlet. For roots created during the execution of an
                    application, such as for displaying popup windows, you can add new
                    roots dynamically to the application instance.
                </para>
            </section>

			<section>
				<title>Servlet Mapping with URL Patterns</title>

                <para>
                    The <literal>url-pattern</literal> is defined above as
                    <literal>/*</literal>. This matches to any URL under the project
                    context. We defined above the project context as
                    <literal>myproject</literal> so the URL for the page of the &root; will be
                    <uri>http://localhost:8080/myproject/</uri>. If the project were to have
                    multiple &root;s or servlets, they would have to be given different names
                    to distinguish them.  For example, <literal>url-pattern</literal>
                    <literal>/my&root;/*</literal> would match a URL such as
                    <uri>http://localhost:8080/myproject/my&root;/</uri>. Notice that the slash
                    and the asterisk <emphasis>must</emphasis> be included at the end of the
                    pattern.
                </para>

                <para>
                    Notice also that if the URL pattern is other than
                    <literal>/*</literal> (such as <literal>/my&root;/*</literal>), you will also
                    need to make a servlet mapping to <literal>/VAADIN/*</literal> (unless you
                    are serving it statically as noted below). For example:
                </para>

                <programlisting>    ...
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<emphasis role="strong">myservlet</emphasis>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/myurl/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;

    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;<emphasis role="strong">myservlet</emphasis>&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/VAADIN/*&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</programlisting>

                <para>
                    If you have multiple servlets, you should specify only one
                    <literal>/VAADIN/*</literal> mapping. It does not matter which servlet you
                    map the pattern to, as long as it is a Vaadin servlet.
                </para>

                <para>
                    You do not have to provide the above <literal>/VAADIN/*</literal> mapping
                    if you serve both the widget sets and (custom and default) themes
                    statically in the <filename>WebContent/VAADIN/</filename> directory. The
                    mapping simply allows serving them dynamically from the Vaadin
                    JAR. Serving them statically is recommended for production environments as
                    it is faster. If you serve the content from within the same web
                    application, you may not have the root pattern <literal>/*</literal> for
                    the Vaadin servlet, as then all the requests would be mapped to the
                    servlet.
                </para>
            </section>

			<section>
				<title>Other Deployment Parameters</title>

				<para>
					Deployment descriptor can have many parameters and options that
					control the execution of a servlet. You can find a complete
					documentation of the deployment descriptor in Java Servlet
					Specification at
					<uri>http://java.sun.com/products/servlet/</uri>.
				</para>

				<para>
					By default, Vaadin applications run in <emphasis>debug
					mode</emphasis>, which should be used during development. This enables
					various debugging features. For production use, you should have put in
					your <filename>web.xml</filename> the following parameter:
				</para>

				<programlisting><![CDATA[<context-param>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
  <description>Vaadin production mode</description>
</context-param>]]></programlisting>
				
				<para>
					The parameter and the debug and production modes are described in
					detail in <xref linkend="advanced.debug-production-modes"/>.
				</para>

				<para>
					One often needed option is the session timeout. Different servlet
					containers use varying defaults for timeouts, such as 30 minutes for
					Apache Tomcat. You can set the timeout with:
				</para>

				<programlisting><![CDATA[<session-config>
    <session-timeout>30</session-timeout>
</session-config>]]></programlisting>

                <!-- TODO Vaadin 7: How is close() detected?
				<para>
					After the timeout expires, the <methodname>close()</methodname>
					method of the <classname>Application</classname> class will be
					called. You should implement it if you wish to handle timeout
					situations.
				</para>
                -->

			</section>
		</section>
	</section>

    <section xml:id="application.architecture">
        <title>Basic Application Architecture</title>

        <para>
            Once your application grows beyond a dozen or so lines, which is actually
            quite soon, you need to start considering the application architecture. You
            are free to use any object-oriented techniques available in Java to organize
            your code in methods, classes, packages, and libraries. The overall
            architecture defines how these modules communicate together and what sort of
            dependencies they have between them. It also defines the scope of the
            application. The scope of this book, however, only gives a possibility to
            mention some of the most common architectural patterns in Vaadin applications.
        </para>

        <para>
            Vaadin framework is built on top of abstraction layers, with interfaces and
            abstract classes. Any classes can be extended by inheritance.
        </para>

        <section xml:id="application.architecture.composition">
            <title>Compositing Components</title>

            <para>
                User interfaces typically contain many user interface components in a
                layout hierarchy. Vaadin provides many layout components for laying
                contained components vertically, horizontally, in a grid, and in many
                other ways. You can extend layout components to create composite
                components.
            </para>

            <programlisting><![CDATA[class MyView extends VerticalLayout {
    TextField entry   = new TextField("Enter this");
    Label     display = new Label("See this");
    Button    click   = new Button("Click This");

    public MyView() {
        addComponent(entry);
        addComponent(display);
        addComponent(click);
        
        // Configure it a bit
        setSizeFull();
        addStyleName("myview");
    }
}

// Use it
Layout myview = new MyView();]]></programlisting>

            <para>
                While extending layouts is an easy way to make component composition, it
                is a good practice to encapsulate implementation details, such as the
                exact layout component used. Otherwise, the users of such a composite
                could begin to rely on such implementation details, which would make
                changes harder. For this purpose, Vaadin has a special
                <classname>CustomComponent</classname> wrapper, which hides the content
                representation.
            </para>

            <programlisting><![CDATA[
class MyView extends CustomComponent {
    TextField entry   = new TextField("Enter this");
    Label     display = new Label("See this");
    Button    click   = new Button("Click This");

    public MyView() {
        Layout layout = new VerticalLayout();
        
        layout.addComponent(entry);
        layout.addComponent(display);
        layout.addComponent(click);
        
        setCompositionRoot(layout);
        
        setSizeFull();
    }
}

// Use it
MyView myview = new MyView();]]></programlisting>

            <para>
                For more detailed information on component composition with
                <classname>CustomComponent</classname>, see <xref
                linkend="components.customcomponent"/>. The Vaadin Plugin for Eclipse also
                includes a visual editor for composite components, as described in <xref
                linkend="eclipse"/>.
            </para>
        </section>

        <section xml:id="application.architecture.layering">
            <title>Layered Architectures</title>

            <para>
                Layered architectures, where each layer has a clearly distinct
                responsibility, are probably the most common architectures. Typically,
                applications follow at least a three-layer architecture:
            </para>

            <itemizedlist>
                <listitem>User interface layer</listitem>
                <listitem>Domain layer</listitem>
                <listitem>Data store layer</listitem>
            </itemizedlist>

            <para>
                Such an architecture starts from a <emphasis>domain model</emphasis>,
                which defines the data model and the "business logic" of the application,
                typically as POJOs. A user interface is built on top of the domain model,
                in our context with the Vaadin Framework. The Vaadin user interface could
                be bound directly to the data model through the Vaadin Data Model,
                described in <xref linkend="datamodel"/>. Beneath the domain model lies a
                data store, such as a relational database. The dependencies between the
                layers are restricted so that a higher layer may depend on a lower one,
                but never the other way around.
            </para>

            <para>
                An <emphasis>application layer</emphasis> (or <emphasis>service
                layer</emphasis>) is often distinguished from the domain layer, offering
                the domain logic as a service, which can be used by the user interface
                layer, as well as for other uses. In Java EE development, Enterprise
                JavaBeans (EJBs) are typically used for building this layer.
            </para>

            <para>
                An <emphasis>infrastructure layer</emphasis> is often distinguished from
                the data store layer, with a purpose to abstract the data store. For
                example, it could involve a persistence solution such as JPA and an EJB
                container. This layer becomes relevant with Vaadin when binding Vaadin
                components to data with the JPAContainer, as described in <xref
                linkend="jpacontainer"/>.
            </para>
        </section>

        <!-- TODO: Scrap or rap... (...)
        <section xml:id="application.architecture.mvc">
            <title>Model-View-Controller</title>

            <para>
                Notice that Vaadin components are views by themselves, but at a different
                level. You can bind a controller to them as an event listener. The
                components can also be bound directly to the data model. Especially, the
                <interfacename>Field</interfacename> components implement the
                <interfacename>Property.Viewer</interfacename> and
                <interfacename>Property.Editor</interfacename> interfaces for this
                purpose. See <xref linkend="datamodel"/> for more information about the
                Vaadin data model and binding.
            </para>
        </section>
        -->

        <section xml:id="application.architecture.mvp">
            <title>Model-View-Presenter</title>

            <para>
                The Model-View-Presenter (MVP) pattern is one of the most common patterns
                with Vaadin. It is similar to the older Model-View-Controller (MVC)
                pattern, which is not as meaningful in Vaadin development. Instead of an
                implementation-aware controller, there is an implementation-agnostic
                presenter that operates the view through an interface. The view does not
                interact directly with the model. This isolates the view implementation
                better than in MVC and allows easier unit testing of the presenter and
                model.
            </para>

            <figure xml:id="figure.application.architecture.mvp">
                <title>Model-View-Presenter Pattern</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/mvp-pattern-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/application/mvp-pattern-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <xref linkend="figure.application.architecture.mvp"/> illustrates the MVP
                pattern with a simple calculator. The domain model is realized in the
                <classname>Calculator</classname> class, which includes a data model and
                some model logic operations. The <classname>CalculatorViewImpl</classname>
                is a Vaadin implementation of the view, defined in the
                <interfacename>CalculatorView</interfacename> interface. The
                <classname>CalculatorPresenter</classname> handles the user interface
                logic. User interaction events received in the view are translated into
                implementation-independent events for the presenter to handle (the view
                implementation could also just call the presenter).
            </para>

            <para>
                Let us first look how the model and view are bound together by the
                presenter in the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[
// Create the model and the Vaadin view implementation
CalculatorModel    model = new CalculatorModel();
CalculatorViewImpl view  = new CalculatorViewImpl();
    
// The presenter binds the model and view together
new CalculatorPresenter(model, view);
    
// The view implementation is a Vaadin component
layout.addComponent(view);]]></programlisting>

            <para>
                You could add the view anywhere in a Vaadin application, as it is a
                composite component.
            </para>

            <section xml:id="application.architecture.mvp.model">
                <title>The Model</title>

                <para>
                    Our business model is quite simple, with one value and a number of
                    operations for manipulating it.
                </para>
    
                <programlisting><?pocket-size 65% ?><![CDATA[/** The model **/
class CalculatorModel {
    private double value = 0.0;
    
    public void clear() {
        value = 0.0;
    }

    public void add(double arg) {
        value += arg;
    }

    public void multiply(double arg) {
        value *= arg;
    }

    public void divide(double arg) {
        if (arg != 0.0)
            value /= arg;
    }
    
    public double getValue() {
        return value;
    }
    
    public void setValue(double value) {
        this.value = value;
    }
}]]></programlisting>
            </section>

            <section xml:id="application.architecture.mvp.view">
                <title>The View</title>

                <para>
                    The purpose of the view in MVP is to display data and receive user
                    interaction. It relays the user interaction to the presenter in an
                    fashion that is independent of the view implementation, that is, no
                    Vaadin events.  It is defined as a UI framework interface that can
                    have multiple implementations.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[interface CalculatorView {
    public void setDisplay(double value);

    interface CalculatorViewListener {
        void buttonClick(char operation);
    }
    public void addListener(CalculatorViewListener listener);
}]]></programlisting>

                <para>
                    The are design alternatives for the view. It could receive the
                    listener in its constructor, or it could just know the
                    presenter. Here, we forward button clicks as an
                    implementation-independent event.
                </para>

                <para>
                    As we are using Vaadin, we make a Vaadin implementation of the
                    interface as follows:
                </para>
    
                <programlisting><?pocket-size 65% ?><![CDATA[class CalculatorViewImpl extends CustomComponent
        implements CalculatorView, ClickListener {
    private Label display = new Label("0.0");

    public CalculatorViewImpl() {
        GridLayout layout  = new GridLayout(4, 5);

        // Create a result label that spans over all
        // the 4 columns in the first row
        layout.addComponent(display, 0, 0, 3, 0);
    
        // The operations for the calculator in the order
        // they appear on the screen (left to right, top
        // to bottom)
        String[] operations = new String[] {
            "7", "8", "9", "/", "4", "5", "6",
            "*", "1", "2", "3", "-", "0", "=", "C", "+" };

        // Add buttons and have them send click events
        // to this class
        for (String caption: operations)
            layout.addComponent(new Button(caption, this));

        setCompositionRoot(layout);
    }
    
    public void setDisplay(double value) {
        display.setValue(Double.toString(value));
    }

    /* Only the presenter registers one listener... */
    List<CalculatorViewListener> listeners =
            new ArrayList<CalculatorViewListener>();

    public void addListener(CalculatorViewListener listener) {
        listeners.add(listener);
    }

    /** Relay button clicks to the presenter with an
     *  implementation-independent event */
    @Override
    public void buttonClick(ClickEvent event) {
        for (CalculatorViewListener listener: listeners)
            listener.buttonClick(event.getButton()
                                 .getCaption().charAt(0));
    }
}]]></programlisting>
            </section>

            <section xml:id="application.architecture.mvp.presenter">
                <title>The Presenter</title>

                <para>
                    The presenter in MVP is a middle-man that handles all user interaction
                    logic, but in an implementation-independent way, so that it doesn't
                    actually know anything about Vaadin. It shows data in the view and
                    receives user interaction back from it.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[class CalculatorPresenter
        implements CalculatorView.CalculatorViewListener {
    CalculatorModel model;
    CalculatorView  view;

    private double current = 0.0;
    private char   lastOperationRequested = 'C';
    
    public CalculatorPresenter(CalculatorModel model,
                               CalculatorView  view) {
        this.model = model;
        this.view  = view;
        
        view.setDisplay(current);            
        view.addListener(this);
    }

    @Override
    public void buttonClick(char operation) {
        // Handle digit input
        if ('0' <= operation && operation <= '9') {
            current = current * 10
                    + Double.parseDouble("" + operation);
            view.setDisplay(current);
            return;
        }

        // Execute the previously input operation
        switch (lastOperationRequested) {
        case '+':
            model.add(current);
            break;
        case '-':
            model.add(-current);
            break;
        case '/':
            model.divide(current);
            break;
        case '*':
            model.multiply(current);
            break;
        case 'C':
            model.setValue(current);
            break;
        } // '=' is implicit

        lastOperationRequested = operation;

        current = 0.0;
        if (operation == 'C')
            model.clear();
        view.setDisplay(model.getValue());
    }
}]]></programlisting>

                <para>
                    In the above example, we held some state information in the
                    presenter. Alternatively, we could have had an intermediate controller
                    between the presenter and the model to handle the low-level button
                    logic.
                </para>
            </section>
        </section>

        <section xml:id="application.architecture.navigation">
            <title>View Navigation</title>

            <para>
                While the most simple applications have just a single
                <emphasis>view</emphasis> (or <emphasis>screen</emphasis>), perhaps most
                have many. Even in a single view, you often want to have sub-views, for
                example to display different content. <xref
                linkend="figure.application.architecture.navigation"/> illustrates a
                typical navigation between different top-level views of an application,
                and a main view with sub-views.
            </para>

            <figure xml:id="figure.application.architecture.navigation">
                <title>Navigation Between Views</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/view-navigation-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/application/view-navigation-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The <classname>Navigator</classname> described in <xref
                linkend="advanced.navigator"/> is a view manager that provides a flexible
                way to navigate between views and sub-views, while managing the URI
                fragment in the page URL to allow bookmarking, linking, and going back in
                browser history.
            </para>

            <para>
                Often Vaadin application views are part of something bigger. In such
                cases, you may need to integrate the Vaadin applications with the other
                website. You can use the embedding techniques described in <xref
                linkend="application.embedding"/>.
            </para>
        </section>

        <section xml:id="application.architecture.accessing">
            <title>Accessing &rootclass;, Page, and Application</title>
            
            <para>
                You can access the current &root;, page, and application objects from
                anywhere in the application using the static
                <methodname>getCurrent()</methodname> method in the respective
                <classname>&rootclass;</classname>, <classname>Page</classname>, and
                <classname>Application</classname> classes.
            </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Opens a sub-window
Root.getCurrent().addWindow(new Window("My Window"));

// Set the page title (window or tab caption)
Page.getCurrent().setTitle("My Page");

// Set the logout URL
Application.getCurrent().setLogoutURL(
        "http://en.wikipedia.org/wiki/Reindeer");]]></programlisting>

            <para>
                These methods use the built-in ThreadLocal support for application and &root;
                objects. The pattern is described in detail in <xref
                    linkend="advanced.global.threadlocal"/>.
            </para>
        </section>
    </section>

</chapter>
	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
