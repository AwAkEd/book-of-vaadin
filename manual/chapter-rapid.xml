<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="rapid">
	<title>Rapid Development Using Vaadin and Roo</title>

    <para>
        This chapter presents a tutorial for developing a basic application using rapid
        application development tools: Spring Roo and Vaadin Plugin for Eclipse. The
        application includes database binding with JPAContainer, internationalization, and
        testing with Vaadin TestBench.
    </para>

    <section xml:id="rapid.overview">
        <title>Overview</title>

        <para>
            In this tutorial, we develop a simple application while demonstrating also the
            basic tasks of making a typical business application:
        </para>

        <itemizedlist>
            <listitem>
                <para>Creating a business data model using Roo</para>
            </listitem>
            <listitem>
                <para>Database binding using Java Persistence API (JPA) and the JPAContainer add-on</para>
            </listitem>
            <listitem>
                <para>Creating CRUD views using the Vaadin Plugin for Spring Roo</para>
            </listitem>
            <listitem>
                <para>Customizing views using Vaadin Plugin for Eclipse</para>
            </listitem>
            <listitem>
                <para>Using the Vaadin Calendar add-on</para>
            </listitem>
            <listitem>
                <para>User login with authentication and authorization</para>
            </listitem>
            <listitem>
                <para>Internationalization</para>
            </listitem>
            <listitem>
                <para>Using the Vaadin TestBench for regression testing</para>
            </listitem>
            <listitem>
                <para>Deploying the application to Cloud Foundry</para>
            </listitem>
        </itemizedlist>

        <para>
            Spring Roo is a rapid development tool for Java applications. It generates
            code that uses the Spring Framework, Java Persistence API, and Apache
            Maven. It also allows extending its functionality using add-ons, such as the
            Vaadin Plugin for Spring Roo. The Vaadin add-on can generate user interface
            views based on the data model definitions given to Roo. These views can then
            be customized and combined with views made with the visual editor of the
            Vaadin Plugin for Eclipse.
        </para>

        <para>
             Vaadin JPAContainer is a <classname>Container</classname> that communicates
             with a JPA implementation of your choice, which in turn usually communicates
             with virtually any SQL database you choose. Then by binding the JPAContainer
             to a component such as a <classname>Table</classname> (in editable mode), you
             get a no-brainer CRUD component. As the edited table data is updated to the
             JPAContainer, which is linked to the JPA implementation, everything you do in
             the UI can immediately be reflected back to the database. JPAContainer is
             dual-licensed with the open source AGPL for free projects and CVAL for
             commercial applications.
        </para>

        <simplesect xml:id="rapid.overview.demoproject">
            <title>Demo Application</title>

            <para>
                For the purpose of this tutorial, we develop a simple business
                application. The work hour reporting application allows an employee to
                report work done for different projects.
            </para>

            <para>
                For authentication, the application will have a login screen, where the
                user can also select the language. Business tasks are done in the main
                view, which will have a typical layout with a menu bar.
            </para>
        </simplesect>
    </section>

    <section xml:id="rapid.environment">
        <title>Setting Up the Environment</title>
    
        <para>
            Let us begin with setting up the environment and creating the project. The
            tutorial requires installation of:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Spring Roo (bundled with the SpringSource Tool Suite)
                </para>
            </listitem>

            <listitem>
                <para>
                    Vaadin Plugin for Eclipse
                </para>
            </listitem>

            <listitem>
                <para>
                    Vaadin Plugin for Spring Roo
                </para>
            </listitem>

            <listitem>
                <para>
                    Vaadin Calendar Add-on
                </para>
            </listitem>

            <listitem>
                <para>
                    Vaadin TestBench Add-on
                </para>
            </listitem>
        </itemizedlist>

        <para>
            The installation of Vaadin add-ons is covered later in <xref
                linkend="rapid.addons"/> and Vaadin TestBench in <xref linkend="rapid.testing"/>.
        </para>

        <section xml:id="rapid.environment.roo">
            <title>Installing Spring Roo</title>

            <para>
                The easiest way to get Spring Roo is to install the SpringSource Tool Suite
                (STS), which is a distribution of the Eclipse IDE packaged with Roo
                integration, among other things. You can also install Spring Roo as a
                command-line tool.
            </para>

            <para>
                You can download the SpringSource Tool Suite from <link
                    xlink:href="http://www.springsource.com/developer/sts">http://www.springsource.com/developer/sts</link>. Please
                follow the installation instructions at the website. After installing, you can
                start STS by running the <filename>STS</filename> executable in the
                installation folder.
            </para>

            <para>
                You need to install the Vaadin Plugin for Eclipse in STS. Please follow the
                instructions given in <xref
                    linkend="getting-started.eclipse"/>.
            </para>
        </section>

        <section xml:id="rapid.environment.project">
            <title>Creating the Project</title>

            <para>
                You can create a new Spring Roo project as follows:
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Select
                        <menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guimenuitem>Spring
                        Roo Project</guimenuitem></menuchoice>.
                    </para>
                </listitem>

                <listitem>
                    <para>Give the project a <guilabel>Project name</guilabel>. The name
                    must be a proper identifier, that is, no spaces, etc.</para>
                </listitem>

                <listitem>
                    <para>Give the project a <guilabel>Top-level package name</guilabel>,
                    such as <literal>com.example.rapid</literal>.</para>
                </listitem>

                <listitem>
                    <para>Make any other necessary project settings. None are required in
                    this tutorial example. Finally, click <guibutton>Next</guibutton> and
                    <guibutton>Finish</guibutton> to create the project. Creating a
                    project can take a few seconds.</para>
                </listitem>
            </orderedlist>
            
            <para>
                A Roo Shell is automatically opened for a new Roo project. If closed, you
                can open a new Roo Shell by selecting
                <menuchoice><guimenu>Window</guimenu><guisubmenu>Show
                View</guisubmenu><guimenuitem>Roo Shell</guimenuitem></menuchoice>.
            </para>
        </section>

        <section xml:id="rapid.environment.rooplugin">
            <title>Installing Vaadin Plugin for Spring Roo</title>

            <para>
                Installing the Vaadin Plugin for Spring Roo is done in the Roo
                Shell. While the plugin installation is not project specific and it will
                work in all projects once installed, a Roo Shell can only be opened for an
                existing project.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        If the Roo Shell is not already open, right-click the project folder
                        in the <guilabel>Package Explorer</guilabel> and select
                        <menuchoice><guimenu>Spring Tools</guimenu><guimenuitem>Open Roo
                                Shell</guimenuitem></menuchoice>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        In the Roo Shell view enter:
                    </para>

                    <screen><?pocket-size 70% ?><prompt>roo&gt;</prompt> <command>pgp trust</command> <parameter>--keyId</parameter> 0xBF0451C0
<prompt>roo&gt;</prompt> <command>download</command> accept terms of use
<prompt>roo&gt;</prompt> <command>addon install bundle</command> <parameter>--bundleSymbolicName</parameter>
     com.vaadin.spring.roo.addon</screen>
                </listitem>
            </orderedlist>
        </section>
        
        <section xml:id="rapid.environment.datalayer">
            <title>Setting up the Roo Data Layer</title>

            <para>
                Binding application data model to a database with Java Persistence API (JPA)
                is amazingly easy with Roo. You simply need to set up persistence as follows:
            </para>

            <screen><?pocket-size 75% ?><prompt>roo&gt;</prompt> <command>persistence setup</command> <parameter>--provider</parameter> ECLIPSELINK
                       <parameter>--database</parameter> HYPERSONIC_IN_MEMORY</screen>

            <para>
                The above example sets up persistence using the EclipseLink JPA layer and an
                in-memory HSQLDB database. Hitting
                <keycombo><keycap>Ctrl</keycap><keycap>Space</keycap></keycombo> completion
                shows the possible values for the <parameter>--provider</parameter> and
                <parameter>--database</parameter> parameters.
            </para>

            <para>
                When using a real database, you need to configure the database connection in
                <filename>src/main/resources/META-INF/spring/database.properties</filename>.
            </para>
        </section>
    </section>

    <section xml:id="rapid.datamodel">
        <title>Creating the Domain Model</title>
	
        <para>
            Spring Roo automates the creation of a domain model. Using simple commands, it
            creates the entity classes and their property fields. As we enabled persistence
            for the project earlier, creating the entities also creates the JPA mappings
            between the domain objects and their underlying database representation.
        </para>

        <section xml:id="rapid.datamodel.design">
            <title>Domain Model Design</title>
        
            <para>
                The domain model of the work hour reporting system consists of three
                entities, illustrated in <xref
                linkend="figure.rapid.datamodel.entity-diagram"/>. Employees working on
                projects, who are also the users of the system, are represented as
                <classname>RapidUser</classname> entities. Authorization is managed simply
                with an <literal>admin</literal> flag.
            </para>

            <para>
                An employee uses the system to enter work entries, represented with the
                <classname>WorkEntry</classname> class. Each entry has starts and ends at a
                specific date and time and has a comment.  A work entry is always associated
                with a project, represented in the <classname>Project</classname> class. A
                project has a name and ended projects can be disabled so that they can no
                longer be selected.
            </para>

        <!--
           Diagram:

    		RapidUser
    		+username: String // min size 2
    		+password: String // min size 4
    		+admin: boolean

    		Project
    		+name // min size 2, not null
    		+enabled: boolean // default

    		WorkEntry
    		+comment: String
    		+project: Project // not null
    		+employer: RapidUser // not null
    		+startTime: Date
    		+endTime: Date
        -->		

            <figure xml:id="figure.rapid.datamodel.entity-diagram">
                <title>Entity Diagram of the Domain Model</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/rapid/domain-model-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="80%" align="center" fileref="img/rapid/domain-model-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="rapid.datamodel.creating">
            <title>Creating the Model in Roo</title>
        
            <para>
                Roo Shell helps you in creating your model objects. The
                <command>entity</command> command creates a new entity class, specified
                with the <parameter>--class</parameter> parameter. Tilde (~) can be used
                to refer to the project package. The
                <parameter>--testAutomatically</parameter> option creates integration
                tests for the entity. As always with Roo Shell, hitting CTRL-SPACE can
                hint or autocomplete your commands.
            </para>

            <screen><?pocket-size 70% ?><prompt>roo&gt;</prompt> <command>entity</command> <parameter>--class</parameter> ~.domain.RapidUser <parameter>--testAutomatically</parameter></screen>

            <para>
                The <command>field</command> command in Roo creates class properties. The
                first parameter for the command is the field type, such as
                <parameter>string</parameter>, <parameter>boolean</parameter>, or
                <parameter>date</parameter>. The name of the field is specified with the
                <parameter>--fieldName</parameter> parameter. The
                <parameter>--notNull</parameter> specifies that the field value may not be
                null. The <parameter>string</parameter> type as additional options, such as
                minimum (<parameter>--sizeMin</parameter>) and maximum
                (<parameter>--sizeMax</parameter>) length.
            </para>

            <screen><?pocket-size 70% ?><prompt>roo&gt;</prompt> <command>field string</command> <parameter>--fieldName</parameter> username <parameter>--notNull --sizeMin</parameter> 2</screen>

            <para>
                To create the domain model described earlier, the following commands need to
                be issued in all (including the ones explained above):
            </para>

            <screen><?pocket-size 65% ?>entity --class ~.domain.RapidUser --testAutomatically
field string --fieldName username --notNull --sizeMin 2
field string --fieldName password --notNull --sizeMin 4
field boolean --fieldName admin --primitive

entity --class ~.domain.Project --testAutomatically
field string --fieldName name --notNull --sizeMin 2 --sizeMax 255
field boolean --fieldName enabled --primitive

entity --class ~.domain.WorkEntry --testAutomatically
field string --fieldName comment --sizeMax 255
field reference --fieldName project --type ~.domain.Project --notNull
field reference --fieldName employee --type ~.domain.RapidUser --notNull
field date --fieldName startTime --type java.util.Date --notNull
field date --fieldName endTime --type java.util.Date --notNull</screen>

            <para>
                The <parameter>reference</parameter> field type is used for references to
                other entities. The entity type is given with the
                <parameter>--type</parameter> option.
            </para>
	
            <para>
                As we gave the <parameter>--testAutomatically</parameter> parameter when we
                created domain objects, Roo should have generated some tests automatically. To
                validate the domain model, type the following command in the Roo Shell:
            </para>

            <screen><prompt>roo&gt;</prompt> <command>perform tests</command></screen>
        </section>
    </section>

    <section xml:id="rapid.crudviews">
        <title>Creating Vaadin Application and CRUD Views</title>
    
        <para>
            Spring Roo is essentially a code generator. As already seen in the data model part
            of this tutorial, it will write a whole bunch of boiler plate code for JPA
            entities. You get an even greater advantage of Roo when you want a simple user
            interface around the domain models.
        </para>

        <para>
            By default, Spring Roo uses JSP pages (Spring MVC to be more specific) to create
            basic CRUD (Create, Remove, Update, Delete) views. This is covered in Roo's own
            tutorials. We choose a bit different route and use the Vaadin plugin for Roo to
            create an advanced Vaadin-based server-side RIA user interface for our backend.
        </para>

        <section xml:id="rapid.crudviews.skeleton">
            <title>Creating the Application Skeleton</title>

            <para>
                First, we use the <command>vaadin setup</command> command to create the basic
                application skeleton, on which we later build the user interface. Issue the
                following command in the Roo shell:
            </para>

            <screen><?pocket-size 65% ?><command>vaadin setup</command> <parameter>--applicationPackage</parameter> ~.web <parameter>--baseName</parameter> RapidWorkHours <parameter>--themeName</parameter> rapid <parameter>--useJpaContainer</parameter> true</screen>
    
            <para>
                The command creates everything that you need or might need later during
                development:
            </para>

            <orderedlist>
                <listitem>a "<package>web</package>" package where all your Vaadin related code will be added</listitem>
                <listitem>an <classname>Application</classname> class</listitem>
                <listitem>a <filename>web.xml</filename> file to configure Vaadin application for servlet containers</listitem>
                <listitem>a theme</listitem>
            </orderedlist>

            <para>
                With <parameter>--useJpaContainer true</parameter>, we instruct the application to
                use JPAContainer later when we create the CRUD views. As JPAContainer is
                lazy-loading, this will save some memory in our application server in case the
                database grows a lot.
            </para>
        </section>

        <section xml:id="rapid.crudviews.generating">
            <title>Generating CRUD Views</title>

            <para>
                Next, we create the actual CRUD views. Issue the following command in
                the Roo Shell:
            </para>

            <screen><?pocket-size 65% ?><command>vaadin generate all</command> <parameter>--package</parameter> ~.web.ui <parameter>--visuallyComposable</parameter> true</screen>

            <para>
                The command creates CRUD views for all the domain objects into
                <package>web.ui</package> package. The
                <parameter>--visuallyComposable</parameter> parameter instructs the Roo
                plugin to build views in such a way that we can later modify them with
                Vaadin Visual Designer. Without this parameter, the views are constructed
                in bit different manner, which may be bit more maintainable for advanced
                Vaadin users.
            </para>

            <para>
                In case you add new domain objects later, you may issue this command again
                to create views for new domain objects.
            </para>
        </section>
    
        <section xml:id="rapid.crudviews.devdeploy">
            <title>Deploying to Development Server</title>

            <para>
                At this point, we have a working Vaadin application ready, so we naturally
                want to see it in action. In the STS IDE, you can simply select the
                project and use <menuchoice><guimenu>Run</guimenu><guisubmenu>Run
                as</guisubmenu><guimenuitem>Run on Server</guimenuitem></menuchoice>. You
                can use the VMware vFabric server bundled with STS, but any other servlet
                container (such as the Jetty-based JEE Preview) should work fine as well.
            </para>

            <!-- TODO: Add screenshot. -->

            <para>
                In case you feel more comfortable in the Maven world, the project can also
                be deployed for testing with, for example, the
                <literal>jetty:run</literal> target. The Jetty plugin is automatically
                installed for the generated project.
            </para>
        </section>
    </section>

    <section xml:id="rapid.addons">
        <title>Using Vaadin Add-ons in a Roo project</title>

        <para>
            Complex Vaadin application often need to use some add-ons in addition to the
            core Vaadin. In our example project, we need the Vaadin Calendar and
            JPAContainer add-ons. The JPAContainer add-on is installed automatically by
            the Roo plugin, but the Calendar add-on needs to be installed manually.
        </para>

        <para>
            We will next:
        </para>

        <orderedlist>
            <listitem><para>Install the Vaadin Calendar add-on</para></listitem>
            <listitem><para>Compile the widget set</para></listitem>
            <listitem><para>Configure the Deployment Assembly</para></listitem>
        </orderedlist>

        <para>
            The Vaadin Plugin for Roo supports installing add-ons from the Vaadin
            Directory and compiling the included widget sets.
        </para>

        <section xml:id="rapid.addons.install">
            <title>Installing Add-ons</title>

            <para>
                Open or select a Roo Shell and enter:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[roo> vaadin addon install --artifactId vaadin-calendar]]></programlisting>

            <para>
                You can type the beginning of the command up to the
                <literal>--artifactId</literal>, followed by a space, and then hit
                <keycombo><keycap>Ctrl</keycap><keycap>Space</keycap></keycombo> for
                completion. It lists all the available add-ons in the Directory. If you
                enter the beginning of an add-on name, such as <literal>vaadin-</literal>,
                before the completion, it shows just those add-ons, as shown in <xref
                linkend="figure.rapid.addons.install.completion"/>.
            </para>

            <figure xml:id="figure.rapid.addons.install.completion">
                <title>Getting List of Add-ons in Directory</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="80%" scale="70" align="center" fileref="img/rapid/addon-install-completion.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="rapid.addons.widgetset">
            <title>Compiling the Widget Set</title>

            <para>
                Add-ons that include custom widgets, in this case the Vaadin Calendar
                component, require compilation of a <emphasis>widget set</emphasis>, as
                described in detail in <xref linkend="addons"/>. Roo makes the compilation
                simple, you only have to enter the following command in the Roo Shell:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[roo> vaadin widgetset create]]></programlisting>

            <para>
                Executing the command can take considerable time, as it downloads all the
                necessary Maven dependencies on the first run. The actual widget set
                compilation takes usually between 20 to 60 seconds, depending on the
                hardware.
            </para>

            <para>
                This creates a <emphasis>combining widget set</emphasis> that includes all
                the widget sets from different add-ons and also the default widget set of
                the Vaadin core library. The compiled widget set should appear in the
                <filename>target/rapid-0.1.0-SNAPSHOT/VAADIN/widgetsets/com.vaadin.rapid.web.RapidWidgetset</filename>
                folder and be referenced in the <filename>web.xml</filename> deployment
                descriptor of the application.
            </para>

            <para>
                Generally, only add-ons that introduce entirely new user interface
                components include a widget set that needs to be compiled. These are the
                majority of Vaadin add-ons. Add-ons providing a theme or container
                implementation do not include a widget set.
            </para>

            <para>
                If you later add other add-ons, you need to issue the <literal>vaadin
                widgetset update</literal> command, which updates the combining widget set
                definition file. The <literal>vaadin widgetset compile</literal> command
                simply recompiles the widget set without updating the combining widget set
                definition file.
            </para>
        </section>    

        <section xml:id="rapid.addons.deployment">
            <title>Configuring the Deployment Assembly</title>

            <para>
                The widget set is compiled under the
                <filename>target/rapid-0.1.0.BUILD-SNAPSHOT</filename> folder, which is
                not included in the deployment path by default.
            </para>

            <orderedlist>
                <listitem><para>Open the project properties for the project</para></listitem>
                <listitem><para>Select <guilabel>Deployment Assembly</guilabel></para></listitem>
                <listitem><para>Click <guibutton>Add</guibutton></para></listitem>
                <listitem><para>Select <menuchoice><guimenu>Folder</guimenu></menuchoice></para></listitem>
                <listitem><para>Select <filename>target/rapid-0.1.0.BUILD-SNAPSHOT</filename></para></listitem>
                <listitem><para>Click <guibutton>Finish</guibutton> and <guibutton>OK</guibutton> to save the settings</para></listitem>
            </orderedlist>
        
            <para>
                If you are using Maven to debug your application, you will face the same
                issue. As a workaround, use the <literal>jetty-run</literal> or
                <literal>jetty:run-exploded</literal> targets that use the target
                directory as the base directory for the web app. Another option is to
                modify the <literal>gwt-maven-plugin</literal> to compile the widget set
                to <filename>src/main/webapp</filename> with its
                <literal>inplace</literal> mode.
            </para>
        </section>
    </section>

    <section xml:id="rapid.viewcustomization">
        <title>Customizing Views</title>
    
        <para>
            For basic use, the entity views created by Roo work just fine. However in some
            cases, modifying the form or changing visible properties in the table
            component may be needed to satisfy critical end users. In this section, we
            discuss some methods how you can modify the application skeleton generated by
            Roo.
        </para>
    
        <section xml:id="rapid.viewcustomization.modify">
            <title>Modifying Roo generated entity form</title>

            <para>
                As discussed in <xref linkend="rapid.crudviews.skeleton"/>, entity forms
                generated by Roo can be made compatible with the visual editor of the
                Eclipse plugin. If you gave the <parameter>--visuallyComposable
                true</parameter> parameter for Roo when creating the views, you can open
                for example the <filename>WorkEntryForm.java</filename> file with the
                Visual Designer. For example, right-click on the the file in the
                <guilabel>Project Explorer</guilabel> view. Then, choosing the
                <guilabel>Design</guilabel> view from the bottom of the screen opens the
                form generated by Roo in a graphical editor. Use the editor to organize
                the view according to your preferences. Also, add a
                <classname>Label</classname> component to the view and name it as
                <parameter>hoursLabel</parameter>.
            </para>
        
            <para>
                When you switch back to the source view, you can immediately see the
                changes made by the visual mode. To fill proper value for the newly
                created <parameter>hoursLabel</parameter>, modify the
                <methodname>setItemDataSource()</methodname> method to call an
                <methodname>updateDuration()</methodname> method that you create to
                calculate the duration between start and the end times. The resulting
                value should be shown in the label. You might also call this method from a
                value change listener hooked to start and end time fields.
            </para>

            <para>
                At any time you may switch between the source code editor and the visual
                editor without losing changes done on the other side. Just make sure not
                to modify parts of the code (methods and field declarations) that are
                marked with <literal>@AutoGenerated</literal> annotation.
            </para>
        </section>

        <section xml:id="rapid.viewcustomization.calendarview">
            <title>Creating a Calendar View for Filling Work Entries</title>
        
            <para>
                In this section, we build an alternative view for
                <classname>WorkEntry</classname> entities built around the Vaadin Calendar
                add-on. The Calendar displays filled entries for the end user in a nice
                graphical presentation. User can get a quick overview of what he has done
                during the week and it is also easy to spot if there is some missing
                entries. The user can also select and modify time ranges visually with the
                calendar, which speeds up the daily tasks.
            </para>
        
            <para>
                Start by sketching the view with the Visual Designer.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Choose
                        <menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guisubmenu>Vaadin</guisubmenu><guimenuitem>Composite</guimenuitem></menuchoice>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Fill in the proper package and class name (such as
                        <filename>~web.ui</filename> and <classname>CalendarView</classname>).
                        The Vaadin Plugin for Eclipse creates a class that extends
                        <classname>CustomComponent</classname>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Switch to the <guilabel>Design</guilabel> tab using the tab selector
                        below the source code and the visual editor opens.
                    </para>
                </listitem>
            </orderedlist>

            <para>
                For our view we need three components: two
                <classname>ComboBox</classname>es to select the project and employee, and a
                <classname>Calendar</classname> from the add-on that we installed
                previously. Filtering may help you in finding them from the component
                list. Drag them to the the composite and sketch the view according to your
                preferences. Also use the <guilabel>Properties</guilabel> tab to give
                components more meaningful names and possibly fill in a suitable caption. When
                you return to the source code view, you can see the generated code.
            </para>

            <section xml:id="rapid.viewcustomization.calendarview.codecustomization">
                <title>Customizing Generated Code</title>
        
                <para>
                    The constructor has a comment to indicate the place where you should add
                    your custom code. To make our view display some data, we need to connect
                    the combo boxes to the data sources and provide events to the
                    <classname>Calendar</classname> component via its
                    <classname>CalendarEventProvider</classname> interface. For the project
                    and employee selectors, the easiest option is to use the
                    <classname>JPAContainer</classname>.
                </para>

                <para>
                    When implementing the <classname>CalendarEventProvider</classname>, you
                    need to extend the data model with a method that lists
                    <classname>WorkEntry</classname> objects within a specific time ranges and
                    also implement a light-weight wrapper for <classname>WorkEntry</classname>
                    to make them compatible with the <classname>Calendar</classname>
                    component.
                </para>
            </section>

            <section xml:id="rapid.viewcustomization.calendarview.usingviews">
                <title>Using Custom Views</title>
        
                <para>
                    Once you have some data sources connected, you most probably want to check
                    out how your new view looks in the application. The Vaadin application
                    skeleton generated by Roo uses the Navigator add-on and a generated
                    <literal>RapidEntityManagerView</literal> (where Rapid is the application
                    base name) class as the view controller. For complex applications, you
                    might want to build your own navigation system, but for this application
                    we can just modify the <classname>RapidEntityManagerView</classname> to
                    include our custom views.
                </para>

                <para>
                    Let the composite implement the
                    <classname>org.vaadin.navigator.Navigator.View</classname> interface and
                    modify <methodname>addEntityViewsToList()</methodname> method in
                    <classname>RapidEntityManagerView</classname> to include your custom view
                    to the navigation. After that, deploy the application and verify the view
                    is shown. You may add some test data in the
                    <classname>WorkEntry</classname> views generated by Roo and check that it
                    is shown in the <classname>CalendarView</classname>.
                </para>
            </section>

            <section xml:id="rapid.viewcustomization.calendarview.addentries">
                <title>Adding New Entries</title>

                <para>
                    To allow users to add new entries via Calendar, implement a
                    <classname>RangeSelectHandler</classname> and register it to the
                    Calendar. In the handler, you can create an new instance of
                    <classname>WorkEntry</classname>. Fill in the time range from the
                    provided event object and default values for the project and employee
                    fields that you can find through the combo boxes that we created
                    earlier.
                </para>
        
                <para>
                    The new <classname>WorkEntry</classname> object now contains the most
                    essential information, but it still has the default comment field. The
                    user might also want to review the new entry. Here we can use the
                    previously fine-tuned <classname>WorkEntry</classname> form that was
                    originally automatically created by the Roo. Wrap the
                    <classname>WorkEntry</classname> object in a
                    <classname>BeanItem</classname> and pass it to a
                    <classname>WorkEntryForm</classname> instance. As our Calendar
                    component consumes quite a lot of space on the screen, it is best to
                    show the editor form in a modal Window. Again, use your existing Java
                    know-how and extract the recyclable parts to helper methods (such as
                    <methodname>showEditorPopup(WorkEntry)</methodname>).
                </para>

                <para>
                    To fine-tune the usability of the view, you may add more hooks in the
                    <classname>Calendar</classname>:
                </para>

                <itemizedlist>
                    <listitem><classname>EventClickHandler</classname> to open editor for existing event</listitem>
                    <listitem><classname>EventMoveHandler</classname> to adjust the time range</listitem>
                    <listitem><classname>EventResizeHandler</classname> to adjust the time range</listitem>
                </itemizedlist>
            </section>
        </section>
    
        <section xml:id="rapid.viewcustomization.reportview">
            <title>Creating a Custom View for Reporting</title>
        
            <para>
                Our example project also has a report view for easy listing of work
                entries. The query can be filtered by project, employee and the time
                range. Most of the process is similar to creating the calendar view, but in
                the <classname>ReportView</classname> one can survive with just standard
                Vaadin components. The table component at the bottom of the view lists entries
                matching the criteria defined by the controls above it.
            </para>

            <para>
                When you have sketched the view connect selects to the data sources. Also hook
                a <classname>JPAContainer</classname> to the <classname>Table</classname>. Add
                <classname>ChangeListener</classname> to all fields and update filters in the
                <classname>JPAContainer</classname> instance hooked to the result table.
            </para>
        </section>
    </section>

    <section xml:id="rapid.auth">
        <title>Authentication and Authorization</title>
    
        <para>
            The goals of authentication and authorization are preventing unauthorized
            viewing and editing of data. In the case of our tutorial application, only
            administrators should be allowed to view and edit hours and projects entered
            by users other than themselves.
            </para>
    
        <section xml:id="rapid.auth.authentication">
            <title>Implementing Authentication and Authorization</title>

            <para>
                Since the requirements of the example project are very simple, all
                authentication is handled with a simple
                <classname>Authenticator</classname> class that checks if a certain user
                with a certain password exists in the database. The
                <classname>Authenticator</classname> could just as easily be implemented
                using Spring Security or some other security framework. The authenticator
                has two responsibilities:
            </para>
            
            <orderedlist>
                <listitem>
                    <para>
                        Authenticate users based on a username / password pair
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Keep track of views that require administrator privileges to
                        access and answer the simple question: "Is this view accessible in
                        the current session?"
                    </para>
                </listitem>
            </orderedlist>

            <para>
                This approach is too simplistic for a real project, but the basics should
                be fairly similar when integrating a framework such as Spring Security
                with Vaadin.
            </para>
        
            <para>
                To authenticate users, the system needs to show a login view before
                letting users view any possibly sensitive data. For the example project,
                the Vaadin composite <classname>LoginView</classname> was created using
                Vaadin Visual Designer. By default the Visual Designer creates a
                <classname>AbsoluteLayout</classname> as the root layout. This was changed
                into a <classname>VerticalLayout</classname> and a login form was placed
                inside of it. The login form was then aligned to the middle center, making
                it appear in the middle of the browser window when the login view is the
                only visible layout in the main window.
            </para>
        
            <para>
                In order to display the login view before anything else, the main window,
                which is defined by the <classname>RapidWindow</classname> class has to be
                edited. Instead of setting the content of the window to a new
                <classname>RapidEntityManagerView</classname>, the content is set to the
                login view, unless a user is already logged in, and a
                <classname>LoginListener</classname> is registered to the login view. The
                login listener is called when the "Login" button is clicked, and passed
                the values of the text fields in the login form. By default, a username
                and a password is passed in and these are passed off to the authenticator
                for authentication. If the authentication succeeds, the content of the
                <classname>RapidWindow</classname> is replaced with a new
                <classname>RapidEntityManagerView</classname>, just as before introducing
                the login view.
            </para>
        
            <programlisting><?pocket-size 65% ?><![CDATA[public class RapidWindow extends Window
        implements LoginListener {

    public RapidWindow() {
        if (RapidApplication.get().getUser() == null) {
            setContent(new LoginView(this));
        } else {
            showMainUI();
        }

        // select window theme
        setTheme("rapid");
    }

    public void showMainUI() {
        // entity manager
        setContent(new RapidEntityManagerView());
    }

    @Override
    public void onLogin(LoginEvent event) {
        String username = event.getLoginParameter("username");
        String password = event.getLoginParameter("password");
        if (Authenticator.login(username, password)) {
            showMainUI();
        }
    }
}]]></programlisting>
        
            <para>
                The check whether a user is already logged in is important, because of the
                multi-window support that is automatically enabled in all Vaadin projects
                created with Spring Roo. Without the check, a user could first log in as
                one user and then open a new window and log in as another user, causing
                both windows to be logged in as the latter user. This is because all
                windows open to the same application in the same browser share the same
                session, and only the last user to be logged in is stored in the session.
            </para>

            <para>
                Authorization is handled in the
                <methodname>addEntityViewsToList()</methodname> method in
                <classname>RapidEntityManagerView</classname> class. Before the view is
                added to the list, the authenticator is asked whether the user is allowed
                access the view and only adds the view if the answer is
                <literal>true</literal>.
            </para>
        
            <programlisting><?pocket-size 65% ?><![CDATA[if (Authenticator.isViewAccessible(viewClass) &&
    Navigator.View.class.isAssignableFrom(viewClass)) {
    navigator.addView(key, viewClass);
    ...
}]]></programlisting>
        </section>
    </section>

    <section xml:id="rapid.i18n">
        <title>Internationalization</title>

        <para>
            We want to have the user interface to be available in different
            languages. Details such as the formatting of dates has to change depending on
            the selected language.
        </para>

        <para>
            The login view has a drop-down select that allows the user to choose the
            language. The application attempts to detect the preferred language reported
            by the browser, and defaults to English if the preferred language is not
            available. The preferred language is detected and the locale set in the
            application class, as follows:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[public void init() {
    ...
    // Use the locale from the request as default.
    // Login uses this setting later.
    setLocale(((WebApplicationContext)getContext())
            .getBrowser().getLocale());
    ...
}]]></programlisting>

        <para>
            Now that we know the preferred language of the user, we can start
            internationalizing the application. Vaadin does not have a preferred way of
            doing internationalization, so you are free to choose whichever method you
            prefer. Quite often, the common Java practice of using
            <classname>ResourceBundle</classname>s and <filename>.properties</filename>
            files is sufficient, and this suits our application perfectly. Please refer to
            Java documentation for more details regarding internationalization in Java.
        </para>

        <para>
            The <emphasis>Externalize Strings</emphasis> feature in the Eclipse IDE (and
            STS) will handle most of the boilerplate generation. In the <guilabel>Package
            Explorer</guilabel>, select the package that holds the UI classes
            (<package>com.vaadin.rapid.web</package>) and select
            <menuchoice><guimenu>Source</guimenu><guimenuitem>Externalize
            Strings</guimenuitem></menuchoice>. The dialog shows a list of files that
            contains strings that are yet to be translated - you need to open one at a
            time and externalize the strings. In the externalize dialog, first make sure
            the location of the <filename>messages.properties</filename> is suitable (and
            stays the same for all files you go trough), in our case we want it in the
            <package>com.vaadin.rapid.web</package> package. The IDE will generate the
            <filename>messages.properties</filename> and a <classname>Messages</classname>
            class the first time you run it. In the <guilabel>String to
            externalize</guilabel> list, make sure that strings that do not need to be
            translated have an X mark and that strings that should be translated have a
            check mark. Also, change all keys for translated strings to something
            descriptive.
        </para>

        <figure xml:id="figure.rapid.i18n.externalize-screenshot">
            <title>The Externalize Strings Dialog</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" scale="50" align="center" fileref="img/rapid/i18n-externalize-strings.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Externalize Strings marks strings that should not be translated using a special
            comment in the code, so that the next time you run the function, it will only show
            the new strings or strings you have forgotten.
        </para>

        <para>
            Note that if you externalize strings from a visually editable component, the
            Visual Editor can no longer open the component, because the generated code has
            been changed. This will probably be fixed in a future release of the Visual
            Editor, but for now you can go ahead and move the code rows that contain
            translations to the constructor.
        </para>

        <para>
            Next, we will translate the names of the Views. We'll do this dynamically in the
            <classname>RapidEntityManagerView</classname> by prefixing the translation key
            with "<literal>View.</literal>" and appending the view name (with spaces removed).
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[final String viewCaption = Messages.getString("View." + viewName);]]></programlisting>

        <para>
            In this application we do not want to translate the URI fragment that is shown in
            the browser, so we make some small changes to keep the viewName and the translated
            viewCaption separate throughout the code. Whether or not one wants to translate
            depends on the application - if you translate the fragment, it will be more
            descriptive in the users own language, but users with different language settings
            will not be able to share deep links.
        </para>

        <para>
            To translate the column headers of the various tables, we add some code to the end
            of the <methodname>refresh()</methodname> in
            <classname>AbstractEntityView</classname>. This will allow us to translate the
            headers after the content has been set:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[protected void refresh() {
    ...
    // Translate column headers
    Object[] columns = getTableColumns();
    String[] headers = new String[columns.length];
    for (int i = 0; i < headers.length; i++)
        headers[i] = Messages.getString(getClass().getSimpleName()
                     + "." + columns[i].toString());
    table.setColumnHeaders(headers);
    ...
}]]></programlisting>

        <para>
            To translate boolean values and localize dates in the various tables, we
            modify the <methodname>createTable()</methodname> in
            <classname>AbstractEntityView</classname> so that it returns our own
            <classname>RapidTable</classname>, which overrides
            <methodname>formatPropertyValue()</methodname>:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[protected String formatPropertyValue(Object rowId, Object colId,
                                     Property property) {
    Object value = property.getValue();
    if (value instanceof Boolean) {
        // Translate boolean values
        return Messages.getString("Boolean."
            + ((Boolean) value).toString());
    } else if (value instanceof Date) {
        // Localize date/time
        return DateFormat.getDateTimeInstance(DateFormat.SHORT,
            DateFormat.SHORT, RapidApplication.get().getLocale())
                .format((Date) value);
    }
    return super.formatPropertyValue(rowId, colId, property);
}]]></programlisting>

        <para>
            There is one more translation task to do:
            <classname>BeansValidation</classname> (JSR 303) is used for validating values
            according to annotations on the entities. This process produces some messages
            that originate from the <classname>BeansValidation</classname>, and need to be
            translated separately. <classname>BeansValidation</classname> also uses
            property files, namely <filename>ValidationMessages.properties</filename>,
            that should be placed in the <filename>src/main/resources</filename>
            folder. To tell <classname>BeansValidation</classname> which locale to use we
            currently need some boilerplate - this will hopefully be fixed soon. In each
            <classname>Form</classname> class (<classname>ProjectForm</classname>,
            <classname>RapidUserForm</classname>, <classname>WorkEntryForm</classname>) we
            need to call a helper that goes trough our validators and sets the locale:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[public void setItemDataSource(Item item) {
    ...
    for (Object propertyId : getBeanPropertyIds())
        ValidatorMessageUtil.updateValidators(
                getField(propertyId));
    ...
}]]></programlisting>

        <para>
            The helper method in <classname>ValidatorMessageUtil</classname> iterates
            trough the validators for the field, updating the locale.
        </para>
    </section>

    <section xml:id="rapid.testing">
        <title>Testing the Application</title>
    
        <para>
            In the data model section, we already discussed briefly about automatic
            integration tests that Roo generates for the domain objects. They are a good
            start, but only ensure that simple CRUD methods work from domain model to the
            persistency layer. In serious application development, you should write tests
            for any additional business logic, as well for the UI layers.
        </para>

        <section xml:id="rapid.testing.overview">
            <title>Overview of Testing</title>
    
            <para>
                Writing unit tests for the user interface layer of an application can be a
                time consuming task. Yet, they do not necessary ensure that the UI works
                properly. Deployment problems, timing issues, and the browser layer may
                still cause issues that break the UI. In this step of the tutorial, we
                will use the Vaadin TestBench to test the user interface layer. TestBench
                executes tests with real browsers, by simulating user actions in the
                browser. This way, we do not just test the UI layer, but the entire stack
                from JavaScripts running in the browser down to the database.
            </para>

            <para>
                <emphasis>This currently describes the use of Vaadin TestBench version 2 -
                see <xref linkend="testbench"/> for the documentation of Vaadin TestBench
                3.</emphasis>
            </para>
    
            <para>
                Vaadin TestBench tests are normally recorded with a browser
                plugin. Advanced users may fine tune the tests by hand and, for example,
                configure tests with parameters. Tests scripts are then converted into
                JUnit test cases, which can be integrated into an existing testing
                environment. Roo projects are based on the Maven build system, so we will
                configure the <filename>pom.xml</filename> of the project so that
                TestBench tests are run automatically. The TestBench setup and usage is
                discussed briefly. Please refer to <xref linkend="testbench"/> in case you
                face problems.
            </para>
    
            <para>
                To help the integration tests, we use the Maven Failsafe plugin. It is a
                testing plugin that automatically runs all tests named, for example,
                <filename>*ITCase.java</filename> in the test sources with the
                <literal>verify</literal> goal. The Failsafe plugin also provides
                necessary hooks where we can configure how our application server is
                started and stopped. If you want to test on a separate server, you can do
                just deploy and un-deploy at these phases. The necessary Maven snippet can
                be found from the Failsafe project page.
            </para>
        </section>

        <section xml:id="rapid.testing.server">
            <title>Running the Test Server</title>
    
            <para>
                The Jetty plugin should be already installed in your
                <filename>pom.xml</filename>, but we will configure Jetty to start
                automatically before the integration test phase and close cleanly when the
                tests have been run. Add the following XML snippet inside the definition
                of your Jetty plugin:
            </para>
    
            <programlisting><?pocket-size 65% ?><![CDATA[<executions>
    <!-- start and stop jetty (running our app) when running
         integration tests -->
    <execution>
        <id>start-jetty</id>
        <phase>pre-integration-test</phase>
        <goals>
            <goal>run-exploded</goal>
        </goals>
        <configuration>
            <scanIntervalSeconds>0</scanIntervalSeconds>
            <daemon>true</daemon>
            <stopKey>STOP</stopKey>
            <stopPort>8866</stopPort>
        </configuration>
    </execution>
    <execution>
        <id>stop-jetty</id>
        <phase>post-integration-test</phase>
        <goals>
            <goal>stop</goal>
        </goals>
        <configuration>
            <stopPort>8866</stopPort>
            <stopKey>STOP</stopKey>
        </configuration>
    </execution>
</executions>]]></programlisting>

            <para>
                To verify that the integration test system works, you can create a simple
                smoke test. Create a JUnit test case and name it as
                <filename>SmokeTestITCase.java</filename> and create a test method that
                connects to the test server. Verify that a proper kickstart page is
                returned. This verifies that the application is properly deployed for more
                advanced tests. Run your integration test with <command>mvn
                verify</command>. If this basic integration test passes fine, you are
                ready to continue setting up the TestBench.
            </para>
        </section>

        <section xml:id="rapid.testing.testbench">
            <title>Installing TestBench with Maven</title>

            <para>
                TestBench is not available in any public Maven repository. Unless you have
                TestBench already installed, download it from
                vaadin.com/directory. Install the JAR to your local repository (or Maven
                proxy) by executing the following command in the install directory of
                TestBench:
            </para>
    
            <screen><?pocket-size 65% ?><command>mvn install::install-file</command> -Dfile=vaadin-testbench-2.2.2.jar
-DgroupId=com.vaadin -DartifactId=testbench -Dversion=2.2.2
-Dpackaging=jar -DgeneratePom=true</screen>

            <para>
                You also need to specify the dependency <filename>pom.xml</filename> file
                of the project. Use the <literal>test</literal> scope as the JAR file is
                not needed in the actual application execution. We will need it when
                compiling test scripts from HTML to JUnit test cases, and also when
                executing the actual JUnit tests.
            </para>

            <para>
                Notice that Vaadin TestBench is licensed with the Commercial Vaadin Add-on
                License. You can download the product for a 30-day free trial period with
                Maven, after which you need a license which you can buy from the Vaadin
                Directory.
            </para>
        </section>
    
        <section xml:id="rapid.testing.generating">
            <title>Generating JUnit Tests</title>

            <!-- TODO: Update to TestBench 3 -->
            <para>
                The test cases for Vaadin TestBench are recorded as HTML files and need to
                be compiled as JUnit tests <!--, as described in <xref
                linkend="testbench.xxxx"/> -->. This needs to be automated.
            </para>

            <para>
                Native scripts are kept in source repository as they are more maintainable
                than the compiled JUnit tests. The conversion is done by
                <classname>com.vaadin.testbenc.DirectoryTestConverter</classname>
                tool. You can use it most conveniently through the Maven Exec
                plugin. Configure it to be run at, for example,
                <filename>generate-test-sources</filename> and add generated java files to
                test sources. The Exec plugin has an option to do this, but you may need
                to use <literal>build-helper-maven-plugin</literal> instead.
            </para>
        </section>

        <section xml:id="rapid.testing.system-properties">
            <title>Configuring System Properties</title>

            <para>
                The test setup is now almost ready. As the last step, we need to provide
                some system properties to be defined for the JUnit tests generated by
                TestBench. Add the following configuration snippet to the configuration of
                the Failsafe plugin:
            </para>
    
            <programlisting><?pocket-size 65% ?><![CDATA[<configuration>
    <!-- Define some necessary system properties for -->
    <!-- TestBench JUnit tests.                      -->
    <systemPropertyVariables>
        <com.vaadin.testbench.tester.host>
            ${testbench.hubhost}
        </com.vaadin.testbench.tester.host>
        <com.vaadin.testbench.deployment.url>
            ${testbench.appurl}
        </com.vaadin.testbench.deployment.url>
        <com.vaadin.testbench.screenshot.directory>
            ${project.build.directory}/testbench-generated
        </com.vaadin.testbench.screenshot.directory>
    </systemPropertyVariables>
    <encoding>UTF-8</encoding>
</configuration>]]></programlisting>

            <para>
                <!-- TODO Update for TestBench 3: The parameters are described in <xref
                linkend="testbench.xxxx.ant-configuration"/>. --> Define the used
                parameters and you are ready to go. The <literal>localhost</literal> and
                <literal>http://localhost:8080/${project.name}</literal> will work fine
                for local testing. Save your scripts under
                <filename>src/test/resources/</filename> with the filenames ending with
                <filename>ITCase.html</filename>, and they will be automatically executed
                when you issue <command>mvn verify</command>. Your first test can simply
                login as the admin user and then assert some text to verify that the
                initial screen gets rendered.
            </para>
        </section>

        <section xml:id="rapid.testing.notes">
            <title>Notes</title>

            <para>
                Notice that we did not configure the TestBench hub (nor a remote control)
                to start and stop from Maven. Instead, we just defined the host where the
                hub is running. So, before actually executing the integration tests, make
                sure that the TestBench is up and running, as described in <xref
                linkend="testbench"/>. Commonly, TestBench is used so that the hub and its
                slaves are running in a separate cluster, rather than on developer's
                workstations. If you have access to this kind of external hub, you can
                give its address as
                <literal>com.vaadin.testbench.tester.host</literal>. The
                <literal>localhost</literal> does not work as the deployment URL in this
                case, but you should use an URL which the test machines can access. If no
                separate test cluster is used, you might want to customize your Maven
                build to start and stop TestBench in a way similar to Jetty.
            </para>

            <para>
                Your more advanced tests can then use the login test as a base and test
                various features. Record tests for at least basic CRUD actions for all
                entity types. To verify authorization code to work, you can also create a
                non-admin user in one test and verify with the new user that admin only
                features are not visible. Most actions can be recorded with the TestBench
                Recorder automatically, but there are some limitations. For example,
                selecting a time range in the Calendar view needs to be manually built
                using Selenium methods.
            </para>
    
            <para>
                When building tests, notice that integration tests use the same database
                by default, so the data filled in the previous test will be visible during
                the next test. Tests are run in alphabetical order, so you may use a
                naming convention to control the test execution order.
            </para>
        </section>
    </section>

    <section xml:id="rapid.exception">
        <title>Exception Handling</title>

        <para>
            When something goes wrong in a Vaadin application, a small error indicator
            icon is shown on the control that was interacted with.  When hovering over the
            icon, a tooltip containing the entire stacktrace of the exception is shown. No
            normal person (that is, other than a software developer) understands what this
            means and knows what to do.
        </para>

        <para>
            In this section, we will remove the stack traces and replace them with error
            messages in terms that a normal user would understand.
        </para>
    
        <section xml:id="rapid.exception.preventing">
            <title>Preventing Stacktraces in the UI</title>

            <para>
                The autogenerated code lets the exceptions fall all the way through to the
                user interface. This can easily be changed by overriding the
                <methodname>terminalError()</methodname> method in the
                <classname>Application</classname> subclass.
            </para>

            <!-- TODO Vaadin 7: Window -> Root/Page -->
            <!-- ...actually move all this under application.error.exception... -->
            <programlisting><?pocket-size 65% ?><![CDATA[@Override
public void terminalError(Terminal.ErrorEvent event) {
    Window errorWindow = findWindowForError(event);
    // Shows an error notification
    if (errorWindow != null) {
        errorWindow.showNotification(
            "An internal error has occurred, please " +
                "contact the administrator!",
            Notification.TYPE_ERROR_MESSAGE);
    }

    // print the error
    logger.log(Level.SEVERE,
        "An uncaught exception occurred: ",
        event.getThrowable());
}]]></programlisting>
        </section>

        <section xml:id="rapid.exception.catch">
            <title>Where to Catch Exceptions</title>

            <para>
                The most likely places for errors to occur in the example application are
                when interacting with the database. Validation errors are already handled
                in the generated code, but errors due to constraint violations on the
                database level and communication failures need to be caught and handled
                correctly.
            </para>
        
            <para>
                Almost all saving and deleting of entities is handled through the
                <classname>AbstractEntityView</classname>, which is the super type of all
                but one view. <classname>CalendarView</classname> is the custom view that
                does not extend <classname>AbstractEntityView</classname>, and thus needs
                to catch the exceptions separately. Almost all exceptions can be handled
                in a good way by handling them in
                <classname>AbstractEntityView</classname> and
                <classname>CalendarView</classname>. When an exception occurs, an error
                notification should be displayed to the user.
            </para>

            <section xml:id="rapid.exception.catch.abstractentityview">
                <title>Handling Exceptions in AbstractEntityView</title>

                <para>
                    The Vaadin plug-in for Spring Roo generates the
                    <classname>AbstractEntityView</classname> class for handling CRUD for
                    all different entities in the application. This means that the methods
                    that handle saving and deleting of entities can be changed to include
                    customized exception handling. Roo generates an aspect,
                    <classname>AbstractEntityView_Roo_AbstractEntityView</classname>
                    containing the <methodname>doCommit()</methodname> and
                    <methodname>doDelete()</methodname> methods. These methods can be
                    changed by moving them to the
                    <classname>AbstractEntityView</classname>, which will cause Roo to
                    stop autogenerating the methods in the
                    <classname>AbstractEntityView_Roo_AbstractEntityView</classname>
                    aspect.
                </para>
            
                <para>
                    Move the methods to <classname>AbstractEntityView</classname> and
                    surround the method contents with a <literal>try...catch</literal>
                    block, catching all <classname>Exception</classname>s and showing a
                    notification about which operation failed.
                </para>
            
                <programlisting><?pocket-size 65% ?><![CDATA[@Transactional
public void doDelete() {
    try {
        Object id = getIdForEntity(getEntityForItem(
                        getForm().getItemDataSource()));
        if (id != null) {
            getTable().removeItem(id);
        }
    } catch (Exception e) {
        logger.log(Level.SEVERE, "Could not delete entity", e);
        Notification.show("Deletion of the item failed.",
                          Notification.TYPE_ERROR_MESSAGE);
    }
}]]></programlisting>
            </section>
        
            <section xml:id="rapid.exception.catch.calendarview">
                <title>Handling Exceptions in CalendarView</title>

                <para>
                    Since <classname>CalendarView</classname> is a custom view which
                    doesn't extend <classname>AbstractEntityView</classname>, it also
                    needs to handle exceptions. The calendar view does the same things as
                    the other entity views, but with a different layout and logic.
                </para>

                <para>
                    Exception handling needs to be added to all code that persists or
                    deletes data from the database.  The
                    <classname>CalendarView</classname> does this in several locations:
                    When creating a new entry, when editing an entry, when moving an entry
                    and when resizing an entry. E.g. the range select handler, which
                    persists a work entry when it is first created should be changed to
                    wrap the call to <methodname>workEntry.persist()</methodname> in a
                    <literal>try...catch</literal> block.
                </para>
            
                <programlisting><?pocket-size 65% ?><![CDATA[@Override
public void rangeSelect(RangeSelectEvent event) {

    ...
    // Build a work entry
    ...

    try {
        workEntry.persist();
        showEditorPopup(workEntry, true);
    } catch (Exception e) {
        logger.log(Level.SEVERE, "Could not store entity", e);
        Notification.show("Could not create a new " +
                work entry due to an internal error.",
                Notification.TYPE_ERROR_MESSAGE);
    }
}]]></programlisting>

                <para>
                    In the rest of the code, all calls to
                    <methodname>persist()</methodname>, <methodname>merge()</methodname>
                    or <methodname>delete()</methodname> are wrapped in
                    <literal>try...catch</literal> blocks and a notification with a
                    suitable message for each of the cases is displayed.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="rapid.cloudfoundry">
        <title>Deploying to Cloud Foundry</title>

        <para>
            Cloud Foundry (<literal>http://cloudfoundry.com/</literal>) is a new
            platform-as-a-service solution from SpringSource. Cloud Foundry makes it
            extremely easy to deploy applications created with Spring Roo and Vaadin to
            the cloud.
        </para>
    
        <para>
            Before you can deploy to Cloud Foundry, you must register an account at
            <literal>http://cloudfoundry.com/</literal>. The activation might take some
            time, so you should do the registration several days before you need the
            account.
        </para>
    
        <section xml:id="rapid.cloudfoundry.plugin">
            <title>Installing the Cloud Foundry Plug-in in STS</title>

            <para>
                Installing the Cloud Foundry plug-in is easy. Open the STS Dashboard and
                select the <guilabel>Extensions</guilabel> tab in the lower-left corner of
                the dashboard view. Scroll down to the <guilabel>Server and
                Clouds</guilabel> section and choose the <guilabel>Cloud Foundry
                integration plug-in</guilabel> from there. Click
                <guibutton>Install</guibutton> and follow the on-screen instructions.
            </para>
        </section>
    
        <section xml:id="rapid.cloudfoundry.deploy">
            <title>Deploying the Application</title>
            <para>
                Deploying the application is also very simple.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Open the <guilabel>Servers</guilabel> view, right-click somewhere in
                        it, and create a
                        <menuchoice><guimenu>New</guimenu><guimenuitem>Server</guimenuitem></menuchoice>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        In the <guilabel>New Server</guilabel> window, choose
                        <menuchoice><guimenu>VMWare</guimenu><guimenuitem>Cloud
                                Foundry</guimenuitem></menuchoice> and click
                        <guibutton>Next</guibutton>.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Fill in the account information that you received by email from
                        cloudfoundry.com and choose <guilabel>VMware Cloud Foundry -
                            http://api.cloudfoundry.com</guilabel> from the URL dropdown.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        You can click 'Validate Account' to make sure that you filled in your
                        password correctly.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Click 'Finish' to finish the installation of the Cloud Foundry server.
                    </para>
                </listitem>
            </orderedlist>
        
            <para>
                Once the new server is installed, you can add your project to it, just
                like you would add your project to any other server using the
                <guilabel>Servers</guilabel> view. Once added, right-click on the project
                and choose <guibutton>Start</guibutton>. This will ask for a name that
                identifies your project in the cloud as well as the URL to deploy
                to. After giving this information, the project will be uploaded and
                started in the cloud. After a few seconds, you should be able to visit the
                URL you provided and see your project in action.
            </para>
        </section>
    
        <section xml:id="rapid.cloudfoundry.mysql">
            <title>Binding to the MySQL Service</title>

            <para>
                The final part of our demonstration is to bind the application deployed in the
                Cloud Foundry to a real DBMS. In the following, we describe how you can bind
                the application to a MySQL database.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Bind a MySQL database to the application in Eclipse. In the
                        <guilabel>Cloud Foundry</guilabel> view:
                    </para>

                    <orderedlist>
                        <listitem>
                            <para>
                                Double-click the application deployed in Cloud Foundry
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                Select <guilabel>Services</guilabel> and click <guibutton>Add</guibutton>
                                in the upper-right corner
                            </para>
                        </listitem>
                
                        <listitem>
                            <para>
                                Give the connection a name and choose a MySQL database
                            </para>
                        </listitem>

                        <listitem>
                            <para>
                                Drag the created service from the <guilabel>Services</guilabel> panel
                                to the <guilabel>Services</guilabel> table in the application

                            <!-- TODO: Is this correct? Sounds suspicious. Verify. -->
                            </para>
                        </listitem>
                    </orderedlist>
                </listitem>

                <listitem>
                    <para>
                        Remove the dependency to the HSQLDB that we used at first from <filename>pom.xml</filename>
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Add the MySQL connector dependency as follows:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>5.1.15</version>
</dependency>]]></programlisting>
                </listitem>

                <listitem>
                    <para>
                        Add the Cloud Foundry runtime dependency as follows:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<dependency>
  <groupId>org.cloudfoundry</groupId>
  <artifactId>cloudfoundry-runtime</artifactId>
  <version>0.6.1</version>
</dependency>]]></programlisting>
                </listitem>

                <listitem>
                    <para>
                        Edit the <filename>persistence.xml</filename> file and change the
                        <classname>org.eclipse.persistence.platform.database.HSQLPlatform</classname>
                        class name to
                        <classname>org.eclipse.persistence.platform.database.MySQLPlatform</classname>.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Edit the <filename>applicationContext.xml</filename> file and change the following line:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop= ...]]></programlisting>

                    <para>
                        to the following:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:aop="http://www.springframework.org/schema/aop"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:jee="http://www.springframework.org/schema/jee"
  xmlns:tx="http://www.springframework.org/schema/tx"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xmlns:cloud="http://schema.cloudfoundry.org/spring"
  xsi:schemaLocation="http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://schema.cloudfoundry.org/spring http://schema.cloudfoundry.org/spring/cloudfoundry-spring.xsd">]]></programlisting>
                </listitem>

                <listitem>
                    <para>
                        Also in the <filename>applicationContext.xml</filename> replace the following:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<bean class="org.apache.commons.dbcp.BasicDataSource"
      destroy-method="close" id="dataSource">
  <property name="driverClassName"
            value="${database.driverClassName}"/>
  <property name="url" value="${database.url}"/>
  <property name="username" value="${database.username}"/>
  <property name="password" value="${database.password}"/>
</bean>]]></programlisting>

                    <para>
                        with the following:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<cloud:data-source id="dataSource" />]]></programlisting>
                </listitem>
            </orderedlist>
        </section>
    </section>
</chapter>
	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
