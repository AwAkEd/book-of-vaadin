<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="datamodel">
	<title>Binding Components to Data</title>

    <para>
        This chapter describes the Vaadin Data Model and shows how you can use it to bind
        components directly to data sources, such as database queries.
    </para>

	<section xml:id="datamodel.overview">
		<title>Overview</title>

		<para>
            The Vaadin Data Model is one of the core concepts of the library. To allow the
            view (user interface components) to access the data model of an application
            directly, we have introduced a standard data interface.
		</para>

		<para>
			The model allows binding user interface components directly to the data that
			they display and possibly allow to edit. There are three nested levels of
			hierarchy in the data model: <emphasis>property</emphasis>,
			<emphasis>item</emphasis>, and <emphasis>container</emphasis>. Using a
			spreadsheet application as an analogy, these would correspond to a cell, a
			row, and a table, respectively.
		</para>

		<figure>
			<title>Vaadin Data Model</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/arch/datamodel-sml.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="20" smallscale="100%" align="center" fileref="img/arch/datamodel-whitebg.png"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>
			The Data Model is realized as a set of interfaces in the
			<classname>com.vaadin.data</classname> package. The package contains the
			<classname>Property</classname>, <classname>Item</classname>, and
			<classname>Container</classname> interfaces, along with a number of more
			specialized interfaces and classes.
		</para>

		<para>
			Notice that the Data Model does not define data representation, but only
			interfaces. This leaves the representation fully to the implementation of the
			containers. The representation can be almost anything, such as a plain old Java
			object (POJO) structure, a filesystem, or a database query.
		</para>

		<para>
			The Data Model is used heavily in the core user interface components of
			Vaadin, especially the field components, that is, components that implement
			the <classname>Field</classname> interface or more typically extend
			<classname>AbstractField</classname>, which defines many common features. A
			key feature of all the built-in field components is that they can either
			maintain their data by themselves or be bound to an external data source. The
			value of a field is always available through the
			<classname>Property</classname> interface. As more than one component can be
			bound to the same data source, it is easy to implement various viewer-editor
			patterns.
		</para>

        <para>
            The relationships of the various interfaces are shown in <xref
            linkend="figure.datamodel.overview.relationships"/>; the value change event
            and listener interfaces are shown only for the <classname>Property</classname>
            interface, while the notifier interfaces are omitted altogether.
        </para>
		
		<figure xml:id="figure.datamodel.overview.relationships">
			<title>Interface Relationships in Vaadin Data Model</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/datamodel/datamodel-interfaces-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="100" smallscale="100%" align="center" fileref="img/datamodel/datamodel-interfaces-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>
		
		<para>
			The Data Model has many important and useful features, such as support for
			change notification. Especially containers have many helper interfaces,
			including ones that allow indexing, ordering, sorting, and filtering the
			data. Also <classname>Field</classname> components provide a number of
			features involving the data model, such as buffering, validation, and lazy
			loading.
		</para>

		<para>
            In addition to the interfaces, Vaadin library provides a number of built-in
            implementations of the interfaces. The built-in implementations are used as
            the default data models in many field components.
        </para>
	</section>

	<section xml:id="datamodel.properties">
		<title>Properties</title>

		<para>
			The <classname>Property</classname> interface is the base of the Vaadin Data
			Model. It provides a standardized API for a single data object that can be
			read (get) and written (set). A property is always typed, but can optionally
			support data type conversions. The type of a property can be any Java
			class. Optionally, properties can provide value change events for following
			their changes.
		</para>

        <para>
            The value of a property is written with <methodname>setValue()</methodname>
            and read with <methodname>getValue()</methodname>. The return value is a
            generic <classname>Object</classname> reference, so you need to cast it to the
            proper type. The type can be acquired with <methodname>getType()</methodname>.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[final TextField tf = new TextField("Name");
        
// Set the value
tf.setValue("The text field value");
        
// When the field value is edited by the user
tf.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Get the value and cast it to proper type
        String value = (String) tf.getValue();
        
        // Do something with it
        layout.addComponent(new Label(value));
    }
});]]></programlisting>

        <para>
            Changes in the property value usually emit a
            <classname>ValueChangeEvent</classname>, which can be handled with a
            <classname>ValueChangeListener</classname>. The event object provides
            reference to the property with <methodname>getProperty()</methodname>.
        </para>

		<!-- TODO this might not be the best place to explain this - maybe split the paragraph? -->
		<para>
			Properties are in themselves unnamed. They are collected in
			<emphasis>items</emphasis>, which associate the properties with names: the
			<emphasis>Property Identifiers</emphasis> or <emphasis>PID</emphasis>s.  Items
			can be further contained in containers and are identified with <emphasis>Item
			Identifiers</emphasis> or <emphasis>IID</emphasis>s. In the spreadsheet
			analogy, <emphasis>Property Identifiers</emphasis> would correspond to column
			names and <emphasis>Item Identifiers</emphasis> to row names. The identifiers
			can be arbitrary objects, but must implement the
			<methodname>equals(Object)</methodname> and
			<methodname>hashCode()</methodname> methods so that they can be used in any
			standard Java <classname>Collection</classname>.
		</para>

		<para>
			The <classname>Property</classname> interface can be utilized either by
			implementing the interface or by using some of the built-in property
			implementations. Vaadin includes a <classname>Property</classname> interface
			implementation for arbitrary function pairs and bean properties, with the
			<classname>MethodProperty</classname> class, and for simple object properties,
			with the <classname>ObjectProperty</classname> class, as described later.
		</para>

		<para>
			In addition to the simple components, many selection components such as
			<classname>Select</classname>, <classname>Table</classname>, and
			<classname>Tree</classname> provide their current selection through the
			<classname>Property</classname> property. In single selection mode, the
			property is a single item identifier, while in multiple selection mode it is a
			set of item identifiers. Please see the documentation of the selection
			components for further details.
		</para>
		
		<para>
			Components that can be bound to a property have an internal default data
			source object, typically a <classname>ObjectProperty</classname>, which is
			described later. As all such components are viewers or editors, also described
			later, so you can rebind a component to any data source with
			<methodname>setPropertyDataSource()</methodname>.
		</para>

        <section xml:id="datamodel.properties.viewers">
            <title>Property Viewers and Editors</title>

            <para>
                The most important function of the <classname>Property</classname> as well
                as of the other data model interfaces is to connect classes implementing
                the interface directly to editor and viewer classes. This means connecting
                a data source (model) to a user interface component (views) to allow
                editing or viewing the data model.
            </para>

            <para>
                A property can be bound to a component implementing the
                <classname>Viewer</classname> interface with
                <methodname>setPropertyDataSource()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a data model
ObjectProperty property =
    new ObjectProperty("Hello", String.class);
        
// Have a component that implements Viewer
Label viewer = new Label();
        
// Bind it to the data
viewer.setPropertyDataSource(property);]]></programlisting>

            <para>
                You can use the same method in the <classname>Editor</classname> interface
                to bind a component that allows editing a particular property type to a
                property.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a data model
ObjectProperty property =
    new ObjectProperty("Hello", String.class);
        
// Have a component that implements Viewer
TextField editor = new TextField("Edit Greeting");
        
// Bind it to the data
editor.setPropertyDataSource(property);
]]></programlisting>

            <para>
                As all field components implement the <classname>Property</classname>
                interface, you can bind any component implementing the
                <classname>Viewer</classname> interface to any field, assuming that the
                viewer is able the view the object type of the field. Continuing from the
                above example, we can bind a <classname>Label</classname> to the
                <classname>TextField</classname> value:
            </para>
        
            <programlisting><?pocket-size 65% ?><![CDATA[Label viewer = new Label();
viewer.setPropertyDataSource(editor);

// The value shown in the viewer is updated immediately
// after editing the value in the editor (once it
// loses the focus)
editor.setImmediate(true);]]></programlisting>

        </section>

        <section xml:id="datamodel.properties.objectproperty">
            <title><classname>ObjectProperty</classname> Implementation</title>

            <para>
                The <classname>ObjectProperty</classname> class is a simple implementation
                of the <classname>Property</classname> interface that allows storing an
                arbitrary Java object.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a component that implements Viewer interface
final TextField tf = new TextField("Name");
        
// Have a data model with some data
String myObject = "Hello";
        
// Wrap it in an ObjectProperty
ObjectProperty property =
    new ObjectProperty(myObject, String.class);
        
// Bind the property to the component
tf.setPropertyDataSource(property);]]></programlisting>

        </section>

        <section xml:id="datamodel.properties.implementing">
            <title>Implementing the <classname>Property</classname> Interface</title>

            <para>
                Implementation of the <classname>Property</classname> interface requires
                defining setters and getters for the value and the
                <emphasis>read-only</emphasis> mode. Only a getter is needed for the
                property type, as the type is often fixed in property implementations.
            </para>

            <para>
                The following example shows a simple implementation of the
                <classname>Property</classname> interface:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyProperty implements Property {
    Integer data     = 0;
    boolean readOnly = false;
    
    // Return the data type of the model
    public Class<?> getType() {
        return Integer.class;
    }

    public Object getValue() {
        return data;
    }
    
    // Override the default implementation in Object
    @Override
    public String toString() {
        return Integer.toHexString(data);
    }

    public boolean isReadOnly() {
        return readOnly;
    }

    public void setReadOnly(boolean newStatus) {
        readOnly = newStatus;
    }

    public void setValue(Object newValue)
            throws ReadOnlyException, ConversionException {
        if (readOnly)
            throw new ReadOnlyException();
            
        // Already the same type as the internal representation
        if (newValue instanceof Integer)
            data = (Integer) newValue;
        
        // Conversion from a string is required
        else if (newValue instanceof String)
            try {
                data = Integer.parseInt((String) newValue, 16);
            } catch (NumberFormatException e) {
                throw new ConversionException();
            }
        else
             // Don't know how to convert any other types
            throw new ConversionException();

        // Reverse decode the hexadecimal value
    }
}
        
// Instantiate the property and set its data
MyProperty property = new MyProperty();
property.setValue(42);
        
// Bind it to a component
final TextField tf = new TextField("Name", property);]]></programlisting>

            <para>
                The components get the displayed value by the
                <methodname>toString()</methodname> method, so it is necessary to override
                it. To allow editing the value, value returned in the
                <methodname>toString()</methodname> must be in a format that is accepted
                by the <methodname>setValue()</methodname> method, unless the property is
                read-only. The <methodname>toString()</methodname> can perform any type
                conversion necessary to make the internal type a string, and the
                <methodname>setValue()</methodname> must be able to make a reverse
                conversion.
            </para>

            <para>
                The implementation example does not notify about changes in the property
                value or in the read-only mode. You should normally also implement at
                least the <classname>Property.ValueChangeNotifier</classname> and
                <classname>Property.ReadOnlyStatusChangeNotifier</classname>. See the
                <classname>ObjectProperty</classname> class for an example of the
                implementation.
            </para>
        </section>

	</section>

	<section xml:id="datamodel.items">
		<title>Holding properties in Items</title>

		<para>
			The <classname>Item</classname> interface provides access to a set of named
			properties. Each property is identified by a <emphasis>property
			identifier</emphasis> (PID) and a reference to such a property can be queried
			from an <classname>Item</classname> with
			<methodname>getItemProperty()</methodname> using the identifier.
        </para>

        <para>
            Examples on the use of items include rows in a <classname>Table</classname>,
            with the properties corresponding to table columns, nodes in a
            <classname>Tree</classname>, and the the data bound to a
            <classname>Form</classname>, with item's properties bound to individual form
            fields.
		</para>
		
		<para>
			Items are generally equivalent to objects in the object-oriented model, but
			with the exception that they are configurable and provide an event handling
			mechanism. The simplest way to utilize <classname>Item</classname> interface
			is to use existing implementations. Provided utility classes include a
			configurable property set (<classname>PropertysetItem</classname>) and a
			bean-to-item adapter (<classname>BeanItem</classname>). Also, a
			<classname>Form</classname> implements the interface and can therefore be used
			directly as an item.
		</para>

		<para>
			In addition to being used indirectly by many user interface components, items
			provide the basic data model underlying the <classname>Form</classname>
			component.  In simple cases, forms can even be generated automatically from
			items.  The properties of the item correspond to the fields of the form.
		</para>

        <para>
            The <classname>Item</classname> interface defines inner interfaces for
            maintaining the item property set and listening changes made to
            it. <classname>PropertySetChangeEvent</classname> events can be emitted by a
            class implementing the <classname>PropertySetChangeNotifier</classname>
            interface. They can be received through the
            <classname>PropertySetChangeListener</classname> interface.
        </para>

        <section>
            <title>The <classname>PropertysetItem</classname> Implementation</title>

            <para>
                The <classname>PropertysetItem</classname> is a generic implementation of
                the <classname>Item</classname> interface that allows storing
                properties. The properties are added with
                <methodname>addItemProperty()</methodname>, which takes a name and the
                property as parameters.
            </para>

            <para>
                The following example demonstrates a typical case of collecting
                <classname>ObjectProperty</classname> properties in an item:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[PropertysetItem item = new PropertysetItem();
item.addItemProperty("name", new ObjectProperty("Zaphod"));
item.addItemProperty("age", new ObjectProperty(42));
        
// Bind it to a component
Form form = new Form();
form.setItemDataSource(item);]]></programlisting>

        </section>

        <section>
            <title>Wrapping a Bean in a <classname>BeanItem</classname></title>

            <para>
                The <classname>BeanItem</classname> implementation of the
                <classname>Item</classname> interface is a wrapper for Java Bean
                objects. In fact, only the setters and getters are required while
                serialization and other bean features are not, so you can wrap almost any
                POJOs with minimal requirements.
            </para>

<programlisting><?pocket-size 65% ?><![CDATA[// Here is a bean (or more exactly a POJO)
class Person {
    String name;
    int    age;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Integer getAge() {
        return age;
    }
    
    public void setAge(Integer age) {
        this.age = age.intValue();
    }
}

// Create an instance of the bean
Person bean = new Person();
        
// Wrap it in a BeanItem
BeanItem<Person> item = new BeanItem<Person>(bean);
        
// Bind it to a component
Form form = new Form();
form.setItemDataSource(item);]]></programlisting>

            <para>
                You can use the <methodname>getBean()</methodname> method to get a
                reference to the underlying bean.
            </para>

        </section>
	</section>

	<section xml:id="datamodel.container">
		<title>Collecting Items in Containers</title>

		<para>
			<classname>Container</classname> is the highest-level of the data model
			interfaces supported by Vaadin. It provides a very flexible way of managing a
			set of items that share common properties. Contained items are identified by
			an <emphasis>item identifier</emphasis> or <emphasis>IID</emphasis>.
        </para>

        <para>
            Items can be added to a container with the <methodname>addItem()</methodname>
            method.  Notice that the actual item is not passed as a parameter to the
            method, only the item ID, as the interface assumes that the container
            implementation knows how to create the item. The parameterless version of the
            method uses an automatically generated item ID. Implementations can provide
            methods to add externally created items, or they can assume that the item ID
            is also the item itself.
        </para>

        <para>
            Properties can be requested from container by first requesting an item with
            <methodname>getItem()</methodname> and then getting the properties from the
            item with <methodname>getItemProperty()</methodname>. You can also get a
            property directly by the item and property ids with
            <methodname>getContainerProperty()</methodname>.
		</para>

		<para>
			The <classname>Container</classname> interface was designed with flexibility
			and efficiency in mind. It contains inner interfaces that containers can
			optionally implement for ordering the items sequentially, indexing the items,
			and accessing them hierarchically. Such ordering models provide the basis for
			the <classname>Table</classname>, <classname>Tree</classname>, and
			<classname>Select</classname> components. As with other data model interfaces,
			the <classname>Container</classname> supports events for notifying about
			changes made to their contents.
		</para>

		<para>
			As containers can be unordered, ordered, indexed, or hierarchical, they can
			interface practically any kind of data representation. Vaadin includes data
			connectors for some common data sources, such as the simple tabular data, with
			<classname>IndexedContainer</classname>, and the filesystem, with
			<classname>FilesystemContainer</classname>.
		</para>

		<para>
			In addition to generic container implementations, also many user interface
			components are containers as themselves, in addition to being properties. This
			is especially true for selection components, that is, those that implement
			<classname>Select</classname>, because they are containers that contain
			selectable items. Their property is the currently selected item.  This is
			useful as it allows binding components to view and updating each others' data
			directly, and makes it easy to reuse already constructed data models, for
			example, a form could edit a row (item) of a table directly, and the table
			could use a database container as its underlying container. The fields of the
			form would correspond to the properties of the item, that is, the cells of the
			table row.
		</para>

		<para>
			The library contains a set of utilities for converting between different
			container implementations by adding external ordering or hierarchy into
			existing containers. In-memory containers implementing indexed and
			hierarchical models provide easy-to-use tools for setting up in-memory data
			storages. Such default container implementations include
			<classname>IndexedContainer</classname>, which can be thought of as a
			generalization of a two-dimensional data table, and
			<classname>BeanItemContainer</classname>, which maps standard Java objects
			(beans) to items of an indexed container. In addition, the built-in containers
			include a hierarchical container for direct file system browsing.
		</para>

        <section xml:id="datamodel.container.interfaces">
            <title>Container Interfaces</title>
        </section>

        <section xml:id="datamodel.container.indexedcontainer">
            <title><classname>IndexedContainer</classname></title>
        </section>

        <section xml:id="datamodel.container.hierarchicalcontainer">
            <title><classname>HierarchicalContainer</classname></title>
        </section>

        <section xml:id="datamodel.container.beancontainers">
            <title>Bean Containers</title>
        </section>

        <section xml:id="datamodel.container.beanitemcontainer">
            <title><classname>BeanItemContainer</classname></title>
        </section>

        <section xml:id="datamodel.container.beancontainer">
            <title><classname>BeanContainer</classname></title>

            <para>
                The <classname>BeanContainer</classname> is an in-memory container for
                JavaBeans. Unlike <classname>BeanItemContainer</classname>, it contains
                bean objects directly, without having to wrap the beans in a
                <classname>BeanItem</classname>.
            </para>

            <para>
                Just like in the <classname>BeanItem</classname> wrapper, the properties
                of the container are determined automatically by inspecting the JavaBean
                class. This requires that the bean class has public visibility and only
                beans of the same type can be added to the container.
            </para>

            <para>
                In <classname>BeanContainer</classname>, again unlike in
                <classname>BeanItemContainer</classname>, the item IDs do not have to be
                the beans themselves. The container can be used either with explicit item
                IDs or the item IDs can be generated when adding beans.
            </para>

            <para>
                To use explicit item IDs, use the methods <methodname>addItem(Object,
                Object)</methodname>, <methodname>addItemAfter(Object, Object,
                Object)</methodname>, and <methodname>addItemAt(int, Object,
                Object)</methodname>.
            </para>

            <book-example id="datamodel.container.beancontainer.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[// Here is a bean (or more exactly a POJO)
public class BeanBean implements Serializable {
    String name;
    
    public BeanBean(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
}

void basic(VerticalLayout layout) {
    // Create a container for such beans
    BeanContainer<String, BeanBean> beans =
        new BeanContainer<String, BeanBean>(BeanBean.class);
    
    // Use the name property as the item ID of the bean
    beans.setBeanIdProperty("name");

    // Add some beans to it
    beans.addBean(new BeanBean("Moth bean"));
    beans.addBean(new BeanBean("Chickpea", 686.0));
    beans.addBean(new BeanBean("Lentil"));
    beans.addBean(new BeanBean("Common bean"));
    beans.addBean(new BeanBean("Soybean"));

    // Bind a table to it
    Table table = new Table("Beans of All Sorts", beans);
    layout.addComponent(table);
}]]></programlisting>
            
            <para>
                It is not possible to add additional properties to the container and
                nested bean properties are not supported.
            </para>

            <section xml:id="datamodel.container.beancontainer.idresolver">
                <title>Defining a Bean ID Resolver</title>

                <para>
                    If a bean ID resolver is set using
                    <methodname>setBeanIdResolver()</methodname> or
                    <methodname>setBeanIdProperty()</methodname>, the methods
                    <methodname>addBean()</methodname>,
                    <methodname>addBeanAfter()</methodname>,
                    <methodname>addBeanAt()</methodname> and
                    <methodname>addAll()</methodname> can be used to add items to the
                    container. If one of these methods is called, the resolver is used to
                    generate an identifier for the item (must not return null).
                </para>

                <para>
                    Note that explicit item identifiers can also be used when a resolver has
                    been set by calling the <methodname>addItem*()</methodname> methods - the
                    resolver is only used when adding beans using the
                    <methodname>addBean*()</methodname> or
                    <methodname>addAll(Collection)</methodname> methods.
                </para>
            </section>
        </section>

        <section>
            <title>Iterating Over a Container</title>

            <para>
                As the items in a <classname>Container</classname> are not necessarily
                indexed, iterating over the items has to be done using an
                <classname>Iterator</classname>. The <methodname>getItemIds()</methodname>
                method of <classname>Container</classname> returns a
                <classname>Collection</classname> of item identifiers over which you can
                iterate. The following example demonstrates a typical case where you
                iterate over the values of check boxes in a column of a
                <classname>Table</classname> component. The context of the example is the
                example used in <xref linkend="components.table"/>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Collect the results of the iteration into this string.
String items = "";

// Iterate over the item identifiers of the table.
for (Iterator i = table.getItemIds().iterator(); i.hasNext();) {
    // Get the current item identifier, which is an integer.
    int iid = (Integer) i.next();
    
    // Now get the actual item from the table.
    Item item = table.getItem(iid);
    
    // And now we can get to the actual checkbox object.
    Button button = (Button)
            (item.getItemProperty("ismember").getValue());
    
    // If the checkbox is selected.
    if ((Boolean)button.getValue() == true) {
        // Do something with the selected item; collect the
        // first names in a string.
        items += item.getItemProperty("First Name")
                     .getValue() + " ";
    }
}

// Do something with the results; display the selected items.
layout.addComponent (new Label("Selected items: " + items));]]></programlisting>

            <para>
                Notice that the <methodname>getItemIds()</methodname> returns an
                <emphasis>unmodifiable collection</emphasis>, so the
                <classname>Container</classname> may not be modified during iteration. You
                can not, for example, remove items from the
                <classname>Container</classname> during iteration. The modification
                includes modification in another thread. If the
                <classname>Container</classname> is modified during iteration, a
                <classname>ConcurrentModificationException</classname> is thrown and the
                iterator may be left in an undefined state.
            </para>
        </section>

	</section>

<!-- TODO more/examples on IndexedContainer and BeanItemContainer? -->

<!--
    <section xml:id="datamodel.querycontainer">
        <title>QueryContainer for Database Queries</title>

        <para>
            The <classname>QueryContainer</classname> allows you to
            bind UI components, such as <classname>Table</classname>
            and <classname>Select</classname> directly to database
            queries.
        </para>


        <section>
            <title>QueryContainer with Select</title>

            <para>
            </para>

            <programlisting><![CDATA[]]></programlisting>

            <programlisting><![CDATA[]]></programlisting>

        </section>
    </section>
-->
	<!-- section>
		<title>Change notification</title>

		<para>
		</para>
	</section -->
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

