<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="portal">
    <title>Portal Integration</title>

    <indexterm xml:id="term.portal" class="startofrange"><primary>portal integration</primary></indexterm>

    <para>
        Vaadin supports running applications as portlets, as defined in the JSR-168 (Java
        Portlet API) and JSR-286 (Java Portlet API 2.0) standards. While providing generic
        support for all portals implementing the standards, Vaadin especially supports the
        Liferay portal and the needed portal-specific configuration is given below for
        Liferay.
    </para>

    <para>
        You can deploy the Vaadin demo package WAR (available from the download site)
        directly to a portal such as Liferay. It contains all the necessary portlet
        configuration files. For optimal performance with Liferay, you can install the
        Vaadin library and other needed resources in Liferay as described later in this
        section.
    </para>

    <para>
        You can find more documentation and examples from the Vaadin Developer's Site at
        <uri>http://dev.vaadin.com/</uri>.
    </para>

    <section>
        <title>Deploying to a Portal</title>

        <para>
            Deploying a Vaadin application as a portlet is essentially just as easy as
            deploying a regular application to an application server. You do not need to
            make any changes to the application itself, but only the following:
        </para>

        <itemizedlist spacing="compact">
            <listitem><para>Application packaged as a WAR</para>
                <itemizedlist spacing="compact" mark="disc">
                    <listitem><para><filename>WEB-INF/portlet.xml</filename> descriptor</para></listitem>
                    <listitem><para><filename>WEB-INF/web.xml</filename> descriptor for Portlet 1.0 portlets</para></listitem>
                    <listitem><para><filename>WEB-INF/liferay-portlet.xml</filename> descriptor for Liferay</para></listitem>
                    <listitem><para><filename>WEB-INF/liferay-display.xml</filename> descriptor for Liferay</para></listitem>
                    <listitem><para><filename>WEB-INF/liferay-plugin-package.properties</filename> for Liferay</para></listitem>
                </itemizedlist>
            </listitem>
            
            <listitem>Widget set installed to portal (optional)</listitem>
            <listitem>Themes installed to portal (optional)</listitem>
            <listitem>Vaadin library installed to portal (optional)</listitem>
            <listitem>Portal configuration settings (optional)</listitem>
        </itemizedlist>

        <para>
            Installing the widget set and themes to the portal is required for running two
            or more Vaadin portlets simultaneously in a single portal page. As this
            situation occurs quite easily, we recommend installing them in any case.
        </para>

        <para>
            In addition to the Vaadin library, you will need to copy the
            <filename>portlet.jar</filename> to your project. It is included in the Vaadin
            installation package. Notice that you must <emphasis>not</emphasis> put the
            <filename>portlet.jar</filename> in the same
            <filename>WebContent/WEB-INF/lib</filename> directory as the Vaadin JAR or
            otherwise include it in the WAR to be deployed, because it would create a
            conflict with the internal portlet library of the portal.
        </para>

        <para>
            How you actually deploy a WAR package depends on the portal. In Liferay, you
            simply drop it to the <filename>deploy</filename> subdirectory under the
            Liferay installation directory. The deployment depends on the application
            server under which Liferay runs; for example, if you use Liferay bundled with
            Tomcat, you will find the extracted package in the
            <filename>webapps</filename> directory under the Tomcat installation directory
            included in Liferay.
        </para>
    </section>

    <section xml:id="portal.eclipse">
        <title>Creating a Portal Application Project in Eclipse</title>

        <para>
            While you can create the needed deployment descriptors manually for any
            existing Vaadin application, as described in subsequent sections, the Vaadin
            Plugin for Eclipse provides a wizard for easy creation of portal application
            projects.
        </para>

        <para>
            Creation of a portal application project is almost identical to the creation
            of a regular application project. For a full treatment of the New Project
            Wizard and the possible options, please see <xref
            linkend="getting-started.first-project.creation"/>.
        </para>

        <orderedlist>
            <listitem>
                Start creating a new project by selecting from the menu
                <menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guimenuitem>Project...</guimenuitem></menuchoice>.
            </listitem>

            <?dbfo-need height="8cm" ?>
            <listitem>
                In the <guilabel>New Project</guilabel> window that opens, select
                <menuchoice><guimenu>Web</guimenu><guimenuitem>Vaadin
                Project</guimenuitem></menuchoice> and click <guibutton>Next</guibutton>.
            </listitem>

            <?dbfo-need height="8cm" ?>
            <listitem>
                <para>
                    In the <guilabel>Vaadin Project</guilabel> step, you need to set
                    the basic web project settings. You need to give at least the
                    project name, the runtime, and select <guilabel>Generic
                        Portlet</guilabel> for the deployment configuration; the default
                    values should be good for the other settings.
                </para>

                <screenshot>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/eclipse/project-new-portlet-1.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="70" smallscale="100%" align="center" fileref="img/eclipse/project-new-portlet-1.png"/>
                        </imageobject>
                    </mediaobject>
                </screenshot>

                <para>
                    You can click <guibutton>Finish</guibutton> here to use the defaults
                    for the rest of the settings, or click <guibutton>Next</guibutton>.
                </para>

            </listitem>

            <?dbfo-need height="8cm" ?>
            <listitem>
                <para>
                    The settings in the <guilabel>Web Module</guilabel> step define the
                    basic servlet-related settings and the structure of the web
                    application project. All the settings are pre-filled, and you should
                    normally accept them as they are and click
                    <guibutton>Next</guibutton>.
                </para>
            </listitem>

            <?dbfo-need height="8cm" ?>
            <listitem>
                <para>
                    The <guilabel>Vaadin project</guilabel> step page has various
                    Vaadin-specific application settings. These are largely the same as
                    for regular applications. You should not need to change anything as
                    you can change the application titles and other details
                    afterwards. The <guilabel>Create portlet template</guilabel> option
                    should be automatically selected. You can give another portlet title
                    of you want. You can change most of the settings afterward.
                </para>
				
                <screenshot>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/eclipse/project-new-portlet-3.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="50" smallscale="100%" align="center" fileref="img/eclipse/project-new-portlet-3.png"/>
                        </imageobject>
                    </mediaobject>
                </screenshot>

                <variablelist>
                    <varlistentry>
                        <term><guilabel>Create project template</guilabel></term>
                        <listitem>
                            <para>
                                Creates an application class and all the needed portlet
                                deployment descriptors.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Application name</guilabel></term>
                        <listitem>
                            <para>
                                The application name is used in the title of the main
                                window (which is usually invisible in portlets) and as an
                                identifier, either as is or with a suffix, in various
                                deployment descriptors.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Base package name</guilabel></term>
                        <listitem>
                            <para>
                                Java package for the application class.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Application class name</guilabel></term>
                        <listitem>
                            <para>
                                Name of the application class. The default is derived from
                                the project name.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Portlet version</guilabel></term>
                        <listitem>
                            <para>
                                Same as in the project settings.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Portlet title</guilabel></term>
                        <listitem>
                            <para>
                                The portlet title, defined in
                                <filename>portlet.xml</filename>, can be used as the
                                display name of the portlet (at least in Liferay). The
                                default value is the project name. The title is also used
                                as a short description in
                                <filename>liferay-plugin-package.properties</filename>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guilabel>Vaadin version</guilabel></term>
                        <listitem>
                            <para>
                                Same as in the project settings.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    Finally, click <guibutton>Finish</guibutton> to create the project.
                </para>
            </listitem>

            <listitem>
                <para>
                    Eclipse may ask you to switch to J2EE perspective. A Dynamic Web
                    Project uses an external web server and the J2EE perspective provides
                    tools to control the server and manage application deployment. Click
                    <guibutton>Yes</guibutton>.
                </para>
            </listitem>
        </orderedlist>
    </section>

    <section>
        <title>Portlet Deployment Descriptors</title>

        <para>
            To deploy a portlet WAR in a portal, you need to provide the basic
            <filename>portlet.xml</filename> descriptor specified in the Java Portlet
            standard. In addition, you may need to include possible portal vendor specific
            deployment descriptors. The ones required by Liferay are described below.
        </para>

        <simplesect>
            <title>Portlet 2.0 Deployment Descriptor</title>

            <para>
                The portlet WAR must include a portlet descriptor located at
                <filename>WebContent/WEB-INF/portlet.xml</filename>. A portlet definition
                includes the portlet name, mapping to a servlet in
                <filename>web.xml</filename>, modes supported by the portlet, and other
                configuration. Below is an example of a simple portlet definition in
                <filename>portlet.xml</filename> descriptor.
            </para>

            <programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;portlet-app
  xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="2.0"
  xsi:schemaLocation=
    "http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd
     http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd"&gt;

  &lt;portlet&gt;
    &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;
    &lt;display-name&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;

    &lt;!-- Map portlet to a servlet. --&gt;
    &lt;portlet-class&gt;
      com.vaadin.terminal.gwt.server.ApplicationPortlet2
    &lt;/portlet-class&gt;
    &lt;init-param&gt;
      &lt;name&gt;application&lt;/name&gt;

      &lt;!-- The application class with package name. --&gt;
      &lt;value&gt;<emphasis role="bold">com.example.myportlet.MyportletApplication</emphasis>&lt;/value&gt;
    &lt;/init-param&gt;

    &lt;!-- Supported portlet modes and content types. --&gt;
    &lt;supports&gt;
      &lt;mime-type&gt;text/html&lt;/mime-type&gt;
      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;
    &lt;/supports&gt;

    &lt;!-- Not always required but Liferay requires these. --&gt;
    &lt;portlet-info&gt;
      &lt;title&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/title&gt;
      &lt;short-title&gt;<emphasis role="bold">Portlet Example</emphasis>&lt;/short-title&gt;
    &lt;/portlet-info&gt;
  &lt;/portlet&gt;
&lt;/portlet-app&gt;</programlisting>

            <para>
                Listing supported portlet modes in <filename>portlet.xml</filename>
                enables the corresponding portlet controls in the portal user interface
                that allow changing the mode, as described later.
            </para>
        </simplesect>

        <simplesect>
            <title>Portlet 1.0 Deployment Descriptor</title>

            <para>
                The portlet deployment descriptor for Portlet 1.0 API is largely the same
                as for Portlet 2.0. The main differences are:
            </para>

            <orderedlist>
                <listitem><para>XML namespace and schema names</para></listitem>

                <listitem><para>Portlet-class: <classname>ApplicationPortlet</classname> vs
                        <classname>ApplicationPortlet2</classname></para></listitem>

                <listitem><para>The <literal>application</literal> parameter is a name of
                the servlet (defined in <filename>web.xml</filename> in Portlet 1.0, but
                name of the application class in Portlet 2.0. There is no longer a
                separate <filename>web.xml</filename> file in Servlet
                2.0.</para></listitem>

                <listitem><para>The <literal>portlet-name</literal> must not be same as
                the servlet name in Portlet 1.0; in Portlet 2.0 this does not
                matter.</para></listitem>
            </orderedlist>

            <para>
                Below is an example of a complete deployment descriptor for Portlet 1.0:
            </para>

            <programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;portlet-app
  version="1.0"
  xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation=
       "http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd
        http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"&gt;

  &lt;portlet&gt;
    &lt;!-- Must not be the same as servlet name. --&gt;
    &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;
    &lt;display-name&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;

    &lt;!-- Map portlet to a servlet. --&gt;
    &lt;portlet-class&gt;
      com.vaadin.terminal.gwt.server.ApplicationPortlet
    &lt;/portlet-class&gt;
    &lt;init-param&gt;
      &lt;name&gt;application&lt;/name&gt;

      &lt;!-- Must match the servlet URL mapping in web.xml. --&gt;
      &lt;value&gt;<emphasis role="bold">portletexample</emphasis>&lt;/value&gt;
    &lt;/init-param&gt;

    &lt;!-- Supported portlet modes and content types. --&gt;
    &lt;supports&gt;
      &lt;mime-type&gt;text/html&lt;/mime-type&gt;
      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;
    &lt;/supports&gt;

    &lt;!-- Not always required but Liferay requires these. --&gt;
    &lt;portlet-info&gt;
      &lt;title&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/title&gt;
      &lt;short-title&gt;<emphasis role="bold">Portlet Example</emphasis>&lt;/short-title&gt;
    &lt;/portlet-info&gt;
  &lt;/portlet&gt;
&lt;/portlet-app&gt;</programlisting>

            <para>
                The value of the application parameter must match the context in the
                <literal>&lt;url-pattern&gt;</literal> element in the
                <literal>&lt;servlet-mapping&gt;</literal> in the
                <filename>web.xml</filename> deployment descriptor, without the path
                qualifiers in the pattern. The above example would match the following
                servlet mapping in <filename>web.xml</filename>:
            </para>

            <programlisting><?pocket-size 65% ?>  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Portlet Example&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/<emphasis role="bold">portletexample</emphasis>/&#x2a;&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</programlisting>

            <para>
                In fact, it would also match the <literal>/&#x2a;</literal> mapping.
            </para>
        </simplesect>

        <simplesect>
            <title>Using a Single Widget Set</title>

            <para>
                If you have just one Vaadin application that you ever need to run in your
                portal, you can just deploy the WAR as described above and that's
                it. However, if you have multiple applications, especially ones that use
                different custom widget sets, you run into problems, because a portal
                window can load only a single Vaadin widget set at a time. You can solve
                this problem by combining all the different widget sets in your different
                applications into a single widget set using inheritance or composition.
            </para>

            <para>
                For example, the portal demos defined in the
                <filename>portlet.xml</filename> in the demo WAR have the following
                setting for all portlets so that they will all use the same widget set:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[<portlet>
  ...
  <!-- Use the portal default widget set for all portal demos. -->
  <init-param>
    <name>widgetset</name>
    <value>com.vaadin.portal.gwt.PortalDefaultWidgetSet</value>
  </init-param>
  ...]]></programlisting>

            <para>
                The <classname>PortalDefaultWidgetSet</classname> extends
                <classname>SamplerWidgetSet</classname>, which extends the
                <classname>DefaultWidgetSet</classname>. The
                <classname>DefaultWidgetSet</classname> is therefore essentially a subset
                of <classname>PortalDefaultWidgetSet</classname>, which contains also the
                widgets required by the Sampler demo. Other applications that would
                otherwise require only the regular
                <classname>DefaultWidgetSet</classname>, and do not define their own
                widgets, can just as well use the larger set, making them compatible with
                the demos. The <classname>PortalDefaultWidgetSet</classname> will also be
                the default Vaadin widgetset bundled in Liferay 5.3 and later.
            </para>

            <para>
                If your portlets are contained in multiple WARs, which can happen quite
                typically, you need to install the widget set and theme portal-wide so
                that all the portlets can use them. See <xref
                linkend="advanced.liferay.widgetsets"/> on configuring the widget sets in
                the portal itself.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.liferay.descriptor.liferay-portlet">
            <title>Liferay Portlet Descriptor</title>

            <indexterm xml:id="term.advanced.liferay.descriptor.liferay-portlet.liferay" class="startofrange">
                <primary>Liferay</primary>
                <secondary>portlet descriptor</secondary>
            </indexterm>

            <para>
                Liferay requires a special <filename>liferay-portlet.xml</filename>
                descriptor file that defines Liferay-specific parameters. Especially,
                Vaadin portlets must be defined as "<emphasis>instanceable</emphasis>",
                but not "<emphasis>ajaxable</emphasis>".
            </para>

            <para>
                Below is an example descriptor for the earlier portlet example:
            </para>

            <programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE liferay-portlet-app PUBLIC
  "-//Liferay//DTD Portlet Application 4.3.0//EN"
  "http://www.liferay.com/dtd/liferay-portlet-app_4_3_0.dtd"&gt;

&lt;liferay-portlet-app&gt;
    &lt;portlet&gt;
        &lt;!-- Matches definition in portlet.xml.          --&gt;
        &lt;!-- Note: Must not be the same as servlet name. --&gt;
        &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;

        &lt;instanceable&gt;true&lt;/instanceable&gt;
        &lt;ajaxable&gt;false&lt;/ajaxable&gt;
    &lt;/portlet&gt;
&lt;/liferay-portlet-app&gt;</programlisting>

            <para>
                See Liferay documentation for further details on the
                <filename>liferay-portlet.xml</filename> deployment descriptor.
            </para>

            <indexterm startref="term.advanced.liferay.descriptor.liferay-portlet.liferay" class="endofrange"/>
        </simplesect>

        <simplesect xml:id="advanced.liferay.descriptor.display">
            <title>Liferay Display Descriptor</title>
            <indexterm xml:id="term.advanced.liferay.descriptor.liferay-display" class="startofrange">
                <primary><filename>liferay-display.xml</filename></primary>
            </indexterm>
            <indexterm xml:id="term.advanced.liferay.descriptor.liferay-display.liferay" class="startofrange">
                <primary>Liferay</primary>
                <secondary>display descriptor</secondary>
            </indexterm>
				
            <para>
                The <filename>WEB-INF/liferay-display.xml</filename> file defines the
                portlet category under which portlets are located in the <guilabel>Add
                Application</guilabel> window in Liferay. Without this definition,
                portlets will be organized under the "Undefined" category.
            </para>

            <para>
                The following display configuration, which is included in the demo WAR,
                puts the Vaadin portlets under the "Vaadin" category, as shown in <xref
                linkend="figure.advanced.liferay.descriptor.display"/>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[<?xml version="1.0"?>
<!DOCTYPE display PUBLIC
  "-//Liferay//DTD Display 4.0.0//EN"
  "http://www.liferay.com/dtd/liferay-display_4_0_0.dtd">

<display>
    <category name="Vaadin">
        <portlet id="Portlet Example portlet" />
    </category>
</display>]]></programlisting>

            <figure xml:id="figure.advanced.liferay.descriptor.display">
                <title>Portlet Categories in Add Application Window</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/liferay-display-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/liferay-display-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                See Liferay documentation for further details on how to configure the
                categories in the <filename>liferay-display.xml</filename> deployment
                descriptor.
            </para>

            <indexterm startref="term.advanced.liferay.descriptor.liferay-display" class="endofrange"/>
            <indexterm startref="term.advanced.liferay.descriptor.liferay-display.liferay" class="endofrange"/>
        </simplesect>

        <simplesect>
            <title>Liferay Plugin Package Properties</title>
            
            <indexterm xml:id="term.advanced.liferay.descriptor.liferay-plugin" class="startofrange">
                <primary><filename>liferay-plugin-package.xml</filename></primary>
            </indexterm>
            <indexterm xml:id="term.advanced.liferay.descriptor.liferay-plugin.liferay" class="startofrange">
                <primary>Liferay</primary>
                <secondary>plugin properties</secondary>
            </indexterm>

            <para>
                The <filename>liferay-plugin-package.properties</filename> file defines a
                number of settings for the portlet, most importantly the Vaadin JAR to be
                used.
            </para>

            <programlisting><?pocket-size 75% ?>name=<emphasis role="bold">Portlet Example portlet</emphasis>
short-description=<emphasis role="bold">myportlet</emphasis>
module-group-id=<emphasis role="bold">Vaadin</emphasis>
module-incremental-version=1
#change-log=
#page-uri=
#author=
license=Proprietary
portal-dependency-jars=\
    <emphasis role="bold">vaadin.jar</emphasis></programlisting>

            <variablelist>
                <varlistentry>
                    <term><parameter>name</parameter></term>
                    <listitem>
                        <para>
                            The plugin name must match the portlet name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>short-description</parameter></term>
                    <listitem>
                        <para>
                            A short description of the plugin. This is by default the
                            project name.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term><parameter>module-group-id</parameter></term>
                    <listitem>
                        <para>
                            The application group, same as the category id defined in
                            <filename>liferay-display.xml</filename>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>license</parameter></term>
                    <listitem>
                        <para>
                            The plugin license type; "proprietary" by default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>portal-dependency-jars</parameter></term>
                    <listitem>
                        <para>
                            The JAR libraries on which this portlet depends. This should
                            have value <filename>vaadin.jar</filename>, unless you need to
                            use a specific version. The JAR must be installed in the
                            portal, for example, in Liferay bundled with Tomcat to
                            <filename>tomcat-x.x.x/webapps/ROOT/WEB-INF/lib/vaadin.jar</filename>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
                
            <indexterm startref="term.advanced.liferay.descriptor.liferay-plugin" class="endofrange"/>
            <indexterm startref="term.advanced.liferay.descriptor.liferay-plugin.liferay" class="endofrange"/>
        </simplesect>
    </section>

    <section xml:id="advanced.liferay.helloworld">
        <title>Portlet Hello World</title>

        <para>
            The Hello World program that runs as a portlet is no different from a regular
            Vaadin application, as long as it doesn't need to handle portlet actions, mode
            changes, and so on.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[import com.vaadin.Application;
import com.vaadin.ui.*;

public class PortletExample extends Application {
    @Override 
    public void init() {
        Window mainWindow = new Window("Portlet Example");

        Label label = new Label("Hello Vaadin user");
        mainWindow.addComponent(label);
        setMainWindow(mainWindow);
    }
}]]></programlisting>

        <para>
            In addition to the application class, you need the descriptor files,
            libraries, and other files as described earlier. <xref
            linkend="figure.advanced.liferay.helloworld.project"/> shows the complete
            project structure under Eclipse.
        </para>

        <figure xml:id="figure.advanced.liferay.helloworld.project" float="center" floatstyle="before">
            <title>Portlet Project Structure in Eclipse</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/liferay-project.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="80" smallscale="100%" align="center" fileref="img/advanced/liferay-project.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Installed as a portlet in Liferay from the <guilabel>Add
				Application</guilabel> menu, the application will show as illustrated in
            <xref linkend="figure.advanced.liferay.helloworld"/>.
        </para>

        <figure xml:id="figure.advanced.liferay.helloworld">
            <title>Hello World Portlet</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/liferay-helloworld.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/liferay-helloworld.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

    <section xml:id="advanced.liferay.widgetsets">
        <title>Installing Vaadin in Liferay</title>
			
        <para>
            Loading widget sets, themes, and the Vaadin JAR from a portlet is possible as
            long as you have a single portlet, but causes a problem if you have multiple
            portlets. To solve this, Vaadin portlets need to use a globally installed
            widget set, themes, and Vaadin JAR. They, and all the required configuration,
            are bundled with Liferay 5.3 and later, but if you are using an earlier
            version of Liferay or use a custom widget set, custom themes, or a specific
            version of Vaadin, you will need to do the configuration manually.
        </para>

        <para>
            In these instructions, we assume that you use Liferay bundled with Apache
            Tomcat, although you can use many other application servers with Liferay just
            as well. The Tomcat installation is included in the Liferay installation
            package, under the <filename>tomcat-x.x.x</filename> directory.
        </para>
        
        <para>
            The Vaadin JAR should be put in
            <filename>tomcat-x.x.x/webapps/ROOT/WEB-INF/lib/vaadin.jar</filename>. The
            Vaadin version number should normally be left out from the JAR.
        </para>

        <para>
            The widget set needs to be located at
            <filename>/html/VAADIN/widgetsets/</filename> and themes at
            <filename>/html/VAADIN/themes/</filename> path under the portal context. You
            simply need to copy the contents from under your
            <filename>WebContent/VAADIN</filename> directory to the
            <filename>tomcat-x.x.x/webapps/ROOT/html/VAADIN</filename> directory under the
            Liferay installation directory. If you use a built-in widget set or theme
            included in Vaadin, such as the <classname>PortalDefaultWidgetSet</classname>,
            you should copy it from the Vaadin installation directory, from under
            <filename>WebContent/VAADIN/widgetsets</filename>. The default themes are
            located under <filename>WebContent/VAADIN/themes</filename> in the
            installation directory.
        </para>

        <para>
            You need to define the widget set, the theme, and the JAR in the
            <filename>portal-ext.properties</filename> configuration file for Liferay, as
            described earlier. The file should normally be placed in the Liferay
            installation directory. See Liferay documentation for details on the
            configuration file.
        </para>

        <para>
            Below is an example of a <filename>portal-ext.properties</filename> file:
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[# Path under which the VAADIN directory is located.
# (/html is the default so it is not needed.)
# vaadin.resources.path=/html

# Portal-wide widget set
vaadin.widgetset=com.vaadin.portal.gwt.PortalDefaultWidgetSet

# Theme to use
vaadin.theme=reindeer]]></programlisting>

        <para>
            The allowed parameters are:
        </para>

        <variablelist>
            <varlistentry>
                <term><parameter>vaadin.resources.path</parameter></term>
                <listitem>
                    <para>Specifies the resource root path under the portal context. This
                    is <filename>/html</filename> by default. Its actual location depends
                    on the portal and the application server; in Liferay with Tomcat it
                    would be located at <filename>webapps/ROOT/html</filename> under the
                    Tomcat installation directory.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>vaadin.widgetset</parameter></term>
                <listitem>
                    <para>The widget set class to use. Give the full path to the class
                    name in the dot notation. If the parameter is not given, the default
                    widget set is used.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>vaadin.theme</parameter></term>
                <listitem>
                    <para>Name of the theme to use. If the parameter is not given, the
                    default theme is used, which is <literal>reindeer</literal> in Vaadin
                    6.</para>
                </listitem>
            </varlistentry>
        </variablelist>
	
        <para>
            You will need to restart Liferay after creating or modifying the
            <filename>portal-ext.properties</filename> file.
        </para>
    </section>

    <section>
        <title>Handling Portlet Requests</title>

        <para>
            Portals such as Liferay are not AJAX applications but reload the page every
            time a user interaction requires data from the server. They consider a Vaadin
            application to be a regular web application that works by HTTP requests. All
            the AJAX communications required by the Vaadin application are done by the
            Vaadin Client-Side Engine (the widget set) past the portal, so that the portal
            is unaware of the communications.
        </para>

        <para>
            The only way a portal can interact with an application is to load it with a
            HTTP request; reloading does not reset the application. The Portlet 2.0 API
            supports four types of requests: <emphasis>render</emphasis>,
            <emphasis>action</emphasis>, <emphasis>resource</emphasis>, and
            <emphasis>event</emphasis> requests. The old Portlet 1.0 API supports only the
            render and action requests. Requests can be caused by user interaction with
            the portal controls or by clicking action URLs displayed by the portlet. You
            can handle portlet requests by implementing the
            <classname>PortletListener</classname> interface and the handler methods for
            each of the request types. You can use the request object passed to the
            handler to access certain portal data, such as user information, the portlet
            mode, etc.
        </para>

        <para>
            The <classname>PortletListener</classname> interface is defined in the
            <classname>PortletApplicationContext2</classname> for Portlet 2.0 API and
            <classname>com.vaadin.terminal.gwt.server.PortletApplicationContext</classname>
            class for the old Portlet 1.0 API. You can get the portlet application context
            with <methodname>getContext()</methodname> method of the application class.
        </para>

        <para>
            You need to have the <filename>portlet.jar</filename> in your class path
            during development. However, you must <emphasis>not</emphasis> deploy the
            <filename>portlet.jar</filename> with the portlet, because it would create a
            conflict with the internal portlet library of the portal. You should put it in
            a directory that is not deployed with the portlet, for example, if you are
            using Eclipse, under the <filename>lib</filename> directory under the project
            root, not under <filename>WebContent/WEB-INF/lib</filename>, for example.
        </para>

        <para>
            You can also define portal actions that you can handle in the
            <methodname>handleActionRequest()</methodname> method of the interface.
        </para>

        <para>
            You add your portlet request listener to the application context of your
            application, which is a <classname>PortletApplicationContext</classname> when
            (and only when) the application is being run as a portlet.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[// Check that we are running as a portlet.
if (getContext() instanceof PortletApplicationContext2) {
    PortletApplicationContext2 ctx =
            (PortletApplicationContext2) getContext();

    // Add a custom listener to handle action and
    // render requests.
    ctx.addPortletListener(this, new MyPortletListener());
} else {
    getMainWindow().showNotification(
            "Not initialized via Portal!",
            Notification.TYPE_ERROR_MESSAGE);
}]]></programlisting>

        <para>
            The handler methods receive references to request and response objects, which
            are defined in the Java Servlet API. Please refer to the Servlet API
            documentation for further details.
        </para>

        <para>
            The PortletDemo application included in the demo WAR package includes examples
            of processing mode and portlet window state changes in a portlet request
            listener.
        </para>
    </section>

    <section xml:id="portal.portlet-mode">
        <title>Handling Portlet Mode Changes</title>

        <para>
            Portals support three portlet modes defined in the Portlet API:
            <emphasis>view</emphasis>, <emphasis>edit</emphasis>, and
            <emphasis>help</emphasis> modes. The <emphasis>view</emphasis> mode is the
            default and the portal can have buttons to switch the portlet to the other
            modes. In addition to the three predefined modes, the Portlet API standards
            allow custom portlet modes, although portals may support custom modes to a
            varying degree.
        </para>

        <para>
            You need to define which portlet modes are enabled in the
            <filename>portlet.xml</filename> deployment descriptor as follows.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[<!-- Supported portlet modes and content types. -->
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>edit</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>

        <para>
            Changes in the portlet mode are received as resource requests, which you can
            handle with a <methodname>handleResourceRequest()</methodname>, defined in the
            <classname>PortletListener</classname> interface. The current portlet mode can
            be acquired with <methodname>getPortletMode()</methodname> from the request
            object.
        </para>

        <para>
            The following complete example (for Portlet 2.0) shows how to handle the three
            built-modes in a portlet application.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
import com.vaadin.terminal.gwt.server.PortletApplicationContext2;
import com.vaadin.terminal.gwt.server.PortletApplicationContext2.PortletListener;

public class PortletModeExample extends Application
                                implements PortletListener {
    Window         mainWindow;
    ObjectProperty data; // Data to view and edit
    VerticalLayout viewContent   = new VerticalLayout();
    VerticalLayout editContent   = new VerticalLayout();
    VerticalLayout helpContent   = new VerticalLayout();
    
    @Override
    public void init() {
        mainWindow = new Window("Myportlet Application");
        setMainWindow(mainWindow);

        // Data model
        data = new ObjectProperty("<h1>Heading</h1>"+
                       "<p>Some example content</p>");

        // Prepare views for the three modes (view, edit, help)
        // Prepare View mode content
        Label viewText = new Label(data, Label.CONTENT_XHTML);
        viewContent.addComponent(viewText);

        // Prepare Edit mode content
        RichTextArea editText = new RichTextArea();
        editText.setCaption("Edit the value:");
        editText.setPropertyDataSource(data);
        editContent.addComponent(editText);

        // Prepare Help mode content
        Label helpText = new Label("<h1>Help</h1>" +
                                   "<p>This helps you!</p>",
                                   Label.CONTENT_XHTML);
        helpContent.addComponent(helpText);

        // Start in the view mode
        mainWindow.setContent(viewContent);

        // Check that we are running as a portlet.
        if (getContext() instanceof PortletApplicationContext2) {
            PortletApplicationContext2 ctx =
                (PortletApplicationContext2) getContext();

            // Add a custom listener to handle action and
            // render requests.
            ctx.addPortletListener(this, this);
        } else {
            mainWindow.showNotification("Not running in portal",
                               Notification.TYPE_ERROR_MESSAGE);
        }
    }

    // Dummy implementations for the irrelevant request types
    public void handleActionRequest(ActionRequest request,
                                    ActionResponse response,
                                    Window window) {
    }
    public void handleRenderRequest(RenderRequest request,
                                    RenderResponse response,
                                    Window window) {
    }
    public void handleEventRequest(EventRequest request,
                                   EventResponse response,
                                   Window window) {
    }

    public void handleResourceRequest(ResourceRequest request,
                                      ResourceResponse response,
                                      Window window) {
        // Switch the view according to the portlet mode
        if (request.getPortletMode() == PortletMode.EDIT)
            window.setContent(editContent);
        else if (request.getPortletMode() == PortletMode.VIEW)
            window.setContent(viewContent);
        else if (request.getPortletMode() == PortletMode.HELP)
            window.setContent(helpContent);
    }
}]]></programlisting>

        <para>
            <xref linkend="figure.portal.portlet-mode"/> shows the resulting
            portlet in the three modes: view, edit, and help. In Liferay, the edit
            mode is shown in the popup menu as a <guilabel>Preferences</guilabel> item.
        </para>

        <figure xml:id="figure.portal.portlet-mode">
            <title>Portlet Modes in Action</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/portal-mode-view.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-view.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/portal-mode-edit.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-edit.png"/>
                </imageobject>
            </mediaobject>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/portal-mode-help.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-help.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

    <section xml:id="portal.portlet-html-mode">
        <title>Non-Vaadin Portlet Modes</title>

        <para>
            In some cases, it can be useful to implement certain modes of a portlet as
            pure HTML or JSP pages instead of running the full Vaadin application user
            interface in them. Common reasons for this are static pages (for example, a
            simple help mode), integrating legacy content to a portlet (for example, a JSP
            configuration interface), and providing an ultra-lightweight initial view for
            a portlet (for users behind slow connections).
        </para>
            
        <para>
            Fully static modes that do not require the Vaadin server side application to
            be running can be implemented by subclassing the portlet class
            <classname>ApplicationPortlet2</classname> (Portlet 2.0).  The subclass can
            either create the HTML content directly or dispatch the request to, for
            example, a HTML or JSP page via the portal. When using this approach, any
            Vaadin portlet and portlet request listeners are not called.
        </para>
            
        <para>
            Customizing the content for the standard modes (<emphasis>view</emphasis>,
            <emphasis>edit</emphasis>, and <emphasis>help</emphasis>) can be performed by
            overriding the methods <methodname>doView</methodname>,
            <methodname>doEdit</methodname> and <methodname>doHelp</methodname>,
            respectively. Custom modes can be handled by implementing similar methods with
            the <classname>@javax.portlet.RenderMode(name = "mymode")</classname>
            annotation.
        </para>

        <para>
            You need to define which portlet modes are enabled in the
            <filename>portlet.xml</filename> deployment descriptor as described in <xref
            linkend="portal.portlet-mode"/>. Also, the portlet class in
            <filename>portlet.xml</filename> should point to the customized subclass of
            <classname>ApplicationPortlet2</classname>.
        </para>

        <para>
            The following example (for Portlet 2.0) shows how to create a static help page
            for the portlet.
        </para>
            
        <para>
            <filename>portlet.xml</filename>:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[<!-- Supported portlet modes and content types. -->
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>
            
        <para>
            <filename>HtmlHelpPortlet.java:</filename>:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
import com.vaadin.terminal.gwt.server.ApplicationPortlet2;

public class HtmlHelpPortlet extends ApplicationPortlet2 {
    // Override the help mode, let the Vaadin
    // application handle the view mode
    @Override
    protected void doHelp(RenderRequest request,
                          RenderResponse response)
            throws PortletException, IOException {
        // Bypass the Vaadin application entirely
        response.setContentType("text/html");
        response.getWriter().println(
                "This is the help text as plain HTML.");

        // Alternatively, you could use the dispatcher for,
        // for example, JSP help pages as follows:
        // PortletRequestDispatcher dispatcher = getPortletContext()
        // .getRequestDispatcher("/html/myhelp.jsp");
        // dispatcher.include(request, response);
    }
}]]></programlisting>

        <para>
            To produce pure HTML portlet content from a running Vaadin application instead
            of statically outside an application, the
            <classname>ApplicationPortlet2</classname> method
            <methodname>writeAjaxPage</methodname> should be overridden.  This approach
            allows using the application state in HTML content generation, and all
            relevant Vaadin portlet request and portlet listeners are called around the
            portlet content generation. However, the client side engine (widgetset) is not
            loaded by the browser, which can shorten the initial page display time.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[<portlet-class>com.vaadin.demo.portlet.HtmlModePortlet</portlet-class>
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>

        <programlisting><?pocket-size 65% ?><![CDATA[public class CountApplication extends Application {
    private int count = 0;
    
    public void init() {
        Window w = new Window("Portlet mode example");
        w.addComponent(new Label("This is the Vaadin app."));
        w.addComponent(new Label("Try opening the help mode."));
        setMainWindow(w);
    }
        
    public int incrementCount() {
        return ++count;
    }
}]]></programlisting>

        <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
public class HtmlModePortlet extends AbstractApplicationPortlet {

    @Override
    protected void writeAjaxPage(RenderRequest request,
            RenderResponse response, Window window,
            Application app)
                throws PortletException, IOException {
        if (PortletMode.HELP.equals(request.getPortletMode())) {
            CountApplication capp = (CountApplication) app;
            response.setContentType("text/html");
            response.getWriter().println(
                "This is the HTML help, shown "
                + capp.incrementCount() + " times so far.");
        } else {
            super.writeAjaxPage(request, response, window, app);
        }
    }
    
    @Override
    protected Class<? extends Application> getApplicationClass(){
        return CountApplication.class;
    }
}]]></programlisting>

        <para>
            The user can freely move between Vaadin and non-Vaadin portlet modes with the
            user interface provided by the portal (for standard modes) or the portlet (for
            example, action links). Once the server side application has been started, it
            continues to run as long as the session is alive.  If necessary, specific
            portlet mode transitions can be disallowed in
            <filename>portlet.xml</filename>.
        </para>

        <para>
            In the case of Portlet 1.0, both a portlet and a servlet are involved.  A
            render request is received by <classname>ApplicationPortlet</classname> when
            the portlet mode is changed, and serving pure HTML in some modes can be
            achieved by overriding the method <methodname>render</methodname> and handling
            the modes of interest separately while calling
            <methodname>super.render()</methodname> for other modes. As always, when
            extending the portlet, the reference to the portlet class in
            <filename>portlet.xml</filename> needs to be updated.
        </para>
            
        <para>
            To serve HTML-only content in the Portlet 1.0 case after starting the server
            side application and calling the relevant listeners, the servlet class
            <classname>ApplicationServlet</classname> should be subclassed instead of the
            portlet. The method <methodname>writeAjaxPage</methodname> can be overridden
            to produce custom HTML content for certain modes. However, it should be noted
            that some HTML content (for example, loading the portal-wide Vaadin theme) is
            created by the portlet and not the servlet.
        </para>
    </section>

    <section xml:id="portal.control-panel">
        <title>Vaadin Control Panel for Liferay</title>

        <para>
            Vaadin portlets, just as all Vaadin applications, use a <emphasis>widget
            set</emphasis> to render the user interface in the browser and to handle the
            Ajax communication with the server-side application. While regular Vaadin
            applications use a widget set for each application, in portals the widget set
            is shared by all Vaadin portlets running in the portal. Liferay actually comes
            preinstalled with a precompiled version of the default portal widget
            set. However, many add-on components come with their own widget set, which
            needs to be compiled into the portal widget set. The Vaadin Control Panel for
            Liferay automates this compilation. You can also use it to just install a new
            version of the Vaadin library.
        </para>

        <section xml:id="portal.control-panel.installing">
            <title>Installing</title>

            <para>
                Vaadin Control Panel for Liferay is available for download from Vaadin
                Directory. It is a WAR package, which you need to simply drop into Liferay's
                <filename>deploy</filename> folder. Once the deployment is done, the Vaadin
                Control Panel should show up in the Liferay Control Panel.
            </para>
        </section>

        <section xml:id="portal.control-panel.using">
            <title>Using the Control Panel</title>

            <para>
                Open the <guilabel>Vaadin</guilabel> section in the Liferay Control Panel.
                The initial state with is illustrated in <xref
                linkend="figure.portal.control-panel.using.initial"/>.
            </para>

            <figure xml:id="figure.portal.control-panel.using.initial">
                <title>Initial State of Vaadin Control Panel for Liferay</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/portal/liferay-control-panel-1.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section xml:id="portal.control-panel.using.upgrade">
                <title>Upgrading Vaadin</title>

                <para>
                    Liferay comes with Vaadin preinstalled. To upgrade the preinstalled
                    version to a newer one, follow the following steps. Notice that the
                    Vaadin library is upgraded for <emphasis>all</emphasis> Vaadin
                    portlets, so they must all be compatible with the new version.
                </para>

                <orderedlist>
                    <listitem>
                        <para>
                            Click <guibutton>Upgrade</guibutton> in the <guilabel>Vaadin
                            Jar Version</guilabel>.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            In the warning dialog that appears, read the message and if
                            you want to go on with the upgrade, click <guibutton>Change
                            version</guibutton> to proceed.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Recompile the widget set as instructed below.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Redeploy all Vaadin portlets in Liferay, that is, copy the
                            WARs to the <filename>deploy</filename> folder in Liferay.
                        </para>
                    </listitem>
                </orderedlist>

                <para>
                    The Google Web Toolkit (GWT) libraries required for the widget set
                    compilation are also upgraded automatically.
                </para>
            </section>

            <section xml:id="portal.control-panel.using.compile">
                <title>Compiling Widget Set</title>

                <para>
                    When you need to compile the widget set, follow the following steps:
                </para>

                <orderedlist>
                    <listitem>
                        <para>
                            Place any add-on Jars containing widget sets, such as add-on
                            Jars, in the <filename>WEB-INF/lib</filename> folder of
                            Liferay. Its exact location depends on the used server; for
                            example in Tomcat it is under the
                            <filename>webapps/ROOT</filename> folder.
                        </para>
                    </listitem>                        
                    <listitem>
                        <para>
                            Click <guibutton>re-scan</guibutton> in the <guilabel>Add-on
                            Directory</guilabel> to detect any new add-on libraries.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Select the add-ons which you wish to compile into the widget
                            set.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Click <guibutton>Manage Additional Dependencies</guibutton> if
                            the libraries require any special libraries and add them.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Click <guibutton>Compile Widget Set</guibutton> to compile the
                            widget set. The compilation can take several minutes.
                        </para>
                    </listitem>
                </orderedlist>

                <para>
                    The compiled widget set is copied automatically to the proper folder
                    and taken into use.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="portal.liferay-ipc">
        <title>Vaadin IPC for Liferay</title>

        <indexterm xml:id="term.portal.liferay-ipc" class="startofrange"><primary>IPC add-on</primary></indexterm>

        <para>
            Portlets rarely live alone. A page can contain multiple portlets and when the
            user interacts with one portlet, you may need to have the other portlets react
            to the change immediately. This is not normally possible with Vaadin portlets,
            as Vaadin applications need to get an Ajax request from the client-side to
            change their user interface. On the other hand, the regular inter-portlet
            communication (IPC) mechanism in Portlet 2.0 Specification requires a complete
            page reload, but that is not appropriate with Vaadin or in general Ajax
            applications, which do not require a page reload. One solution is to
            communicate between the portlets on the server-side and then use a server-push
            mechanism to update the client-side.
        </para>

        <para>
            The Vaadin IPC for Liferay Add-on takes another approach by communicating
            between the portlets through the client-side. Events (messages) are sent
            through the <classname>LiferayIPC</classname> component and the client-side
            widget relays them to the other portlets, as illustrated in <xref
            linkend="figure.portal.liferay-ipc.architecture"/>.
        </para>

        <figure xml:id="figure.portal.liferay-ipc.architecture">
            <title>Vaadin IPC for Liferay Architecture</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/portal/liferay-ipc-architecture-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata smallscale="80%" align="center" fileref="img/portal/liferay-ipc-architecture-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Vaadin IPC for Liferay uses the Liferay JavaScript event API for client-side
            inter-portlet communication, so you can communicate just as easily with other
            Liferay portlets.
        </para>

        <para>
            Notice that you can use this communication only between portlets on the same
            page.
        </para>

        <para>
            <xref linkend="figure.portal.liferay-ipc.demo"/> shows Vaadin IPC for Liferay
            in action.  Entering a new item in one portlet is updated interactively in the
            other.
        </para>

        <figure xml:id="figure.portal.liferay-ipc.demo">
            <title>Vaadin IPC Add-on Demo with Two Portlets</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="100%" align="center" fileref="img/portal/liferay-ipc-demo-annotated-lo.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <section xml:id="portal.liferay-ipc.installation">
            <title>Installing the Add-on</title>

            <para>
                The Vaadin IPC for Liferay add-on is available from the Vaadin Directory
                as well as from a Maven repository, as described in <xref
                linkend="addons"/>.
            </para>

            <?dbfo-need height="3cm" ?>
            <para>
                The contents of the installation package are as follows:
            </para>

            <variablelist>
                <varlistentry>
                    <term><filename>vaadin-ipc-for-liferay-x.x.x.jar</filename></term>
                    <listitem>
                        The add-on JAR in the installation package must be installed in
                        the <filename>WEB-INF/lib</filename> directory under the root
                        context. The location depends on the server - for example in
                        Liferay running in Tomcat it is located under the
                        <filename>webapps/ROOT</filename> folder of the server.
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>doc</filename></term>
                    <listitem>
                        The documentation folder includes a
                        <filename>README.TXT</filename> file that describes the contents
                        of the installation package briefly, and
                        <filename>licensing.txt</filename> and
                        <filename>license-asl-2.0.txt</filename>, which describe the
                        licensing under the Apache License 2.0. Under the
                        <filename>doc/api</filename> folder is included the complete
                        JavaDoc API documentation for the add-on.
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>vaadin-ipc-for-liferay-x.x.x-demo.war</filename></term>
                    <listitem>
                        A WAR containing demo portlets. After installing the add-on
                        library and compiling the widget set, as described below, you can
                        deploy the WAR to Liferay and add the two demo portlets to a page,
                        as shown in <xref linkend="figure.portal.liferay-ipc.demo"/>. The
                        source of the demo is available at <link
                        xlink:href="http://dev.vaadin.com/svn/addons/IPCforLiferay/trunk/demo/src/com/vaadin/addon/ipcforliferay/demo/">dev.vaadin.com/svn/addons/IPCforLiferay/trunk/</link>.
                    </listitem>
                </varlistentry>
            </variablelist>

            <simplesect xml:id="portal.liferay-ipc.installation.demo">
                <title>Compiling the Widget Set</title>

                <para>
                    The add-on contains a widget set, which you must compile into the Vaadin widget
                    set installed in the portal. The easiest way you can do this is to use the
                    Vaadin Control Panel for Liferay to compile the portal widget set, as
                    described in <xref linkend="portal.control-panel"/>.
                </para>
            </simplesect>
        </section>

        <section xml:id="portal.liferay-ipc.communication">
            <title>Basic Communication</title>

            <para>
                <classname>LiferayIPC</classname> is an invisible user interface component
                that can be used to send messages between two or more Vaadin portlets. You
                add it to an application layout as you would any regular user interface
                component.
            </para>

            <programlisting><![CDATA[LiferayIPC liferayipc = new LiferayIPC();
layout.addComponent(liferayipc);]]></programlisting>

            <para>
                You should be careful not to remove the invisible component from the
                portlet later if you modify the layout of the portlet.
            </para>

            <para>
                The component can be used both for sending and receiving messages, as
                described next.
            </para>

            <simplesect xml:id="portal.liferay-ipc.communication.sending">
                <title>Sending Events</title>

                <para>
                    You can send an event (a message) with the
                    <methodname>sendEvent()</methodname> method, which takes an event ID
                    and the message data as parameters. The event is broadcast to all
                    listening portlets. The event ID is a string that can be used to
                    identify the recipient of an event or the event type.
                </para>

                <programlisting><![CDATA[liferayipc.sendEvent("hello", "This is Data");]]></programlisting>

                <para>
                    If you need to send more complex data, you need to format or serialize
                    it to a string representation as described in <xref
                    linkend="portal.liferay-ipc.serialization"/>.
                </para>
            </simplesect>

            <simplesect xml:id="portal.liferay-ipc.communication.receiving">
                <title>Receiving Events</title>

                <para>
                    A portlet wishing to receive events (messages) from other portlets
                    needs to register a listener in the component with
                    <methodname>addListener()</methodname>. The listener receives the
                    messages in a <classname>LiferayIPCEvent</classname> object. Filtering
                    events by the ID is built in into the listener handler, you give the
                    listened event ID as the first parameter for the
                    <methodname>addListener()</methodname>. The actual message data is
                    held in the <parameter>data</parameter> property, which you can read
                    with <methodname>getData()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[liferayipc.addListener("hello", new LiferayIPCEventListener() {
    public void eventReceived(LiferayIPCEvent event) {
        // Do something with the message data
        String data = event.getData();
        getWindow().showNotification(
           "Received hello: " + data);
    }
});]]></programlisting>

                <para>
                    A listener added to a <classname>LiferayIPC</classname> can be removed
                    with <methodname>removeListener()</methodname>.
                </para>
            </simplesect>
        </section>

        <section xml:id="portal.liferay-ipc.concerns">
            <title>Considerations</title>

            <para>
                Both security and efficiency should be considered with inter-portlet
                communications when using the Vaadin IPC for Liferay.
            </para>

            <section xml:id="portal.liferay-ipc.concerns.security">
                <title>Browser Security</title>

                <para>
                    As the message data is passed through the client-side (browser), any
                    code running in the browser has access to the data. You should be
                    careful not to expose any security-critical data in client-side
                    messaging. Also, malicious code running in the browser could alter or
                    fake messages. Sanitization can help with the latter problem and
                    encryption to solve the both issues. You can also share the sensitive
                    data through session attributes or a database and use the client-side
                    IPC only to notify that the data is available.
                </para>
            </section>

            <section xml:id="portal.liferay-ipc.concerns.efficiency">
                <title>Efficiency</title>

                <para>
                    Sending data through the browser requires loading and sending it in
                    HTTP requests. The data is held in the memory space of the browser,
                    and handling large data in the client-side JavaScript code can take
                    time. Noticeably large message data can therefore reduce the
                    responsiveness of the application and could, in extreme cases, go over
                    browser limits for memory consumption or JavaScript execution time.
                </para>
            </section>
        </section>

        <section xml:id="portal.liferay-ipc.attributes">
            <title>Communication Through Session Attributes</title>

            <para>
                In many cases, such as when considering security or efficiency, it is best
                to pass the bulk data on the server-side and use the client-side IPC only
                for notifying the other portlet(s) that the data is available. Session
                attributes are a conveninent way of sharing data on the server-side. You
                can also share objects through them, not just strings.
            </para>

            <para>
                The session variables have a <emphasis>scope</emphasis>, which should be
                <parameter>APPLICATION_SCOPE</parameter>. The "application" refers to the
                scope of the Java web application (WAR) that contains the portlets.
            </para>

            <para>
                If the communicating portlets are in the same Java web application (WAR),
                no special configuration is needed. You can also communicate between
                portlets in different WARs, in which case you need to disable the
                <parameter>private-session-attributes</parameter> parameter in
                <filename>liferay-portlet.xml</filename> by setting it to
                <literal>false</literal>. Please see Liferay documentation for more
                information regarding the configuration.
            </para>

            <para>
                You can also share Java objects between the portlets in the same WAR, not
                just strings. If the portlets are in different WARs, they normally have
                different class loaders, which could cause incompatibilities, so you can
                only communicate with strings and any object data needs to be serialized.
            </para>

            <para>
                Session attributes are accessible through the
                <classname>PortletSession</classname> object, which you can access through
                the portlet context from the Vaadin <classname>Application</classname>
                class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Person person = new Person(firstname, lastname, age);
...

PortletSession session =
        ((PortletApplicationContext2)getContext()).
            getPortletSession();

// Share the object
String key = "IPCDEMO_person";
session.setAttribute(key, person,
                     PortletSession.APPLICATION_SCOPE);

// Notify that it's available
liferayipc.sendEvent("ipc_demodata_available", key);]]></programlisting>

            <para>
                You can then receive the attribute in a
                <classname>LiferayIPCEventListener</classname> as follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public void eventReceived(LiferayIPCEvent event) {
    String key = event.getData();

    PortletSession session =
            ((PortletApplicationContext2)getContext()).
                getPortletSession();

    // Get the object reference
    Person person = (Person) session.getAttribute(key);

    // We can now use the object in our application
    BeanItem<Person> item = new BeanItem<Person> (person);
    form.setItemDataSource(item);
}]]></programlisting>

            <para>
                Notice that changes to a shared object bound to a user interface component
                are not updated automatically if it is changed in another portlet. The
                issue is the same as with double-binding in general.
            </para>
        </section>

        <section xml:id="portal.liferay-ipc.serialization">
            <title>Serializing and Encoding Data</title>

            <para>
                The IPC events support transmitting only plain strings, so if you have
                object or other non-string data, you need to format or serialize it to a
                string representation. For example, the demo application formats the
                trivial data model as a semicolon-separated list as follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[private void sendPersonViaClient(String firstName,
                                 String lastName, int age) {
    liferayIPC_1.sendEvent("newPerson", firstName + ";" +
                           lastName + ";" + age);
}]]></programlisting>

            <para>
                You can use standard Java serialization for any classes that implement the
                <interfacename>Serializable</interfacename> interface. The transmitted
                data may not include any control characters, so you also need to encode
                the string, for example by using Base64 encoding.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Some serializable object
MyBean mybean = new MyBean();
...

// Serialize
ByteArrayOutputStream baostr = new ByteArrayOutputStream();
ObjectOutputStream oostr;
try {
    oostr = new ObjectOutputStream(baostr);
    oostr.writeObject(mybean); // Serialize the object
    oostr.close();
} catch (IOException e) {
    getWindow().showNotification("IO PAN!"); // Complain
}

// Encode
BASE64Encoder encoder = new BASE64Encoder();
String encoded = encoder.encode(baostr.toByteArray());

// Send the IPC event to other portlet(s)
liferayipc.sendEvent("mybeanforyou", encoded);]]></programlisting>

            <para>
                You can then deserialize such a message at the receiving end as follows:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public void eventReceived(LiferayIPCEvent event) {
    String encoded = event.getData();

    // Decode and deserialize it    
    BASE64Decoder decoder = new BASE64Decoder();
    try {
        byte[] data = decoder.decodeBuffer(encoded);
        ObjectInputStream ois =
                new ObjectInputStream( 
                        new ByteArrayInputStream(data));

        // The deserialized bean
        MyBean deserialized = (MyBean) ois.readObject();
        ois.close();

        ... do something with the bean ...

    } catch (IOException e) {
        e.printStackTrace(); // Handle somehow
    } catch (ClassNotFoundException e) {
        e.printStackTrace(); // Handle somehow
    }
}]]></programlisting>
        </section>

        <section xml:id="portal.liferay-ipc.nonvaadin">
            <title>Communicating with Non-Vaadin Portlets</title>

            <para>
                You can use the Vaadin IPC for Liferay to communicate also between a
                Vaadin application and other portlets, such as JSP portlets. The add-on
                passes the events as regular Liferay JavaScript events. The demo WAR
                includes two JSP portlets that demonstrate the communication.
            </para>

            <?dbfo-need height="3cm" ?>
            <para>
                When sending events from non-Vaadin portlet, fire the event using the
                JavaScript <methodname>Liferay.fire()</methodname> method with an event ID
                and message. For example, in JSP you could have:
            </para>

            <programlisting><![CDATA[<%@ taglib uri="http://java.sun.com/portlet_2_0"
           prefix="portlet" %>
<portlet:defineObjects />

<script>
function send_message() {
    Liferay.fire('hello', "Hello, I'm here!");
}
</script>

<input type="button" value="Send message"
       onclick="send_message()" />]]></programlisting>

            <?dbfo-need height="3cm" ?>
            <para>
                You can receive events using a Liferay JavaScript event handler. You
                define the handler with the <methodname>on()</methodname> method in the
                Liferay object. It takes the event ID and a callback function as its
                parameters. Again in JSP you could have:
            </para>

            <programlisting><![CDATA[<%@ taglib uri="http://java.sun.com/portlet_2_0"
           prefix="portlet" %>
<portlet:defineObjects />

<script>
Liferay.on('hello', function(event, data) {
    alert("Hello: " + data);
});
</script>]]></programlisting>

        </section>
    
        <indexterm startref="term.portal.liferay-ipc" class="endofrange"/>
    </section>

    <indexterm startref="term.portal" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
