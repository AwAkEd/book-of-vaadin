<?xml version="1.0" encoding="UTF-8"?>

<section xml:id="rapid.crudviews">
    <title>Creating Vaadin Application and CRUD Views</title>
    
    <para>
        Spring Roo is essentially a code generator. As already seen in the data model part
        of this tutorial, it will write a whole bunch of boiler plate code for JPA
        entities. You get an even greater advantage of Roo when you want a simple user
        interface around the domain models.
    </para>

    <para>
        By default, Spring Roo uses JSP pages (Spring MVC to be more specific) to create
        basic CRUD (Create, Remove, Update, Delete) views. This is covered in Roo's own
        tutorials. We choose a bit different route and use the Vaadin plugin for Roo to
        create an advanced Vaadin-based server-side RIA user interface for our backend.
    </para>

    <section xml:id="rapid.crudviews.skeleton">
        <title>Creating the Application Skeleton</title>

        <para>
            First, we will use the <command>vaadin setup</command> command to create the basic
            application skeleton, on which we will later build the user interface. Issue the
            following command in the Roo shell:
        </para>

        <screen><?pocket-size 65% ?><command>vaadin setup</command> <parameter>--applicationPackage</parameter> ~.web <parameter>--baseName</parameter> RapidWorkHours <parameter>--themeName</parameter> rapid <parameter>--useJpaContainer</parameter> true</screen>
    
        <para>
            The command creates all you need or might need later during your development:
        </para>

        <orderedlist>
            <listitem>a "<package>web</package>" package where all your Vaadin related code will added</listitem>
            <listitem>an <classname>Application</classname> class</listitem>
            <listitem>a <filename>web.xml</filename> file to configure Vaadin application for servlet containers</listitem>
            <listitem>a theme</listitem>
        </orderedlist>

        <para>
            With <parameter>--useJpaContainer true</parameter>, we instruct the application to
            use JPAContainer later when we create the CRUD views. As JPAContainer is
            lazy-loading, this will save some memory in our application server in case the
            database grows a lot.
        </para>
    </section>

    <section xml:id="rapid.crudviews.skeleton">
        <title>Generating CRUD Views</title>

        <para>
            Next, we will create the actual CRUD views. Issue the following command in the Roo
            Shell:
        </para>

        <screen><?pocket-size 65% ?><command>vaadin generate all</command> <parameter>--package</parameter> ~.web.ui <parameter>--visuallyComposable</parameter> true</screen>

        <para>
            The command creates CRUD views for all domain objects into
            <package>web.ui</package> package. The <parameter>--visuallyComposable</parameter>
            parameter instructs the Roo plugin to build views in such a way that we can later
            modify them with Vaadin Visual Designer. Without this parameter views are
            constructed in bit different manner, which may be bit more maintainable for
            advanced Vaadin users.
        </para>

        <para>
            In case you add new domain objects later, you may issue this command again to
            create views for new domain objects.
        </para>
    </section>
    
    <section xml:id="rapid.crudviews.devdeploy">
        <title>Deploying to Development Server</title>

        <para>
            At this point, we have a working Vaadin application ready so we naturally want to
            see it in action. In the STS IDE, you can simply select the project and use
            <menuchoice><guimenu>Run</guimenu><guisubmenu>Run as</guisubmenu><guimenuitem>Run
                    on Server</guimenuitem></menuchoice>. You can use the VMware vFabric server
            bundled with STS, but any other servlet container (such as the Jetty-based JEE
            Preview) should work fine as well.
        </para>

        <!-- TODO: Add screenshot. -->

        <para>
            In case you feel more comfortable in the Maven world, the project can also be
            deployed for testing with, for example, <literal>jetty:run</literal> target. The
            Jetty plugin is automatically installed for the generated project.
        </para>
    </section>
    
</section>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
