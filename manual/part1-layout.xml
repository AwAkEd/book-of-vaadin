<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="layout">
	<title>Managing Layout</title>

	<para>
		This chapter gives an overview of layout components, starting with their
		history, and then gives more specific description of the components
		together with some examples.
	</para>
	
	<section xml:id="layout.overview">
		<title>Overview</title>

        <para>
            Layout components are used to place other components to specific places in the
            user interface. You can use plain Java to accomplish sophisticated component
            layouting. Another option is to use <classname>CustomLayout</classname> class
            and let the web page designers take responsibility of component layouting
            using their own set of tools.
        </para>

        <para>
            Layouts are often strongly coupled with themes that specify various layout
            attributes such as backgrounds, borders, alignment, and so on. Themes are
            detailed in <xref linkend="themes"/>.
        </para>
        
     	<note>
			<title>WYSIWYG editor</title>

			In addition to programmed layouts discussed in this chapter, the layouts
			can be edited visually using WYSIWYG editor. You can read more about the
			WYSIWYG editor on <uri>http://vaadin.com/eclipse</uri>. 
		</note>

    </section>

	<section xml:id="layout.background">
		<title>Background for Layout</title>
		
		<para>
			Ever since the ancient xeroxians invented graphical user interfaces,
			programmers have wanted to make GUI programming ever easier for
			themselves. Solutions started simple. When GUIs appeared on PC
			desktops, practically all screens were of the VGA type and fixed into
			640x480 size. Mac or X Window System on UNIX were not much
			different. Everyone was so happy with such awesome graphics
			resolutions that they never thought that an application would have to
			work on a radically different screen size. At worst, screens could
			only grow, they thought, giving more space for more windows. In the
			80s, the idea of having a computer screen in your pocket was simply
			not realistic. Hence, the GUI APIs allowed placing UI components
			using screen coordinates. Visual Basic and some other systems
			provided an easy way for the designer to drag and drop components on
			a fixed-sized window. One would have thought that at least
			translators would have complained about the awkwardness of such a solution,
			but apparently they were not, as non-engineers, heard or at least
			cared about. At best, engineers could throw at them a resource editor
			that would allow them to resize the UI components by hand. Such was
			the spirit back then.
		</para>
			
		<para>
			After the web was born, layout design was doomed to change for ever.
			At first, layout didn't matter much, as everyone was happy with plain
			headings, paragraphs, and a few hyperlinks here and there.  Designers
			of HTML wanted the pages to run on any screen size. The screen size
			was actually not pixels but rows and columns of characters, as the
			baby web was really just hyper<emphasis>text</emphasis>, not
			graphics. That was soon to be changed. The first GUI-based browser,
			NCSA Mosaic, launched a revolution that culminated in Netscape
			Navigator. Suddenly, people who had previously been doing
			advertisement brochures started writing HTML. This meant that layout
			design had to be easy not just for programmers, but also allow the
			graphics designer to do his or her job without having to know a thing
			about programming. The W3C committee designing web standards came up
			with the CSS (Cascading Style Sheet) specification, which allowed trivial separation of
			appearance from content. Later versions of HTML followed, XHTML
			appeared, as did countless other standards.
		</para>
			
		<para>
			Page description and markup languages are a wonderful solution for static
			presentations, such as books and most web pages. Real applications, however,
			need to have more control. They need to be able to change the state of user
			interface components and even their layout on the run. This creates a need to
			separate the presentation from content on exactly the right level. <!-- Vaadin
			provides a solution for this, using themes and CSS, but let us first look at
			what Java did for UI programming. -->

			<!-- Changing the layout steps right on the feet of the graphics
			designers, so we have a conflict. We will discuss this conflict
			later, but let us first look at what Java did for UI programming. -->
		</para>
			
		<para>
			Thanks to the attack of graphics designers, desktop applications were, when it
			comes to appearance, far behind web design. Sun Microsystems had come in 1995
			with a new programming language, Java, for writing cross-platform desktop
			applications. Java's original graphical user interface toolkit, AWT (Abstract
			Windowing Toolkit), was designed to work on multiple operating systems as well
			as embedded in web browsers. One of the special aspects of AWT was the layout
			manager, which allowed user interface components to be flexible, growing and
			shrinking as needed. This made it possible for the user to resize the
			windows of an application flexibly and also served the needs of localization,
			as text strings were not limited to some fixed size in pixels. It became even
			possible to resize the pixel size of fonts, and the rest of the layout
			adapted to the new size.
		</para>

		<para>
			Layout management of Vaadin is a direct successor of the web-based
			concept for separation of content and appearance and of the Java AWT solution
			for binding the layout and user interface components into objects in
			programs. Vaadin layout components allow you to position your UI
			components on the screen in a hierarchical fashion, much like in conventional
			Java UI toolkits such as AWT, Swing, or SWT. In addition, you can approach the
			layout from the direction of the web with the
			<classname>CustomLayout</classname> component, which you can use to write your
			layout as a template in XHTML that provides locations of any contained
			components.
		</para>

		<para>
			The moral of the story is that, because Vaadin is intended
			for web applications, appearance is of high importance. The solutions
			have to be the best of both worlds and satisfy artists of both
			kind: code and graphics. On the API side, the layout is controlled by UI
			components, particularly the layout components. On the visual side, it is controlled by themes. Themes
			can contain any HTML, CSS, and JavaScript that you or your web
			artists create to make people feel good about your software.
		</para>
			
	</section>
		
    <section xml:id="layout.components.orderedlayout">
        <title><classname>VerticalLayout</classname> and <classname>HorizontalLayout</classname></title>
        
        <para>
            <classname>VerticalLayout</classname> and
            <classname>HorizontalLayout</classname> components are containers for laying
            out components either vertically or horizontally, respectively. Some
            components, such as <classname>Window</classname>, have a
            <classname>VerticalLayout</classname> as the root layout, which you can set
            with <methodname>setLayout()</methodname>.
        </para>

        <para>
            Typical use of the layouts goes as follows:
        </para>

        <programlisting><![CDATA[VerticalLayout vertical = new VerticalLayout ();
vertical.addComponent(new TextField("Name"));
vertical.addComponent(new TextField("Street address"));
vertical.addComponent(new TextField("Postal code"));
main.addComponent(vertical);]]></programlisting>

        <para>
            The text fields have a label attached, which will by default be placed
            above the field. The layout will look on screen as follows:
        </para>

        <screenshot>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/orderedlayout_vertical.png"/>
                </imageobject>
            </mediaobject>
        </screenshot>
        
        <para>
            Using <classname>HorizontalLayout</classname> gives the following layout:
        </para>
        
        <screenshot>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/layout/orderedlayout_horizontal.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="60" align="center" fileref="img/layout/orderedlayout_horizontal.png"/>
                </imageobject>
            </mediaobject>
        </screenshot>

        <para>
            The layouts can have spacing between the horizontal or vertical cells,
            defined with <methodname>setSpacing()</methodname>, as described in <xref
				linkend="layout.settings.spacing"/>. The contained components can be
            aligned within their cells with
            <methodname>setComponentAlignment()</methodname>, as described in <xref
				linkend="layout.settings.alignment"/>.
        </para>

        <para>
            You can use <methodname>setWidth()</methodname> and
            <methodname>setHeight()</methodname> to specify width and height of a
            component in either fixed units or relatively with a percentage.
        </para>

        <section>
            <title>Sizing Contained Components</title>

            <para>
                The components contained within an ordered layout can be laid out in a
                number of different ways depending on how you specify their height or
                width in the primary direction of the layout component.
            </para>
            
            <figure xml:id="figure.layout.orderedlayout.size.summary">
                <title>Component Widths in <classname>HorizontalLayout</classname></title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/layout/horizontallayout_sizing.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <xref linkend="figure.layout.orderedlayout.size.summary"/> above
                gives a summary of the sizing options for a
                <classname>HorizontalLayout</classname>. Let us break down the figure
                as follows.
            </para>

            <para>
                If a <classname>VerticalLayout</classname> has undefined height or
                <classname>HorizontalLayout</classname> undefined width, the layout
                will shrink to fit the contained components so that there is no extra
                space between them.
            </para>

            <programlisting><![CDATA[HorizontalLayout fittingLayout = new HorizontalLayout();
fittingLayout.setWidth(Sizeable.SIZE_UNDEFINED, 0);
fittingLayout.addComponent(new Button("Small"));
fittingLayout.addComponent(new Button("Medium-sized"));
fittingLayout.addComponent(new Button("Quite a big component"));
parentLayout.addComponent(fittingLayout);]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_undefined.png"/>
                </imageobject>
            </mediaobject>

            <para>
                If such a vertical layout continues below the bottom of a window (a
                <classname>Window</classname> object), the window will pop up a
                vertical scroll bar on the right side of the window area. This way,
                you get a "web page".
            </para>

            <para>
                If you set a <classname>HorizontalLayout</classname> to a defined size
                horizontally or a <classname>VerticalLayout</classname> vertically,
                and there is space left over from the contained components, the extra
                space is distributed equally between the component cells. The
                components are aligned within these cells according to their
                alignment setting, top left by default, as in the example below.
            </para>

            <programlisting><![CDATA[fixedLayout.setWidth("400px");]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_defined.png"/>
                </imageobject>
            </mediaobject>

            <para>
                Using percentual sizes for components contained in a layout requires
                answering the question, "Percentage of what?" There is no sensible
                default answer for this question in the current implementation of the
                layouts, so in practice, you may not define "100%" size alone.
            </para>

            <para>
                Often, you want to have one component that takes all the available
                space left over from other components. You need to set its size as
                100% and set it as <emphasis>expanding</emphasis> with
                <methodname>setExpandRatio()</methodname>. The second parameter for
                the method is an expansion ratio, which is relevant if there are more
                than one expanding component, but its value is irrelevant for a single
                expanding component.
            </para>

			<programlisting><![CDATA[HorizontalLayout layout = new HorizontalLayout();
layout.setWidth("400px");

// These buttons take the minimum size.
layout.addComponent(new Button("Small"));
layout.addComponent(new Button("Medium-sized"));

// This button will expand.
Button expandButton = new Button("Expanding component");

// Use 100% of the expansion cell's width.
expandButton.setWidth("100%");

// The component must be added to layout before setting the ratio.
layout.addComponent(expandButton);

// Set the component's cell to expand.
layout.setExpandRatio(expandButton, 1.0f);

parentLayout.addComponent(layout);]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_expanding.png"/>
                </imageobject>
            </mediaobject>

            <para>
                Notice that you must call <methodname>setExpandRatio()</methodname>
                <emphasis>after</emphasis> <methodname>addComponent()</methodname>,
                because the layout can not operate on an component that it doesn't
                (yet) include.
            </para>

            <para>
                <emphasis role="bold">Warning:</emphasis> <emphasis>A layout that
					contains components with percentual size must have a defined
					size</emphasis>! If a layout has undefined size and component has,
                say, 100% size, the component would fill the space given by the
                layout, while the layout would shrink to fit the space taken by the
                component, which is a paradox. This requirement holds for height and
                width separately. The debug mode allows detecting such invalid cases;
                see <xref linkend="advanced.debug-production-modes.debug.mode"/>.
            </para>

            <para>
                If you specify an expand ratio for multiple components, they will all
                try to use the available space according to the ratio.
            </para>

            <programlisting><![CDATA[HorizontalLayout layout = new HorizontalLayout();
                layout.setWidth("400px");

// Create three equally expanding components.
String[] captions = { "Small", "Medium-sized", "Quite a big component" };
for (int i = 1; i <= 3; i++) {
    Button button = new Button(captions[i-1]);
    button.setWidth("100%");
    layout.addComponent(button);

    // Have uniform 1:1:1 expand ratio.
    layout.setExpandRatio(button, 1.0f);
}]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_expand_uniform.png"/>
                </imageobject>
            </mediaobject>

            <para>
                As we used the same ratio for each components, the ones with more
                content may be have the content cut. Below, we use differing ratios:
            </para>

            <programlisting><![CDATA[// Expand ratios for the components are 1:2:3.
layout.setExpandRatio(button, i * 1.0f);]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_expand_ratios.png"/>
                </imageobject>
            </mediaobject>

            <para>
                If the size of the expanding components is defined as a percentage
                (typically "100%"), the ratio is calculated from the
                <emphasis>overall</emphasis> space available for the relatively sized
                components. For example, if you have a 100 pixels wide layout with two
                cells with 1.0 and 4.0 respective expansion ratios, and both the
                components in the layout are set as
                <methodname>setWidth("100%")</methodname>, the cells will have
                respective widths of 20 and 80 pixels, regardless of the minimum size
                of the components.
            </para>

            <para>
                However, if the size of the contained components is undefined or
                fixed, the expansion ratio is of the <emphasis>excess</emphasis>
                available space. In this case, it is the excess space that expands, not
                the components.
            </para>

            <programlisting><![CDATA[        for (int i = 1; i <= 3; i++) {
    // Button with undefined size.
    Button button = new Button(captions[i - 1]);
    
    layout4.addComponent(button);

    // Expand ratios are 1:2:3.
    layout4.setExpandRatio(button, i * 1.0f);
}]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_expand_ratios-2.png"/>
                </imageobject>
            </mediaobject>

            <para>
                It is not meaningful to combine expanding components with percentually
                defined size and components with fixed or undefined size. Such
                combination can lead to a very unexpected size for the percentually
                sized components.
            </para>

            <para>
                A percentual size of a component defines the size of the component
                <emphasis>within its cell</emphasis>. Usually, you use "100%", but a
                smaller percentage or a fixed size (smaller than the cell size) will
                leave an empty space in the cell and align the component within the
                cell according to its alignment setting, top left by default.
            </para>

            <programlisting><![CDATA[HorizontalLayout layout50 = new HorizontalLayout();
layout50.setWidth("400px");

String[] captions1 = { "Small 50%", "Medium 50%", "Quite a big 50%" };
for (int i = 1; i <= 3; i++) {
    Button button = new Button(captions1[i-1]);
    button.setWidth("50%");
    layout50.addComponent(button);

    // Expand ratios for the components are 1:2:3.
    layout50.setExpandRatio(button, i * 1.0f);
}
parentLayout.addComponent(layout50);]]></programlisting>

            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/horizontallayout_width_expand_percentage.png"/>
                </imageobject>
            </mediaobject>

        </section>
        
    </section>
    
    <section xml:id="layout.components.gridlayout">
        <title><classname>GridLayout</classname></title>
        
        <para>
            <classname>GridLayout</classname> container lays components out on a grid
            of defined width and height. The columns and rows of the grid serve as
            coordinates that are used for laying out components on the grid. Each
            component can use multiple cells from the grid, defined as an area
            (x1,y1,x2,y2), although they typically take up only a single grid cell.
        </para>
        
        <para>
            The grid layout maintains a cursor for adding components in left-to-right,
            top-to-bottom order. If the cursor goes past the bottom-right corner, it
            will automatically extend the grid downwards.
        </para>
        
        <para>
            The following example demonstrates the use of
            <classname>GridLayout</classname>. The
            <methodname>addComponent</methodname> takes a component and optional
            coordinates. The coordinates can be given for a single cell or for an area
            in x,y (column,row) order. The coordinate values have a base value of
            0. If coordinates are not given, the cursor will be used.
        </para>
        
        <programlisting><![CDATA[/* Create a 4 by 4 grid layout. */
GridLayout grid = new GridLayout(4, 4);
grid.addStyleName("example-gridlayout");

/* Fill out the first row using the cursor. */
grid.addComponent(new Button("R/C 1"));
for (int i = 0; i < 3; i++) {
    grid.addComponent(new Button("Col " + (grid.getCursorX() + 1)));
}

/* Fill out the first column using coordinates. */
for (int i = 1; i < 4; i++) {
    grid.addComponent(new Button("Row " + i), 0, i);
}

/* Add some components of various shapes. */
grid.addComponent(new Button("3x1 button"), 1, 1, 3, 1);
grid.addComponent(new Label("1x2 cell"), 1, 2, 1, 3);
InlineDateField date = new InlineDateField("A 2x2 date field");
date.setResolution(DateField.RESOLUTION_DAY);
grid.addComponent(date, 2, 2, 3, 3);]]></programlisting>

        <para>
            The resulting layout will look as follows. The borders have been
            made visible to illustrate the layout cells.
        </para>
        
        <figure xml:id="figure.ui.gridlayout">
            <title>The Grid Layout Component</title>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/gridlayout.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            A component to be placed on the grid must not overlap with existing
            components. A conflict causes throwing a
            <classname>GridLayout.OverlapsException</classname>.
        </para>

        <section>
            <title>Sizing Grid Cells</title>
            
            <para>
                You can define the size of both a grid layout and its components in
                either fixed or percentual units, or leave the size undefined
                altogether, as described in <xref
					linkend="components.features.sizeable"/>. <xref
					linkend="layout.settings.size"/> gives an introduction to sizing of
                layouts.
            </para>

            <para>
                The size of the <classname>GridLayout</classname> component is
                undefined by default, so it will shrink to fit the size of the
                components placed inside it. In most cases, especially if you set a
                defined size for the layout but do not set the contained components to
                full size, there will be some unused space. The position of the
                non-full components within the grid cells will be determined by their
                <emphasis>alignment</emphasis>. See <xref
					linkend="layout.settings.alignment"/> for details on how to align the
                components inside the cells.
            </para>
            
            <para>
                The components contained within a <classname>GridLayout</classname>
                layout can be laid out in a number of different ways depending on how
                you specify their height or width. The layout options are similar to
                <classname>HorizontalLayout</classname> and
                <classname>VerticalLayout</classname>, as described in <xref
					linkend="layout.components.orderedlayout"/>.
            </para>
            
            <para>
                <emphasis role="bold">Warning:</emphasis> <emphasis>A layout that
					contains components with percentual size must have a defined
					size</emphasis>! If a layout has undefined size and component has,
                say, 100% size, the component would fill the space given by the
                layout, while the layout would shrink to fit the space taken by the
                component, which is a paradox. This requirement holds for height and
                width separately. The debug mode allows detecting such invalid cases;
                see <xref linkend="advanced.debug-production-modes.debug.mode"/>.
            </para>

            <para>
                Often, you want to have one or more rows or columns that take all the
                available space left over from non-expanding rows or columns. You need
                to set the rows or columns as <emphasis>expanding</emphasis> with
                <methodname>setRowExpandRatio()</methodname> and
                <methodname>setColumnExpandRatio()</methodname>. The first parameter
                for these methods is the index of the row or column to set as
                expanding. The second parameter for the methods is an expansion ratio,
                which is relevant if there are more than one expanding row or column,
                but its value is irrelevant if there is only one. With multiple
                expanding rows or columns, the ratio parameter sets the relative
                portion how much a specific row/column will take in relation with the
                other expanding rows/columns.
            </para>

            <programlisting><![CDATA[GridLayout grid = new GridLayout(3,2);
grid.addStyleName("gridexpandratio");

// Layout containing relatively sized components must have a defined size.
grid.setWidth("600px");
grid.setHeight("200px");

// Add content
grid.addComponent(new Label("Shrinking column<br/>Shrinking row", Label.CONTENT_XHTML));
grid.addComponent(new Label("Expanding column (1:)<br/>Shrinking row", Label.CONTENT_XHTML));
grid.addComponent(new Label("Expanding column (5:)<br/>Shrinking row", Label.CONTENT_XHTML));

grid.addComponent(new Label("Shrinking column<br/>Expanding row", Label.CONTENT_XHTML));
grid.addComponent(new Label("Expanding column (1:)<br/>Expanding row", Label.CONTENT_XHTML));
grid.addComponent(new Label("Expanding column (5:)<br/>Expanding row", Label.CONTENT_XHTML));

// Set different expansion ratios for the two columns
grid.setColumnExpandRatio(1, 1);
grid.setColumnExpandRatio(2, 5);

// Set the bottom row to expand
grid.setRowExpandRatio(1, 1);

// Align and size the labels.
for (int col=0; col<grid.getColumns(); col++) {
    for (int row=0; row<grid.getRows(); row++) {
        Component c = grid.getComponent(col, row);
        grid.setComponentAlignment(c, Alignment.TOP_CENTER);
        
        // Make the labels high to illustrate the empty horizontal space.
        if (col != 0 || row != 0) {
            c.setHeight("100%");
        }
    }
}]]></programlisting>

            <figure xml:id="figure.ui.gridlayout.sizing.expanding">
                <title>Expanding Rows and Columns in <classname>GridLayout</classname></title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/layout/gridlayout_sizing_expanding.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                If the size of the contained components is undefined or fixed, the
                expansion ratio is of the <emphasis>excess</emphasis> space, as in
                <xref linkend="figure.ui.gridlayout.sizing.expanding"/> (excess
                horizontal space shown in white). However, if the size of the all the
                contained components in the expanding rows or columns is defined as a
                percentage, the ratio is calculated from the
                <emphasis>overall</emphasis> space available for the percentually
                sized components. For example, if we had a 100 pixels wide grid layout
                with two columns with 1.0 and 4.0 respective expansion ratios, and all
                the components in the grid were set as
                <methodname>setWidth("100%")</methodname>, the columns would have
                respective widths of 20 and 80 pixels, regardless of the minimum size
                of their contained components.
            </para>
            
        </section>
        
        <note>
            <title>CSS Style Rules</title>
            
            <programlisting><![CDATA[.v-gridlayout {}
.v-gridlayout-margin {}]]></programlisting>

            <para>
                The <markup>v-gridlayout</markup> is the root element of the
                <classname>GridLayout</classname> component. The
                <markup>v-gridlayout-margin</markup> is a simple element inside it
                that allows setting a padding between the outer element and the cells.
            </para>

            <para>
                For styling the individual grid cells, you should style the components
                inserted in the cells. The implementation structure of the grid can
                change, so depending on it, as is done in the example below, is not
                generally recommended. Normally, if you want to have, for example, a
                different color for a certain cell, just make set the component inside
                it <methodname>setSizeFull()</methodname>, and add a style name for
                it. Sometimes you may need to use a layout component between a cell
                and its actual component just for styling.
            </para>

            <para>
                The following example shows how to make the grid borders visible, as
                in <xref linkend="figure.ui.gridlayout.sizing.expanding"/>.
            </para>
            
            <programlisting><![CDATA[.v-gridlayout-gridexpandratio {
    background: blue; /* Creates a "border" around the layout grid. */
    margin:     10px; /* Empty space around the layout. */
}

/* Add padding through which the background color of the grid shows. */
.v-gridlayout-gridexpandratio .v-gridlayout-margin {
    padding: 2px;     
}

/* Add cell borders and make the cell backgrounds white.
 * Warning: This depends heavily on the HTML structure. */
.v-gridlayout-gridexpandratio > div > div > div {
    padding:    2px;   /* Layout's background will show through. */
    background: white; /* The cells will be colored white. */
}

/* Components inside the layout. This is a safe way to style the cells. */
.v-gridlayout-gridexpandratio .v-label {
    text-align: left;
    background: #ffffc0; /* Pale yellow */
}]]></programlisting>
            
            <para>
                You should beware of <literal>margin</literal>,
                <literal>padding</literal>, and <literal>border</literal> settings in
                CSS as they can mess up the layout. The dimensions of layouts are
                calculated in the Client-Side Engine of Vaadin and some
                settings can interfere with these calculations. For more information,
                on margins and spacing, see <xref linkend="layout.settings.spacing"/>
                and <xref linkend="layout.settings.margins"/>
            </para>
        </note>
    </section>
    
    <section xml:id="layout.components.formlayout">
        <title><classname>FormLayout</classname></title>
        
        <para>
            <classname>FormLayout</classname> is the default layout of a
            <classname>Form</classname> component. It lays the form fields and their
            captions out in two columns, with optional indicators for required fields and
            errors that can be shown for each field.
        </para>

        <para>
            A <classname>Form</classname> handles additional layout elements
            itself, including a caption, a form description, a form error indicator,
            a footer that is often used for buttons and a border. For more
            information on these, see <xref linkend="components.form"/>.
        </para>

        <para>
            The field captions can have an icon in addition to the text.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[// A FormLayout used outside the context of a Form
FormLayout fl = new FormLayout();

// Make the FormLayout shrink to its contents 
fl.setSizeUndefined();

TextField tf = new TextField("A Field");
fl.addComponent(tf);

// Mark the first field as required
tf.setRequired(true);
tf.setRequiredError("The Field may not be empty.");

TextField tf2 = new TextField("Another Field");
fl.addComponent(tf2);

// Set the second field straing to error state with a message.
tf2.setComponentError(
    new UserError("This is the error indicator of a Field."));]]></programlisting>

        <para>
            The resulting layout will look as follows. The error message shows in a
            tooptip when you hover the mouse pointer over the error indicator.
        </para>
        
        <figure xml:id="figure.layout.formlayout">
            <title>A <classname>FormLayout</classname> Layout for Forms</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="110" align="center" fileref="img/layout/formlayout-example1.png"/>
                </imageobject>
            </mediaobject>
        </figure>	

        <simplesect>
            <title>CSS Style Rules</title>

            <!-- TODO contains some rather specific examples -->            
            <programlisting><?pocket-size 70% ?><![CDATA[.v-formlayout {}
.v-formlayout .v-caption {}

/* Columns in a field row. */
.v-formlayout-contentcell {} /* Field content. */
.v-formlayout-captioncell {} /* Field caption. */
.v-formlayout-errorcell {}   /* Field error indicator. */

/* Overall style of field rows. */
.v-formlayout-row {}
.v-formlayout-firstrow {}
.v-formlayout-lastrow {}

/* Required field indicator. */
.v-formlayout .v-required-field-indicator {}
.v-formlayout-captioncell .v-caption
        .v-required-field-indicator {}

/* Error indicator. */
.v-formlayout-cell .v-errorindicator {}
.v-formlayout-error-indicator .v-errorindicator {}]]></programlisting>

            <!-- NOTE: Margin and spacing styles were mentioned, but they looked very
            suspicious so removed them. -->

            <para>
                The top-level element of <classname>FormLayout</classname> has the
                <literal>v-formlayout</literal> style. The layout is tabular with three
                columns: the caption column, the error indicator column, and the field
                column. These can be styled with
                <literal>v-formlayout-captioncell</literal>,
                <literal>v-formlayout-errorcell</literal>, and
                <literal>v-formlayout-contentcell</literal>, respectively. While the
                error indicator is shown as a dedicated column, the indicator for required
                fields is currently shown as a part of the caption column.
            </para>

            <para>
                For information on setting margins and spacing, see also <xref
                linkend="layout.settings.spacing"/> and <xref
                linkend="layout.settings.margins"/>.
            </para>
            
        </simplesect>
    </section>

    <section xml:id="layout.components.panel">
        <title><classname>Panel</classname></title>

        <para>
            <classname>Panel</classname> is a simple container with a frame and an
            optional caption. The content area has an inner layout component for laying
            out the contained components.
        </para>

        <para>
            The caption can have an icon in addition to the text.
        </para>

        <programlisting><![CDATA[// Create a panel with a caption.
final Panel panel = new Panel("Contact Information");
panel.addStyleName("panelexample");

// The width of a Panel is 100% by default, make it
// shrink to fit the contents.
panel.setWidth(Sizeable.SIZE_UNDEFINED, 0);

// Create a layout inside the panel
final FormLayout form = new FormLayout();

// Have some margin around it.
form.setMargin(true);

// Add some components
form.addComponent(new TextField("Name"));
form.addComponent(new TextField("Email"));

// Set the layout as the root layout of the panel
panel.setLayout(form);]]></programlisting>

        <para>
            The resulting layout will look as follows.
        </para>
        
        <figure xml:id="figure.layout.panel">
            <title>A <classname>Panel</classname> Layout</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="120" align="center" fileref="img/layout/panel.png"/>
                </imageobject>
            </mediaobject>
        </figure>	

        <simplesect>
            <title>CSS Style Rules</title>
            
            <programlisting><![CDATA[.v-panel {}
.v-panel-caption {}
.v-panel-nocaption {}
.v-panel-content {}
.v-panel-deco {}]]></programlisting>

            <para>
                The entire panel has <literal>v-panel</literal> style. A panel
                consists of three parts: the caption, content, and bottom decorations
                (shadow). These can be styled with <literal>v-panel-caption</literal>,
                <literal>v-panel-content</literal>, and
                <literal>v-panel-deco</literal>, respectively. If the panel has no
                caption, the caption element will have the style
                <literal>v-panel-nocaption</literal>.
            </para>
            
            <para>
                The <emphasis>light style</emphasis> for the
                <classname>Panel</classname> is a predefined style that has now
                borders or border decorations for the panel. You enable it simply by
                adding the <literal>light</literal> style name for the panel, as is
                done in the example below. 
            </para>

            <para>
                The light style is typical when using a <classname>Panel</classname>
                as the root layout of a window or some similar layout, as in the
                example below.
            </para>

            <programlisting><![CDATA[// Have a window with a SplitPanel.
final Window window = new Window("Window with a Light Panel");
window.setWidth("400px");
window.setHeight("200px");
final SplitPanel splitter = new SplitPanel(SplitPanel.ORIENTATION_HORIZONTAL);
window.setLayout(splitter);

// Create a panel with a caption.
final Panel light = new Panel("Light Panel");
light.setSizeFull();

// The "light" style is a predefined style without borders.
light.addStyleName("light");

light.addComponent(new Label("The light Panel has no borders."));
light.getLayout().setMargin(true);

// The Panel will act as a "caption" of the left panel in SplitPanel.
splitter.addComponent(light);
splitter.setSplitPosition(250, Sizeable.UNITS_PIXELS);

main.addWindow(window);]]></programlisting>

			<figure xml:id="figure.layout.panel.light">
				<title>A <classname>Panel</classname> with Light Style</title>
				<mediaobject>
					<imageobject>
						<imagedata align="center" fileref="img/layout/panel-light.png"/>
					</imageobject>
				</mediaobject>
			</figure>	
            
        </simplesect>
    </section>

	<section xml:id="layout.components.splitpanel">
        <title><classname>SplitPanel</classname></title>
        
        <para>
            <classname>SplitPanel</classname> is a two-component container that divides
            the available space into two areas to accomodate the two components. The split
            direction is vertical by default, but you can change it with
            <methodname>setOrientation()</methodname>.
        </para>

        <para>
            You can set the two components with the dedicated
            <methodname>setFirstComponent()</methodname> and
            <methodname>setSecondComponent()</methodname> methods, or with the regular
            <methodname>addComponent()</methodname> method.
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[SplitPanel splitpanel = new SplitPanel();

// Set the orientation.
splitpanel.setOrientation(SplitPanel.ORIENTATION_HORIZONTAL);

// Put two components in the container.
splitpanel.setFirstComponent(new Label("Left Panel"));
splitpanel.setSecondComponent(new Label("Right Panel"));]]></programlisting>

        <para>
            A split bar that divides the two panels is enabled by default. The user can
            drag the bar with mouse to change the split position. To disable the bar, lock
            the split position with <methodname>setLocked(true)</methodname>.
        </para>
        
        <para>
            The following example shows how you can create a layout with two nested
            <classname>SplitPanel</classname> components (one of which has a locked split
            position):
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// A top-level panel to put everything in.
Panel panel = new Panel("Nested SplitPanels");

// Allow it to shrink to the size of the contained SplitPanel.
panel.setSizeUndefined();

// Have a vertical SplitPanel as the main component.
SplitPanel vertical = new SplitPanel();
panel.addComponent(vertical);

// Set the size of the SplitPanel rather than the containing Panel,
// because then we know how much space we have for the panels.
vertical.setHeight("150px");
vertical.setWidth("250px");

// Set the split position to 50 pixels, which is more than
// enough height for the Label in the upper panel.
vertical.setSplitPosition(50, SplitPanel.UNITS_PIXELS);

// Put a label in the upper panel.
vertical.addComponent(new Label("The contents of the upper area."));

// Put a horizontal SplitPanel in the lower area.
SplitPanel horizontal = new SplitPanel();
horizontal.setOrientation(SplitPanel.ORIENTATION_HORIZONTAL);
horizontal.setSplitPosition(65); // percent
vertical.addComponent(horizontal);

// The lower SplitPanel is locked, so the user cannot move
// the split position.
horizontal.setLocked(true);

// Component in the left panel:
horizontal.addComponent(new Label("Lower left area. "+
              "The text on the left wraps around as needed."));

// Component in the right panel:
horizontal.addComponent(new Label("Lower right area. "+
              "The text on the right also wraps around."));]]></programlisting>

        <figure xml:id="figure.splitpanel.example1">
            <title>A Layout With Nested SplitPanels</title>
            <mediaobject>
                <imageobject>
                    <imagedata align="center" fileref="img/layout/splitpanel-example1.png"/>
                </imageobject>
            </mediaobject>
        </figure>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><?pocket-size 70% ?>/* For a horizontal SplitPanel. */
.v-splitpanel-horizontal {}
.v-splitpanel-hsplitter {}
.v-splitpanel-hsplitter-locked {}

/* For a vertical SplitPanel. */
.v-splitpanel-vertical {}
.v-splitpanel-vsplitter {}
.v-splitpanel-vsplitter-locked {}

/* The two container panels. */
.v-splitpanel-first-container {}  /* Top or left panel. */
.v-splitpanel-second-container {} /* Bottom or right panel. */</programlisting>

            <para>
                The entire accordion has the style
                <literal>v-splitpanel-horizontal</literal> or
                <literal>v-splitpanel-vertical</literal>. The split bar or
                <emphasis>splitter</emphasis> between the two content panels has either
                the <literal>...-splitter</literal> or
                <literal>...-splitter-locked</literal> style, depending on whether its
                position is locked or not.
            </para>
            
		</simplesect>
    </section>

    <section xml:id="layout.components.tabsheet">
        <title><classname>TabSheet</classname></title>
        
        <para>
            The <classname>TabSheet</classname> is a multicomponent container that
            allows switching between the components with "tabs". The tabs are
            organized as a tab bar at the top of the tab sheet. Clicking on a tab
            opens its contained component in the main display area of the layout.
        </para>

		<para>
			You add new tabs to a tab sheet with the <methodname>addTab()</methodname>
			method. The method takes as its parameter the root component of the
			tab. Typically, you put a layout component as the root component.
		</para>

        <programlisting><?pocket-size 70% ?><![CDATA[// Create an empty tab sheet.
TabSheet tabsheet = new TabSheet();

// Create a component to put in a tab and put
// some content in it.
VerticalLayout myTab = new VerticalLayout();
myTab.addComponent(new Label("Hello, I am a Tab!"));

// Add the component to the tab sheet as a new tab.
tabsheet.addTab(myTab);

// Get the Tab holding the component and set its caption.
tabsheet.getTab(myTab).setCaption("My Tab");]]></programlisting>
        
        <para>
			Each tab in a tab sheet is represented as a <classname>Tab</classname> object,
			which manages the tab caption, icon, and attributes such as hidden and
			visible. New tabs can be added simply with the
			<methodname>addComponent()</methodname> method, but doing so leaves them
			without a caption. You can set the caption with
			<methodname>setTabCaption()</methodname> or simply use the
			<methodname>addTab()</methodname> method to create tabs and give them a
			caption. In addition to a caption, tabs can contain an icon, which you can
			define either in the <methodname>addTab()</methodname> call or set later with
			<methodname>setTabIcon()</methodname>.
        </para>

        <para>
            The following example demonstrates the creation of a simple tab sheet, where
            each tab shows a different <classname>Label</classname> component. The
            tabs have an icon, which are (in this example) loaded as Java class loader
            resources from the application.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[final TabSheet tabsheet = new TabSheet();

// Make the tabsheet shrink to fit the contents.
tabsheet.setSizeUndefined();

tabsheet.addTab(new Label("Contents of the first tab"),
          "First Tab",
          new ClassResource("images/Mercury_small.png", this));
tabsheet.addTab(new Label("Contents of the second tab"),
          "Second Tab",
          new ClassResource("images/Venus_small.png", this));
tabsheet.addTab(new Label("Contents of the third tab"),
          "Third tab",
          new ClassResource("images/Earth_small.png", this));

        <figure xml:id="figure.tabsheet.example1">
            <title>A Simple TabSheet Layout</title>
            <mediaobject>
                <imageobject>
                   <imagedata smallscale="120" align="center" fileref="img/components/tabsheet-example1.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            The <methodname>hideTabs()</methodname> method allows hiding the tab bar
            entirely. This can be useful in tabbed document interfaces (TDI) when
            there is only one tab. An individual tab can be made invisible by making
            its component invisible with <methodname>setVisible(false)</methodname>. A
            tab can be disabled by disabling its component with
            <methodname>setEnabled(false)</methodname>. A tab can be selected
            programmatically with <methodname>setSelectedTab()</methodname>.
        </para>

        <para>
            Clicking on a tab selects it. This fires a
            <classname>TabSheet.SelectedTabChangeEvent</classname>, which can be
            handled with the
            <classname>TabSheet.SelectedTabChangeListener</classname>. The source
            component of the event, which you can retrieve with
            <methodname>getSource()</methodname> method of the event, will be the
            <classname>TabSheet</classname> component. You can find out the currently
            selected component with <methodname>getSelectedTab()</methodname>.
        </para>
        
        <para>
            The example below demonstrates handling <classname>TabSheet</classname>
            related events and enabling and disabling tabs. The sort of logic used in
            the example is useful in sequential user interfaces, often called
            <emphasis>wizards</emphasis>, where the user goes through the tabs one by
            one, but can return back if needed.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[import com.vaadin.ui.*;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.TabSheet.SelectedTabChangeEvent;

public class TabSheetExample extends CustomComponent
        implements Button.ClickListener,
        TabSheet.SelectedTabChangeListener {
    TabSheet tabsheet = new TabSheet();
    Button tab1 = new Button("Push this button");
    Label  tab2 = new Label("Contents of Second Tab");
    Label  tab3 = new Label("Contents of Third Tab");
    
    TabSheetExample () {
        setCompositionRoot (tabsheet);

        // Listen for changes in tab selection.
        tabsheet.addListener(this);

        // First tab contains a button, for which
        // we listen button click events.
        tab1.addListener(this);
        tabsheet.addTab(tab1, "First Tab", null);

        // A tab that is initially invisible.
        tab2.setVisible(false);
        tabsheet.addTab(tab2, "Second Tab", null);
        
        // A tab that is initially disabled.
        tab3.setEnabled(false);
        tabsheet.addTab(tab3, "Third tab", null);
    }

    public void buttonClick(ClickEvent event) {
        // Enable the invisible and disabled tabs.
        tab2.setVisible(true);
        tab3.setEnabled(true);
        
        // Change selection automatically to second tab.
        tabsheet.setSelectedTab(tab2);
    }

    // Handle changes in tab selection.
    public void selectedTabChange(
                         SelectedTabChangeEvent event) {
        TabSheet source = event.getTabSheet();
        if (source == tabsheet) {
            // If the first tab was selected.
            if (source.getSelectedTab() == tab1) {
                tab2.setVisible(false);
                tab3.setEnabled(false);
            }
        }
    }
}]]></programlisting>

        <figure xml:id="figure.tabsheet.example2">
            <title>A TabSheet with Hidden and Disabled Tabs</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="120" align="center" fileref="img/components/tabsheet-example2.png"/>
                </imageobject>
            </mediaobject>
        </figure>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting>.v-tabsheet {}
.v-tabsheet-tabs {}
.v-tabsheet-content {}
.v-tabsheet-deco {}
.v-tabsheet-tabcontainer {}
.v-tabsheet-tabsheetpanel {}
.v-tabsheet-hidetabs {}

.v-tabsheet-scroller {}
.v-tabsheet-scrollerPrev {}
.v-tabsheet-scrollerNext {}
.v-tabsheet-scrollerPrev-disabled{}
.v-tabsheet-scrollerNext-disabled{}

.v-tabsheet-tabitem {}
.v-tabsheet-tabitem-selected {}
.v-tabsheet-tabitemcell {}
.v-tabsheet-tabitemcell-first {}

.v-tabsheet-tabs td {}
.v-tabsheet-spacertd {}</programlisting>

            <para>
                The entire tabsheet has the <literal>v-tabsheet</literal> style.
                A tabsheet consists of three main parts: the tabs on the top, the
                main content pane, and decorations around the tabsheet.
            </para>
            
            <para>
                The tabs area at the top can be styled with
                <literal>v-tabsheet-tabs</literal>,
                <literal>v-tabsheet-tabcontainer</literal> and
                <literal>v-tabsheet-tabitem*</literal>.
            </para>
            
            <para>
             	The style <literal>v-tabsheet-spacertd</literal> is used for any
             	empty space after the tabs. If the tabsheet has too little space to
             	show all tabs, scroller buttons enable browsing the full tab list.
             	These use the styles <literal>v-tabsheet-scroller*</literal>.
            </para>
            
            <para>
                The content area where the tab contents are shown can be styled with
                <literal>v-tabsheet-content</literal>, and the surrounding decoration
                with <literal>v-tabsheet-deco</literal>.
            </para>

		</simplesect>
    </section>
    
	<section xml:id="layout.components.accordion">
        <title><classname>Accordion</classname></title>

        <para>
            <classname>Accordion</classname> is a multicomponent container similar to
            <classname>TabSheet</classname>, except that the "tabs" are arranged
            vertically. Clicking on a tab opens its contained component in the space
            between the tab and the next one. You can use an
            <classname>Accordion</classname> identically to a
            <classname>TabSheet</classname>, which it actually inherits. See <xref
            linkend="layout.components.tabsheet"/> for more information.
        </para>
        
        <para>
            The following example shows how you can create a simple accordion. As the
            <classname>Accordion</classname> is rather naked alone, we put it inside a
            Panel that acts as its caption and provides it a border.
        </para>

        <programlisting><?pocket-size 70% ?><![CDATA[// Create the Accordion.
Accordion accordion = new Accordion();

// Have it take all space available in the layout.
accordion.setSizeFull();

// Some components to put in the Accordion.
Label l1 = new Label("There are no previously saved actions.");
Label l2 = new Label("There are no saved notes.");
Label l3 = new Label("There are currently no issues.");

// Add the components as tabs in the Accordion.
accordion.addTab(l1, "Saved actions", null);
accordion.addTab(l2, "Notes", null);
accordion.addTab(l3, "Issues", null);

// A container for the Accordion.
Panel panel = new Panel("Tasks");
panel.setWidth("300px");
panel.setHeight("300px");
panel.addComponent(accordion);

// Trim its layout to allow the Accordion take all space.
panel.getLayout().setSizeFull();
panel.getLayout().setMargin(false);]]></programlisting>

        <para>
            <xref linkend="figure.accordion.example1"/> shows what the example would look
            like with the default theme.
        </para>

        <figure xml:id="figure.accordion.example1">
            <title>An Accordion</title>
            <mediaobject>
                <imageobject>
                    <imagedata smallscale="120" align="center" fileref="img/layout/accordion-example1.png"/>
                </imageobject>
            </mediaobject>
        </figure>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting>.v-accordion {}
.v-accordion-item {}
.v-accordion-item-open {}
.v-accordion-item-first {}
.v-accordion-item-caption {}
.v-accordion-item-caption .v-caption {}
.v-accordion-item-content {}</programlisting>

            <para>
                The top-level element of <classname>Accordion</classname> has the
                <literal>v-accordion</literal> style. An <classname>Accordion</classname>
                consists of a sequence of item elements, each of which has a caption
                element (the tab) and a content area element.
            </para>
            
            <para>
                The selected item (tab) has also the <literal>v-accordion-open</literal>
                style. The content area is not shown for the closed items.
            </para>
		</simplesect>
    </section>

	<section xml:id="layout.settings">
		<title>Layout Formatting</title>

		<para>
			While the formatting of layouts is mainly done with style sheets, just as with
			other components, style sheets are not ideal or even possible to use in some
			situations. For example, CSS does not allow defining the spacing of table
			cells, which is done with the <parameter>cellspacing</parameter> attribute in
			HTML.
		</para>

		<para>
			Moreover, as many layout sizes are calculated dynamically in the Client-Side
			Engine of Vaadin, some CSS settings can fail altogether.
		</para>

		<section xml:id="layout.settings.size">
			<title>Layout Size</title>

			<para>
				The size of a layout component can be specified with the
				<methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname> methods defined in the
				<classname>Sizeable</classname> interface, just like for any component. It
				can also be undefined, in which case the layout shrinks to fit the
				component(s) inside it. <xref linkend="components.features.sizeable"/>
				gives details on the interface.
			</para>

			<figure xml:id="figure.layout.settings.size.undefined">
				<title><classname>HorizontalLayout</classname> with Undefined vs Defined size</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/layout/layout_size_undefined_vs_defined.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Many layout components take 100% width by default, while they have the
				height undefined.
			</para>

			<para>
				The sizes of components inside a layout can also be defined as a
				percentage of the space available in the layout, for example with
				<methodname>setWidth("100%");</methodname> or with the (most commonly used
				method) <methodname>setFullSize()</methodname> that sets 100% size in both
				directions. If you use a percentage in a
				<classname>HorizontalLayout</classname>,
				<classname>VerticalLayout</classname>, or
				<classname>GridLayout</classname>, you will also have to set the component
				as <emphasis>expanding</emphasis>, as noted below.
			</para>

			<warning>
                <para>
                    <emphasis>A layout that contains components with percentual size must
                    have a defined size</emphasis>!
                </para>

                <para>
                    If a layout has undefined size and a contained component has, say,
                    100% size, the component will try to fill the space given by the
                    layout, while the layout will shrink to fit the space taken by the
                    component, which is a paradox. This requirement holds for height and
                    width separately. The debug mode allows detecting such invalid cases;
                    see <xref linkend="advanced.debug-production-modes.debug.mode"/>.
                </para>
			</warning>

			<para>
				For example:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[// This takes 100% width but has undefined height.
VerticalLayout layout = new VerticalLayout();

// A button that takes all the space available in the layout.
Button button = new Button("100%x100% button");
button.setSizeFull();
layout.addComponent(button);

// We must set the layout to a defined height vertically, in
// this case 100% of its parent layout, which also must
// not have undefined size.
layout.setHeight("100%");]]></programlisting>

			<para>
				The default layout of <classname>Window</classname> and
				<classname>Panel</classname> is <classname>VerticalLayout</classname> with
				undefined height. If you insert enough components in such a layout, it
				will grow outside the bottom of the view area and scrollbars will appear
				in the browser. If you want your application to use all the
				browser view, nothing more or less, you should use
				<methodname>setFullSize()</methodname> for the root layout.
			</para>

			<programlisting><![CDATA[// Create the main window.
Window main = new Window("Main Window");
setMainWindow(main);

// Use full size.
main.getLayout().setSizeFull();]]></programlisting>

			<section>
				<title>Expanding Components</title>

				<para>
					If you set a <classname>HorizontalLayout</classname> to a defined size
					horizontally or a <classname>VerticalLayout</classname> vertically,
					and there is space left over from the contained components, the extra
					space is distributed equally between the component cells. The
					components are aligned within these cells, according to their
					alignment setting, top left by default, as in the example below.
				</para>

				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/layout/horizontallayout_width_defined.png"/>
					</imageobject>
				</mediaobject>

				<para>
					Often, you don't want such empty space, but want one or more
					components to take all the leftover space. You need to set such a
					component to 100% size and use
					<methodname>setExpandRatio()</methodname>. If there is just one
					such expanding component in the layout, the ratio parameter is irrelevant.
				</para>
				
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/layout/horizontallayout_width_expanding.png"/>
					</imageobject>
				</mediaobject>

				<para>
					If you set multiple components as expanding, the expand ratio dictates
					how large proportion of the available space (overall or excess
					depending on whether the components are sized as a percentage or not)
					each component takes. In the example below, the buttons have 1:2:3
					ratio for the expansion.
				</para>

				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/layout/horizontallayout_width_expand_ratios.png"/>
					</imageobject>
				</mediaobject>

				<para>
					<classname>GridLayout</classname> has corresponding method for both of
					its directions, <methodname>setRowExpandRatio()</methodname> and
					<methodname>setColumnExpandRatio()</methodname>.
				</para>

				<para>
					Expansion is dealt in detail in the documentation of the layout
					components that support it. See <xref
					linkend="layout.components.orderedlayout"/> and <xref
					linkend="layout.components.gridlayout"/> for details on components
					with relative sizes.
				</para>
			</section>

		</section>

		<section xml:id="layout.settings.alignment">
			<title>Layout Cell Alignment</title>

			<para>
				You can set the alignment of the component inside a specific layout cell
				with the <methodname>setComponentAlignment()</methodname> method. The
				method takes as its parameters the component contained in the cell to be
				formatted, and the horizontal and vertical alignment.
			</para>

			<para>
				<xref linkend="figure.layout.settings.alignment"/> illustrates the
				alignment of components within a <classname>GridLayout</classname>.
			</para>

			<figure xml:id="figure.layout.settings.alignment">
				<title>Cell Alignments</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/layout/layout_alignment.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="120" align="center" fileref="img/layout/layout_alignment.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The easiest way to set alignments is to use the constants defined in the
				<classname>Alignment</classname> class. Let us look how the buttons in the
				top row of the above <classname>GridLayout</classname> are aligned with
				constants:
			</para>

			<programlisting><?pocket-size 75% ?><![CDATA[// Create a grid layout
final GridLayout grid = new GridLayout(3, 3);

grid.setWidth(400, Sizeable.UNITS_PIXELS);
grid.setHeight(200, Sizeable.UNITS_PIXELS);

Button topleft = new Button("Top Left");
grid.addComponent(topleft, 0, 0);
grid.setComponentAlignment(topleft, Alignment.TOP_LEFT);

Button topcenter = new Button("Top Center");
grid.addComponent(topcenter, 1, 0);
grid.setComponentAlignment(topcenter, Alignment.TOP_CENTER);

Button topright = new Button("Top Right");
grid.addComponent(topright, 2, 0);
grid.setComponentAlignment(topright, Alignment.TOP_RIGHT);
...]]></programlisting>

			<para>
				The following table lists all the <classname>Alignment</classname>
				constants by their respective locations:
			</para>

			<table>
				<title>Alignment Constants</title>
				<tgroup cols="3" align="left">
					<tbody>
						<row valign="top">
							<entry><parameter>TOP_LEFT</parameter></entry>
							<entry><parameter>TOP_CENTER</parameter></entry>
							<entry><parameter>TOP_RIGHT</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>MIDDLE_LEFT</parameter></entry>
							<entry><parameter>MIDDLE_CENTER</parameter></entry>
							<entry><parameter>MIDDLE_RIGHT</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>BOTTOM_LEFT</parameter></entry>
							<entry><parameter>BOTTOM_CENTER</parameter></entry>
							<entry><parameter>BOTTOM_RIGHT</parameter></entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				Another way to specify the alignments is to create an
				<classname>Alignment</classname> object and specify the horizontal and
				vertical alignment with separate constants. You can specify either of the
				directions, in which case the other alignment direction is not modified,
				or both with a bitmask operation between the two directions.
			</para>

			<programlisting><?pocket-size 75% ?><![CDATA[Button middleleft = new Button("Middle Left");
grid.addComponent(middleleft, 0, 1);
grid.setComponentAlignment(middleleft,
          new Alignment(Bits.ALIGNMENT_VERTICAL_CENTER | 
                        Bits.ALIGNMENT_LEFT));

Button middlecenter = new Button("Middle Center");
grid.addComponent(middlecenter, 1, 1);
grid.setComponentAlignment(middlecenter,
          new Alignment(Bits.ALIGNMENT_VERTICAL_CENTER |
                        Bits.ALIGNMENT_HORIZONTAL_CENTER));

Button middleright = new Button("Middle Right");
grid.addComponent(middleright, 2, 1);
grid.setComponentAlignment(middleright,
          new Alignment(Bits.ALIGNMENT_VERTICAL_CENTER |
                        Bits.ALIGNMENT_RIGHT));]]></programlisting>

			<para>
				Obviously, you may combine only one vertical bitmask with one horizontal
				bitmask, though you may leave either one out. The following table lists
				the available alignment bitmask constants:
			</para>

			<table>
				<title>Alignment Bitmasks</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row valign="top">
							<entry morerows="2">Horizontal</entry>
							<entry><parameter>Bits.ALIGNMENT_LEFT</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>Bits.ALIGNMENT_HORIZONTAL_CENTER</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>Bits.ALIGNMENT_RIGHT</parameter></entry>
						</row>
						<row valign="top">
							<entry morerows="2">Vertical</entry>
							<entry><parameter>Bits.ALIGNMENT_TOP</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>Bits.ALIGNMENT_VERTICAL_CENTER</parameter></entry>
						</row>
						<row valign="top">
							<entry><parameter>Bits.ALIGNMENT_BOTTOM</parameter></entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				You can determine the current alignment of a component with
				<methodname>getComponentAlignment()</methodname>, which returns an
				<classname>Alignment</classname> object. The class provides a number of
				getter methods for decoding the alignment, which you can also get as a
				bitmask value.
			</para>

		</section>

		<section xml:id="layout.settings.spacing">
			<title>Layout Cell Spacing</title>
			
			<para>
				The <classname>VerticalLayout</classname>,
				<classname>HorizontalLayout</classname>, and
				<classname>GridLayout</classname> layouts offer a
				<methodname>setSpacing()</methodname> method for enabling space between
				the cells in the layout. Enabling the spacing adds a spacing style for all
				cells except the first so that, by setting the left or top padding, you
				can specify the amount of spacing.
			</para>

			<para>
				To enable spacing, simply call <methodname>setSpacing(true)</methodname>
				for the layout as follows:
			</para>

			<programlisting><![CDATA[HorizontalLayout layout2 = new HorizontalLayout();
layout2.addStyleName("spacingexample");
layout2.setSpacing(true);
layout2.addComponent(new Button("Component 1"));
layout2.addComponent(new Button("Component 2"));
layout2.addComponent(new Button("Component 3"));

VerticalLayout layout4 = new VerticalLayout();
layout4.addStyleName("spacingexample");
layout4.setSpacing(true);
layout4.addComponent(new Button("Component 1"));
layout4.addComponent(new Button("Component 2"));
layout4.addComponent(new Button("Component 3"));]]></programlisting>

			<para>
				In practise, the <methodname>setSpacing()</methodname> method toggles
				between the "<literal>v-COMPONENTCLASSNAME-spacing-on</literal>" and
				"<literal>-off</literal>" CSS class names in the cell elements. Elements
				having those class names can be used to define the spacing metrics in a
				theme.
			</para>
				
			<para>
				The layouts have a spacing style name to define spacing also when spacing
				is off. This allows you to define a small default spacing between
				components by default and a larger one when the spacing is actually
				enabled.
			</para>

			<para>
				Spacing can be horizontal (for <classname>HorizontalLayout</classname>),
				vertical (for <classname>VerticalLayout</classname>), or both (for
				<classname>GridLayout</classname>). The name of the spacing style for
				horizontal and vertical spacing is the base name of the component style
				name plus the "<literal>-spacing-on</literal>" suffix, as shown in the
				following table:
			</para>

			<table>
				<title>Spacing Style Names</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row valign="top">
							<entry><classname>VerticalLayout</classname></entry>
							<entry><literal>v-verticallayout-spacing-on</literal></entry>
						</row>
						<row valign="top">
							<entry><classname>HorizontalLayout</classname></entry>
							<entry><literal>v-horizontallayout-spacing-on</literal></entry>
						</row>
						<row valign="top">
							<entry><classname>GridLayout</classname></entry>
							<entry><literal>v-gridlayout-spacing-on</literal></entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				In the CSS example below, we specify the exact amount of spacing for the
				code example given above, for the layouts with the custom
				"<literal>spacingexample</literal>" style:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Set the amount of horizontal cell spacing in a
 * specific element with the "-spacingexample" style. */
.v-horizontallayout-spacingexample .v-horizontallayout-spacing-on {
    padding-left: 30px;
}

/* Set the amount of vertical cell spacing in a
 * specific element with the "-spacingexample" style. */
.v-verticallayout-spacingexample .v-verticallayout-spacing-on {
    padding-top: 30px;
}

/* Set the amount of both vertical and horizontal cell spacing
 * in a specific element with the "-spacingexample" style. */
.v-gridlayout-spacingexample .v-gridlayout-spacing-on {
    padding-top: 30px;
    padding-left: 50px;
}]]></programlisting>

			<para>
				The resulting layouts will look as shown in <xref
				linkend="figure.layout.spacing"/>, which also shows the layouts with
				no spacing.
			</para>

			<figure xml:id="figure.layout.spacing">
				<title>Layout Spacings</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/layout/layout_spacing.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/layout/layout_spacing.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<note>
				<para>
					Spacing is unrelated to "cell spacing" in HTML tables. While many
					layout components are implemented with HTML tables in the browser,
					this implementation is not guaranteed to stay the same and at least
					<classname>Vertical</classname>-/<classname>HorizontalLayout</classname>
					could be implemented with <literal>&lt;div&gt;</literal> elements as
					well. In fact, as GWT compiles widgets separately for different
					browsers, the implementation could even vary between browsers.
				</para>
				<para>
				    Also note that HTML elements with spacing classnames don't necessarily
				    exist in a component after rendering, because the Client-Side Engine
				    of Vaadin processes them.
				</para>
			</note>
		</section>

		<section xml:id="layout.settings.margins">
			<title>Layout Margins</title>

			<para>
				By default, layout components do not have any margin around them. You can
				add margin with CSS directly to the layout component. Below we set margins
				for a specific layout component (here a <literal>horizontallayout</literal>):
			</para>

			<programlisting><![CDATA[layout1.addStyleName("marginexample1");]]></programlisting>
			<programlisting>.v-<emphasis>horizontallayout</emphasis>-marginexample1
        .v-<emphasis>horizontallayout</emphasis>-margin {
	padding-left:   200px;
	padding-right:  100px;
	padding-top:    50px;
	padding-bottom: 25px;
}</programlisting>

			<para>
				Similar settings exist for other layouts such as <literal>verticallayout</literal>. 
			</para>

			<para>
				The layout size calculations require the margins to be defined as
				CSS <literal>padding</literal> rather than as CSS
				<literal>margin</literal>.   
			</para>

			<para>
				As an alternative to the pure CSS method, you can set up a margin around the
				layout that can be enabled with <methodname>setMargin(true)</methodname>.
				The margin element has some default margin widths, but you can adjust the
				widths in CSS if you need to.
			</para>

			<para>
				Let us consider the following example, where we enable the margin on all
				sides of the layout:
			</para>

			<programlisting><![CDATA[// Create a layout
HorizontalLayout layout2 = new HorizontalLayout();
containinglayout.addComponent(
    new Label("Layout with margin on all sides:"));
containinglayout.addComponent(layout2);
        
// Set style name for the layout to allow styling it
layout2.addStyleName("marginexample");
        
// Have margin on all sides around the layout
layout2.setMargin(true);
        
// Put something inside the layout
layout2.addComponent(new Label("Cell 1"));
layout2.addComponent(new Label("Cell 2"));
layout2.addComponent(new Label("Cell 3"));]]></programlisting>

			<para>
				You can enable the margins only for specific sides. The margins are
				specified for the <methodname>setMargin()</methodname> method in clockwise
				order for top, right, bottom, and left margin. The following would enable
				the top and left margins:
			</para>

			<programlisting><![CDATA[layout2.setMargin(true, false, false, true);]]></programlisting>

			<para>
				You can specify the actual margin widths in the CSS if you are not
				satisfied with the default widths (in this example for a
				<classname>HorizontalLayout</classname>):
			</para>

			<programlisting>.v-<emphasis>horizontallayout</emphasis>-marginexample .v-<emphasis>horizontallayout</emphasis>-margin-left   {padding-left:   200px;}
.v-<emphasis>horizontallayout</emphasis>-marginexample .v-<emphasis>horizontallayout</emphasis>-margin-right  {padding-right:  100px;}
.v-<emphasis>horizontallayout</emphasis>-marginexample .v-<emphasis>horizontallayout</emphasis>-margin-top    {padding-top:    50px; }
.v-<emphasis>horizontallayout</emphasis>-marginexample .v-<emphasis>horizontallayout</emphasis>-margin-bottom {padding-bottom: 25px; }</programlisting>

			<para>
				The resulting margins are shown in <xref linkend="figure.layout.margin"/>
				below. The two ways produce identical margins.
			</para>

			<figure xml:id="figure.layout.margin">
				<title>Layout Margins</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/layout/layout_margin.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="110" align="center" fileref="img/layout/layout_margin.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<simplesect>
				<title>CSS Style Rules</title>

				<para>
					The CSS style names for the margin widths for
					<methodname>setMargin()</methodname> consist of the specific layout
					name plus <literal>-margin-left</literal> and so on.
					The CSS style names for CSS-only margins consist of the specific
					layout name plus <literal>-margin</literal>. 
					Below, the style rules are given for
					<classname>VerticalLayout</classname>:
				</para>

				<programlisting><?pocket-size 75% ?>/* Alternative 1: CSS only style */
.v-<emphasis>verticallayout</emphasis>-margin {
    padding-left:   ___px;
    padding-right:  ___px;
    padding-top:    ___px;
    padding-bottom: ___px;
}
/* Alternative 2: CSS rules to be enabled in code */
.v-<emphasis>verticallayout</emphasis>-margin-left   {padding-left:   ___px;}
.v-<emphasis>verticallayout</emphasis>-margin-right  {padding-right:  ___px;}
.v-<emphasis>verticallayout</emphasis>-margin-top    {padding-top:    ___px;}
.v-<emphasis>verticallayout</emphasis>-margin-bottom {padding-bottom: ___px;}</programlisting>
				
			</simplesect>
		</section>
	</section>
		
	<section xml:id="layout.customlayout">
		<title>Custom Layouts</title>
		
		<para>
			While it is possible to create almost any typical layout with the standard layout
			components, it is sometimes best to separate the layout completely from
			code. With the <classname>CustomLayout</classname> component, you can write
			your layout as a template in XHTML that provides locations of any contained
			components. The layout template is included in a theme. This separation allows
			the layout to be designed separately from code, for example using WYSIWYG web
			designer tools such as Adobe Dreamweaver.
		</para>
		
		<para>
			A template is a HTML file located under <filename>layouts</filename> folder
			under a theme folder under the <filename>WebContent/VAADIN/themes/</filename>
			folder, for example,
			<filename>WebContent/VAADIN/themes/<emphasis>themename/layouts/mylayout.html</emphasis></filename>. (Notice
			that the root path <filename>WebContent/VAADIN/themes/</filename> for themes
			is fixed.) A template can also be provided dynamically from an
			<classname>InputStream</classname>, as explained below.  A template includes
			<literal>&lt;div&gt;</literal> elements with a <parameter>location</parameter>
			attribute that defines the location identifier. All custom layout HTML-files
			must be saved using UTF-8 character encoding.
		</para>

		<programlisting><?pocket-size 75% ?>&lt;table width="100%" height="100%"&gt;
  &lt;tr height="100%"&gt;
    &lt;td&gt;
      &lt;table align="center"&gt;
        &lt;tr&gt;
          &lt;td align="right"&gt;User&amp;nbsp;name:&lt;/td&gt;
          &lt;td&gt;<emphasis role="strong">&lt;div location="username"&gt;&lt;/div&gt;</emphasis>&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td align="right"&gt;Password:&lt;/td&gt;
          &lt;td&gt;<emphasis role="strong">&lt;div location="password"&gt;&lt;/div&gt;</emphasis>&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/table&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td align="right" colspan="2"&gt;<emphasis role="strong">&lt;div location="okbutton"&gt;</emphasis>&lt;/div&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;</programlisting>

		<para>
			The client-side engine of Vaadin will replace contents of the
			location elements with the components. The components are bound to the
			location elements by the location identifier given to
			<methodname>addComponent()</methodname>, as shown in the example below.
		</para>

		<programlisting><?pocket-size 70% ?><![CDATA[// Have a Panel where to put the custom layout.
Panel panel = new Panel("Login");
panel.setSizeUndefined();
main.addComponent(panel);

// Create custom layout from "layoutname.html" template.
CustomLayout custom = new CustomLayout("layoutname");
custom.addStyleName("customlayoutexample");

// Use it as the layout of the Panel.
panel.setLayout(custom);

// Create a few components and bind them to the location tags
// in the custom layout.
TextField username = new TextField();
custom.addComponent(username, "username");

TextField password = new TextField();
custom.addComponent(password, "password");

Button ok = new Button("Login");
custom.addComponent(ok, "okbutton");]]></programlisting>

		<para>
			The resulting layout is shown below in <xref linkend="figure.layout.customlayout"/>.
		</para>

		<figure xml:id="figure.layout.customlayout">
			<title>Example of a Custom Layout Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/layout/customlayout-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="100" smallscale="130" align="center" fileref="img/layout/customlayout-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can use <methodname>addComponent()</methodname> also to replace an
			existing component in the location given in the second parameter.
		</para>

		<para>
			In addition to a static template file, you can provide a template dynamically
			with the <classname>CustomLayout</classname> constructor that accepts an
			<classname>InputStream</classname> as the template source. For example:
		</para>

		<programlisting><![CDATA[new CustomLayout(new ByteArrayInputStream("<b>Template</b>".getBytes()));]]></programlisting>

		<para>or</para>

		<programlisting><![CDATA[new CustomLayout(new FileInputStream(file));]]></programlisting>

	</section>
		
</chapter>


<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

