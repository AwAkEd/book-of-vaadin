msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2009-09-07 14:42+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:345(None) part1-advanced.xml:348(None) 
msgid "@@image: 'img/application/window-application-dynamic-3.png'; md5=b8270d7e35cb460a325b6d0d8b6ff8fe"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:392(None) part1-advanced.xml:395(None) 
msgid "@@image: 'img/application/window-application-dynamic-1.png'; md5=53451f4ab61672529b67ab3abf1bb54c"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:439(None) part1-advanced.xml:442(None) 
msgid "@@image: 'img/application/window-application-dynamic-2.png'; md5=4f1c83ef76040a8beb9b36f24a158ec6"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:518(None) part1-advanced.xml:521(None) 
msgid "@@image: 'img/application/window-polling-example1.png'; md5=571123ad9dfc5cd868941eb5a75ad981"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:878(None) part1-advanced.xml:881(None) 
msgid "@@image: 'img/application/embedding2.png'; md5=e3caa029f4bff91b0a81abd0dafe4576"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:981(None) part1-advanced.xml:984(None) 
msgid "@@image: 'img/application/embedding3.png'; md5=15660260639529d83104dcbee94f1e83"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:1042(None) part1-advanced.xml:1045(None) 
msgid "@@image: 'img/debug/debug-window.png'; md5=66011645d6d57d1b901a164f16a65805"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:1149(None) part1-advanced.xml:1152(None) 
msgid "@@image: 'img/debug/debug-window-analyze-layouts.png'; md5=d1fa6f2cc05ca40bbbd49367607ed80f"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:1403(None) part1-advanced.xml:1406(None) 
msgid "@@image: 'img/application/paramhandler-screen.png'; md5=b48ed781e1faeff39e713f10f5bc68ae"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:2000(None) 
msgid "@@image: 'img/advanced/liferay-display-lo.png'; md5=e2e24f1df8fba3a1167c629e118bbd62"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:2003(None) 
msgid "@@image: 'img/advanced/liferay-display-hi.png'; md5=4da543ca35fa2ef43677e11760b9374c"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:2050(None) part1-advanced.xml:2053(None) 
msgid "@@image: 'img/advanced/liferay-project.png'; md5=d35df0bedfe591ed7604d4cd5386def2"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-advanced.xml:2068(None) part1-advanced.xml:2071(None) 
msgid "@@image: 'img/advanced/liferay-helloworld.png'; md5=9107a401513268666224d62f57c55cb5"
msgstr ""

#: part1-advanced.xml:4(title) 
msgid "Advanced Web Application Topics"
msgstr ""

#: part1-advanced.xml:6(para) 
msgid "This chapter covers various features and topics often needed in applications. While other topics could be considered as \"advanced\", the first section gives a brief introduction to AJAX development for beginners."
msgstr ""

#: part1-advanced.xml:13(title) 
msgid "Special Characteristics of AJAX Applications"
msgstr ""

#: part1-advanced.xml:15(para) 
msgid "New to AJAX? This section is intended for people familiar with the development of either traditional web applications or desktop applications, who are entering AJAX-enabled web application development. AJAX application development has a few special characteristics with respect to other types of applications. Possibly the most important one is how the display is managed in the web browser."
msgstr ""

#: part1-advanced.xml:24(para) 
msgid "The web was originally not built for applications, but for hypertext pages that you can view with a browser. The purpose of web pages is to provide <emphasis>content</emphasis> for the user. Application software has a somewhat different purpose; usually to allow you to work on some data or content, much of which is not ever intended to be accessible through a web browser as web pages. As the web is inherently page-based, conventional web applications had to work with page requests and output HTML as response. JavaScript and AJAX have made it possible to let go of the pages."
msgstr ""

#: part1-advanced.xml:36(para) 
msgid "Pages are largely an unknown concept to conventional desktop applications. At most, desktop applications can open multiple windows, but usually they work with a single main window, with an occasional dialog window here and there. Same goes usually for web applications developed with Vaadin: an application typically runs on a single page, changing the layout as needed and popping up dialog boxes."
msgstr ""

#: part1-advanced.xml:46(para) 
msgid "Not having to load pages and use hyperlinks to communicate all user interaction is a relief for application development. However, they are an important feature that ordinary desktop applications lack. They allow referencing different functionalities of an application or resources managed by the application. They are also important for integration with external applications."
msgstr ""

#: part1-advanced.xml:55(para) 
msgid "Certain resources can be identified through a <firstterm>URI</firstterm> or <firstterm>Universal Resource Identifier</firstterm>. A URI can easily be passed around or stored as a bookmark. We will see in <xref linkend=\"section.application.resources.uri\"/> how you can retrieve the URI of a page request. Similarly, a page request can have query parameters, which can be handled as detailed in <xref linkend=\"section.application.resources.parameters\"/>."
msgstr ""

#: part1-advanced.xml:66(para) 
msgid "Using URIs or request parameters to access functionalities or content is not as straight-forward as in conventional page-based web applications. Vaadin, just as any other AJAX framework, uses browser cookies not just for tracking users but also for tracking the application state. Cookies are unique in a browser, so any two windows share the same cookies and therefore also the state. The advantage is that you can close your browser and open it again and the application will be in the state where you left off (except for components such as text fields which did not have the immediate attribute enabled). The disadvantage is that there is no good way to distinguish between the windows, so there can usually be only a single application window. Even if there were several, you would have trouble with synchronization of application data between windows. Many conventional page-based web applications simply ignore out-of-sync situations, but such situations are risky for application platforms that are intended to be stable. Therefore it is safer to work with a single browser window. If you wish to have multiple windows in your application, you can create them inside the main window as <classname>Window</classname> objects. A URI can be used to fetch resources that have no particular state or to provide an entry point to the application."
msgstr ""

#: part1-advanced.xml:93(title) 
msgid "Application-Level Windows"
msgstr ""

#: part1-advanced.xml:95(para) 
msgid "Vaadin Release 5 introduces support for multiple application-level windows that can be used just like the main window. All such windows use the same application session. Each window is identified with a URL that is used to access it. This makes it possible to bookmark application-level windows. Such windows can even be created dynamically based on URLs."
msgstr ""

#: part1-advanced.xml:103(para) 
msgid "Application-level windows allow several uses important for the usability of browser-based applications."
msgstr ""

#: part1-advanced.xml:110(emphasis) 
msgid "Native child windows"
msgstr ""

#: part1-advanced.xml:109(listitem) 
msgid "<placeholder-1/>. An application can open child windows that are not floating windows inside a parent window."
msgstr ""

#: part1-advanced.xml:114(emphasis) 
msgid "Page-based browsing"
msgstr ""

#: part1-advanced.xml:113(listitem) 
msgid "<placeholder-1/>. The application can allow the user to open certain content to different windows. For example, in a messaging application, it can be useful to open different messages to different windows so that the user can browse through them while writing a new message."
msgstr ""

#: part1-advanced.xml:121(emphasis) 
msgid "Bookmarking"
msgstr ""

#: part1-advanced.xml:120(listitem) 
msgid "<placeholder-1/>. Bookmarks in the web browser can provide an entry-point to some content provided by an application."
msgstr ""

#: part1-advanced.xml:125(emphasis) 
msgid "Embedding windows"
msgstr ""

#: part1-advanced.xml:124(listitem) 
msgid "<placeholder-1/>. Windows can be embedded in web pages, thus making it possible to provide different views to an application from different pages or even from the same page, while keeping the same session. See <xref linkend=\"application.embedding\"/>."
msgstr ""

#: part1-advanced.xml:132(para) 
msgid "Because of the special nature of AJAX applications, these uses require some caveats. We will go through them later in <xref linkend=\"application.windows.caveats\"/>."
msgstr ""

#: part1-advanced.xml:139(title) 
msgid "Creating New Application-Level Windows"
msgstr ""

#: part1-advanced.xml:141(para) 
msgid "Creating a new application-level window is much like creating a child window (see <xref linkend=\"application.child-windows\"/>), except that the window is added with <methodname>addWindow()</methodname> to the application object instead of the main window."
msgstr ""

#: part1-advanced.xml:168(para) 
msgid "This creates the window object that a user can view by opening a URL in a browser. Creating an application-level window object does not open a new browser window automatically to view the object, but if you wish to open one, you have to do it explicitly as shown below. An application-level window has a unique URL, which is based on the application URL and the name of the window given with the <methodname>setName()</methodname> method. For example, if the application URL is <uri>http://localhost:8080/myapp/</uri> and the window name is <literal>mywindow</literal>, the URL for the window will be <uri>http://localhost:8080/myapp/mywindow/</uri>. If the name of a window is not explicitly set with <methodname>setName()</methodname>, an automatically generated name will be used. The name can be retrieved with the <methodname>getName()</methodname> method and the entire URL with <methodname>getURL()</methodname>."
msgstr ""

#: part1-advanced.xml:185(para) 
msgid "There are three typical ways to open a new window: using the <methodname>open()</methodname> method of <classname>Window</classname> class, a <classname>Link</classname>, or referencing it from HTML or JavaScript code written inside a <classname>Label</classname> component."
msgstr ""

#: part1-advanced.xml:192(para) 
msgid "The <classname>Window</classname><methodname>open()</methodname> method takes as parameters a resource to open and the target name. You can use <classname>ExternalResource</classname> to open a specific URL, which you get from the window to be opened with the <methodname>getURL()</methodname> method."
msgstr ""

#: part1-advanced.xml:210(para) 
msgid "The target name is one of the default HTML target names (<parameter>_new</parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, etc.) or a custom target name. How the window is exactly opened depends on the browser. Browsers that support tabbed browsing can open the window in another tab, depending on the browser settings."
msgstr ""

#: part1-advanced.xml:217(para) 
msgid "Another typical way to open windows is to use a <classname>Link</classname> component with the window URL as an <classname>ExternalResource</classname>."
msgstr ""

#: part1-advanced.xml:232(para) 
msgid "Using a <classname>Link</classname> allows you to specify parameters for the window that opens by clicking on the link. Above, we set the dimensions of the window and specify what window controls the window should contain. The <parameter>Link.TARGET_BORDER_DEFAULT</parameter> specifies to use the default, which includes most of the usual window controls, such as the menu, the toolbar, and the status bar."
msgstr ""

#: part1-advanced.xml:241(para) 
msgid "Another way to allow the user to open a window is to insert the URL in HTML code inside a <classname>Label</classname>. This allows even more flexibility in specifying how the window should be opened."
msgstr ""

#: part1-advanced.xml:256(para) 
msgid "When an application-level window is closed in the browser the <methodname>close()</methodname> method is normally called just like for a child window and the <classname>Window</classname> object is purged from the application. However, there are situations where <methodname>close()</methodname> might not be called. See <xref linkend=\"application.windows.closing\"/> for more information."
msgstr ""

#: part1-advanced.xml:268(title) 
msgid "Creating Windows Dynamically"
msgstr ""

#: part1-advanced.xml:270(para) 
msgid "You can create a window object dynamically by its URL path by overriding the <methodname>getWindow()</methodname> method of the <classname>Application</classname> class. The method gets a window name as its parameter and must return the corresponding <classname>Window</classname> object. The window name is determined from the first URL path element after the application URL (window name may not contain slashes). See the notes below for setting the actual name of the dynamically created windows below."
msgstr ""

#: part1-advanced.xml:281(para) 
msgid "The following example allows opening windows with a window name that begins with \"<literal>planet-</literal>\" prefix. Since the method is called for <emphasis>every</emphasis> browser request for the application, we filter only the requests where a window with the given name does not yet exist."
msgstr ""

#: part1-advanced.xml:327(para) 
msgid "The window name is and must be a unique indentifier for each <classname>Window</classname> object instance. If you use <methodname>setName()</methodname> to set the window name explicitly, as we did above, any browser window that has the same URL (within the same browser) would open the <emphasis>same</emphasis> window object. This is dangerous and <emphasis>generally not recommended</emphasis>, because the browser windows would share the same window object. Opening two windows with the same static name would immediately lead to a synchronization error, as is shown in <xref linkend=\"figure.application.window.dynamic.error\"/> below. (While also the window captions are same, they are irrelevant for this problem.)"
msgstr ""

#: part1-advanced.xml:342(title) 
msgid "Synchronization Error Between Windows with the Same Name"
msgstr ""

#: part1-advanced.xml:353(para) 
msgid "There are some cases where setting the name explicitly is useful. The launch application below is one example, as it always opens the other windows in a window target that is specific to the window name, thereby never creating two windows with the same URL. Similarly, if you had embedded the application in a browser frame and the link would open the window in a frame, you would not have problems. Having a single window instance for a URL is also useful if the browser crashes and the user opens the window again, as it will have kept its previous (server-side) state."
msgstr ""

#: part1-advanced.xml:365(para) 
msgid "Leaving the window name to be automatically generated allows opening multiple windows with the same URL, while each of the windows will have a separate state. The URL in the location bar stays unchanged and the generated window name is used only for the Ajax communications to identify the window object. A generated name is a string representation of a unique random number, such as \"<literal>1928676448</literal>\". You should be aware of the generated window names when overriding the <methodname>getWindow()</methodname> method (and not unintentionally create a new window instance dynamically for each such request). The condition in the above example would also filter out the requests for an already existing window with a generated name."
msgstr ""

#: part1-advanced.xml:379(para) 
msgid "<xref linkend=\"figure.application.window.dynamic.new\"/> shows a dynamically created application-level window with the URL shown in the address bar. The URL for the application is here <uri>http://localhost:8080/tk5/windowexample/</uri>, including the application context, and the dynamically created window's name is <uri>planet-mars</uri>."
msgstr ""

#: part1-advanced.xml:389(title) 
msgid "A Dynamically Created Window"
msgstr ""

#: part1-advanced.xml:400(para) 
msgid "The application knows the windows it already has and can return them after the creation. The application also handles closing and destruction of application-level window objects, as discussed in <xref linkend=\"application.windows.closing\"/>."
msgstr ""

#: part1-advanced.xml:407(para) 
msgid "Such dynamic windows could be opened as in the following example:"
msgstr ""

#: part1-advanced.xml:436(title) 
msgid "Opening Windows"
msgstr ""

#: part1-advanced.xml:449(title) 
msgid "Closing Windows"
msgstr ""

#: part1-advanced.xml:451(para) 
msgid "When the user closes an application-level window, the Client-Side Engine running in the browser will report the event to the server before the page is actually removed. You can catch the event with a <classname>Window.CloseListener</classname>, as is done in the example below."
msgstr ""

#: part1-advanced.xml:474(para) 
msgid "Notice that the change to the server-side state of the main window (or another application-level window) does not refresh the window in the browser, so the change will be unseen until user interaction or polling refreshes the window. This problem and its dangers are discussed in <xref linkend=\"application.windows.caveats\"/> below."
msgstr ""

#: part1-advanced.xml:482(para) 
msgid "The close event does not occur if the browser crashes or the connection is otherwise severed violently. In such a situation, the window object will be left hanging, which could become a resource problem if you allow the users to open many such application-level windows. The positive side is that the user can reconnect to the window using the window URL."
msgstr ""

#: part1-advanced.xml:492(title) 
msgid "Caveats in Using Multiple Windows"
msgstr ""

#: part1-advanced.xml:495(title) 
msgid "Communication Between Windows"
msgstr ""

#: part1-advanced.xml:497(para) 
msgid "For cases where you need communication between windows, we recommend using floating child windows. In Vaadin Release 5, an application window can not update the data in other windows. The contents of a window can only be updated when the particular window makes a request to the server. The request can be caused by user input or through polling."
msgstr ""

#: part1-advanced.xml:506(para) 
msgid "Changing the server-side state of a window while processing a user event from another window can potentially cause serious problems. Changing the client-side state of a window does not always immediately communicate the changes to the server. The server-side state can therefore be out of sync with the client-side state."
msgstr ""

#: part1-advanced.xml:515(title) 
msgid "Communication Between Two Application-Level Windows"
msgstr ""

#: part1-advanced.xml:526(para) 
msgid "The following example creates a second window that changes the contents of the main window, as illustrated in the figure above. In this simple case, changing the main window contents is safe."
msgstr ""

#: part1-advanced.xml:584(para) 
msgid "The example uses an invisible <classname>ProgressIndicator</classname> to implement polling. This is sort of a trick and a more proper API for polling is under design. Making the progress indicator invisible requires the following CSS style definition:"
msgstr ""

#: part1-advanced.xml:601(title) 
msgid "Embedding Applications in Web Pages"
msgstr ""

#: part1-advanced.xml:603(para) 
msgid "Many web applications and especially web sites are not all AJAX, but AJAX is used only for specific functionalities. In practice, many web applications are a mixture of dynamic web pages and AJAX applications embedded to such pages."
msgstr ""

#: part1-advanced.xml:610(para) 
msgid "Embedding Vaadin applications is easy. There are two basic ways to embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for the web application and load the Vaadin Client-Side Engine with a simple JavaScript code. The second method is even easier, which is to simply use the <literal>&lt;iframe&gt;</literal> element. Both of these methods have advantages and disadvantages. The <literal>&lt;div&gt;</literal> method can only embed one application in a page, while the <literal>&lt;iframe&gt;</literal> method can embed as many as needed. One disadvantage of the <literal>&lt;iframe&gt;</literal> method is that the size of the <literal>&lt;iframe&gt;</literal> element is not flexible according to the content while the <literal>&lt;div&gt;</literal> method allows such flexibility. The following sections look closer into these two embedding methods."
msgstr ""

#: part1-advanced.xml:627(title) 
msgid "Embedding Inside a <literal>div</literal> Element"
msgstr ""

#: part1-advanced.xml:632(emphasis) 
msgid "The loading code for the Client-Side Engine changed in IT Mill toolkit version 5.1.2 and the explanation below is no longer compatible with Vaadin. Please view the source code of the initial page of your application in your browser."
msgstr ""

#: part1-advanced.xml:641(para) 
msgid "You can embed a Vaadin application inside a web page with a method that is equivalent to loading the initial page content from the application servlet in a non-embedded application. Normally, the <classname>ApplicationServlet</classname> servlet generates an initial page that contains the correct parameters for the specific application. You can easily configure it to load multiple Vaadin applications on the same page, assuming that they use the same widget set."
msgstr ""

#: part1-advanced.xml:651(para) 
msgid "You can view the initial page for your application easily simply by opening the application in a web browser and viewing the HTML source code. You could just copy and paste the embedding code from the default initial page. It has, however, some extra functionality that is not normally needed: it generates some of the script content with <methodname>document.write()</methodname> calls, which is useful only when you are running the application as a portlet in a portal. The method outlined below is much simpler."
msgstr ""

#: part1-advanced.xml:662(para) 
msgid "The <filename>WebContent/multiapp.html</filename> file included in the Vaadin installation package provides an example of embedding (multiple) Vaadin applications in a page. After launching the demo application, you can view the example at URL <uri>http://localhost:8888/multiapp.html</uri>. Notice that the example assumes the use of root context for the applications (<parameter>/</parameter>)."
msgstr ""

#. figure xml:id="figure.embedding.source">
#. 				<title>Source Code of an Initial Page</title>
#. 				<mediaobject>
#. 					<imageobject role="html">
#. 						<imagedata align="center" fileref="img/application/embedding1.png"/>
#. 					</imageobject>
#. 					<imageobject role="fo">
#. 						<imagedata scale="80" align="center" fileref="img/application/embedding1.png"/>
#. 					</imageobject>
#. 				</mediaobject>
#. 			</figure
#: part1-advanced.xml:684(para) 
msgid "Embedding requires four elements inside the HTML document:"
msgstr ""

#: part1-advanced.xml:690(para) 
msgid "In the <literal>&lt;head&gt;</literal> element, you need to define the application URI and parameters and load the Vaadin Client-Side Engine. The <varname>vaadin</varname> variable is an associative map that can contain various runtime data used by the Client-Side Engine of Vaadin. The <varname>vaadinConfigurations</varname> item is itself an associate map that contains parameters for each of the applications embedded in the page. The map must contain the following items:"
msgstr ""

#: part1-advanced.xml:704(classname) part1-advanced.xml:710(parameter) 
msgid "appUri"
msgstr ""

#: part1-advanced.xml:708(literal) 
msgid "/mycontext"
msgstr ""

#: part1-advanced.xml:709(literal) 
msgid "myapp"
msgstr ""

#: part1-advanced.xml:711(literal) 
msgid "/mycontext/myapp"
msgstr ""

#: part1-advanced.xml:712(filename) 
msgid "multiapp.html"
msgstr ""

#: part1-advanced.xml:705(listitem) 
msgid "The application URI consists of the context and the application path. If the context is <placeholder-1/> and the application path is <placeholder-2/>, the <placeholder-3/> would be <placeholder-4/>. The <placeholder-5/> example assumes the use of root context, which is used in the demo application."
msgstr ""

#: part1-advanced.xml:717(classname) 
msgid "pathInfo"
msgstr ""

#: part1-advanced.xml:719(parameter) 
msgid "PATHINFO"
msgstr ""

#: part1-advanced.xml:718(listitem) 
msgid "The <placeholder-1/> parameter for the Servlet."
msgstr ""

#: part1-advanced.xml:724(classname) 
msgid "themeUri"
msgstr ""

#: part1-advanced.xml:729(filename) 
msgid "/VAADIN/themes/"
msgstr ""

#: part1-advanced.xml:725(listitem) 
msgid "URI of the application theme. The URI must include application context and the path to the theme directory. Themes are, by default, stored under the <placeholder-1/> path."
msgstr ""

#: part1-advanced.xml:733(classname) 
msgid "versionInfo"
msgstr ""

#: part1-advanced.xml:736(parameter) 
msgid "vaadinVersion"
msgstr ""

#: part1-advanced.xml:738(parameter) 
msgid "applicationVersion"
msgstr ""

#: part1-advanced.xml:734(listitem) 
msgid "This item is itself an associative map that contains two parameters: <placeholder-1/> contains the version number of the Vaadin version used by the application. The <placeholder-2/> parameter contains the version of the particular application."
msgstr ""

#: part1-advanced.xml:745(para) 
msgid "The following example defines two applications to run in the same window: the Calculator and Hello World examples. In the example, the application context is <literal>/tk5</literal>."
msgstr ""

#: part1-advanced.xml:751(programlisting) 
#, no-wrap
msgid "<?pocket-size 65% ?>&lt;script type=\"text/javascript\"&gt;\n    var vaadin = {\n        vaadinConfigurations: {\n            '<emphasis role=\"bold\">calc</emphasis>': {\n                appUri:'<emphasis role=\"bold\">/tk5/Calc</emphasis>',\n                pathInfo: '<emphasis role=\"bold\">/</emphasis>',\n                themeUri: '<emphasis role=\"bold\">/tk5/VAADIN/themes/example</emphasis>',\n                versionInfo : {\n                    vaadinVersion:\"5.9.9-INTERNAL-\n                         NONVERSIONED-DEBUG-BUILD\",\n                    applicationVersion:\"NONVERSIONED\"\n                }\n            },\n            '<emphasis role=\"bold\">hello</emphasis>': {\n                appUri:'<emphasis role=\"bold\">/tk5/HelloWorld</emphasis>',\n                pathInfo: '<emphasis role=\"bold\">/</emphasis>',\n                themeUri: '<emphasis role=\"bold\">/tk5/VAADIN/themes/example</emphasis>',\n                versionInfo : {\n                    vaadinVersion:\"5.9.9-INTERNAL-\n                          NONVERSIONED-DEBUG-BUILD\",\n                    applicationVersion:\"NONVERSIONED\"\n                }\n            }\n        }};\n&lt;/script&gt;"
msgstr ""

#: part1-advanced.xml:779(para) 
msgid "Loading the Vaadin Client-Side Engine is done with the following kind of line in the <literal>&lt;head&gt;</literal> element:"
msgstr ""

#: part1-advanced.xml:785(programlisting) 
#, no-wrap
msgid "<?pocket-size 65% ?>&lt;script language='javascript' src='/<emphasis>vaadin-examples</emphasis>/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'&gt;&lt;/script&gt;"
msgstr ""

#: part1-advanced.xml:787(para) 
msgid "The engine URI consists of the context of the web application, <literal>vaadin-examples</literal> above, followed by the path to the JavaScript (<filename>.js</filename>) file of the widget set, relative to the <filename>WebContent</filename> directory. The file contains the Client-Side Engine compiled for the particular widget set. The line above assumes the use of the default widget set of Vaadin. If you have made custom widgets that are defined in a custom widget set, you need to use the path to the compiled widget set file. Widget sets must be compiled under the <filename>WebContent/VAADIN/widgetsets</filename> directory."
msgstr ""

#: part1-advanced.xml:803(para) 
msgid "In the <literal>&lt;html&gt;</literal> element, you need to do a routine inclusion of GWT history <literal>iframe</literal> element as follows:"
msgstr ""

#: part1-advanced.xml:809(programlisting) 
#, no-wrap
msgid "<?pocket-size 65% ?>&lt;iframe id=\"__gwt_historyFrame\"\n        style=\"width:0;height:0;border:0\"&gt;&lt;/iframe&gt;"
msgstr ""

#: part1-advanced.xml:814(para) 
msgid "The location of the Vaadin application is defined with a <literal>div</literal> placeholder element having <literal>id=\"itmill-ajax-window\"</literal> as follows:"
msgstr ""

#: part1-advanced.xml:820(programlisting) 
#, no-wrap
msgid "&lt;div id=\"itmill-ajax-window\"/&gt;"
msgstr ""

#: part1-advanced.xml:824(para) 
msgid "Below is a complete example of embedding an application. It works out-of-the-box with the <application>Calculator</application> demo application."
msgstr ""

#: part1-advanced.xml:870(para) 
msgid "The page will look as shown in <xref linkend=\"figure.embedding.div\"/>."
msgstr ""

#: part1-advanced.xml:875(title) 
msgid "Embedded Application"
msgstr ""

#: part1-advanced.xml:886(para) 
msgid "You can style the web application with themes as described in <xref linkend=\"themes\"/>. The Client-Side Engine loads the style sheets required by the application. In addition, you can do styling in the embedding page, as was done in the example above."
msgstr ""

#: part1-advanced.xml:893(para) 
msgid "The <application>Reservation Demo</application> and <application>Windowed Demos</application> provide similar examples of embedding an application in a web page. The embedding web pages are <filename>WebContent/reservr.html</filename> and <filename>WebContent/windoweddemos.html</filename>, respectively."
msgstr ""

#: part1-advanced.xml:901(para) 
msgid "The disadvantage of this embedding method is that there can only be one web application embedded in a page. One is usually enough, but if it is not, you need to use the <literal>&lt;iframe&gt;</literal> method below."
msgstr ""

#: part1-advanced.xml:910(title) 
msgid "Embedding Inside an <literal>iframe</literal> Element"
msgstr ""

#: part1-advanced.xml:912(para) 
msgid "Embedding a Vaadin application inside an <literal>&lt;iframe&gt;</literal> element is even easier than the method described above, as it does not require definition of any Vaadin specific definitions. The use of <literal>&lt;iframe&gt;</literal> makes it possible to embed multiple web applications or two different views to the same application on the same page."
msgstr ""

#: part1-advanced.xml:921(para) 
msgid "You can embed an application with an element such as the following:"
msgstr ""

#: part1-advanced.xml:927(para) 
msgid "The problem with <literal>&lt;iframe&gt;</literal> elements is that their size of is not flexible depending on the content of the frame, but the content must be flexible to accommodate in the frame. You can set the size of an <literal>&lt;iframe&gt;</literal> element with <literal>height</literal> and <literal>width</literal> attributes."
msgstr ""

#: part1-advanced.xml:935(para) 
msgid "Below is a complete example of using the <literal>&lt;iframe&gt;</literal> to embed two applications in a web page."
msgstr ""

#: part1-advanced.xml:972(para) 
msgid "The page will look as shown in <xref linkend=\"figure.embedding.iframe\"/> below."
msgstr ""

#: part1-advanced.xml:978(title) 
msgid "Vaadin Applications Embedded Inside IFrames"
msgstr ""

#: part1-advanced.xml:992(title) 
msgid "Debug and Production Mode"
msgstr ""

#: part1-advanced.xml:994(para) 
msgid "Vaadin applications can be run in two modes: <emphasis>debug mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode, which is on by default, enables a number of built-in debug features for the developers. The features include:"
msgstr ""

#: part1-advanced.xml:1002(listitem) 
msgid "Debug Window for accessing debug functionalities"
msgstr ""

#: part1-advanced.xml:1003(listitem) 
msgid "Display debug information in the Debug Window and server console."
msgstr ""

#: part1-advanced.xml:1004(guibutton) 
msgid "Analyze layouting"
msgstr ""

#: part1-advanced.xml:1004(listitem) 
msgid "<placeholder-1/> button that analyzes the layout for possible problems."
msgstr ""

#: part1-advanced.xml:1007(para) 
msgid "All applications are run in the debug mode by default (since IT Mill Toolkit version 5.3.0). The production mode can be enabled, and debug mode thereby disabled, by adding a <parameter>productionMode=true</parameter> parameter to the servlet context in the <filename>web.xml</filename> deployment descriptor:"
msgstr ""

#: part1-advanced.xml:1020(para) 
msgid "Enabling the production mode disables the debug features, thereby preventing users from easily inspecting the inner workings of the application from the browser."
msgstr ""

#: part1-advanced.xml:1027(title) 
msgid "Debug Mode"
msgstr ""

#: part1-advanced.xml:1029(para) 
msgid "Running an application in the debug mode enables the client-side Debug Window in the browser. You can open the Debug Window by adding \"<uri>?debug</uri>\" to the application URL, e.g., <uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in <xref linkend=\"figure.debug.window\"/>, consists of buttons controlling the debugging features and a scrollable log of debug messages."
msgstr ""

#: part1-advanced.xml:1039(title) 
msgid "Debug Window"
msgstr ""

#: part1-advanced.xml:1052(guibutton) 
msgid "Clear console"
msgstr ""

#: part1-advanced.xml:1053(listitem) 
msgid "Clears the log in the Debug Window."
msgstr ""

#: part1-advanced.xml:1058(guibutton) 
msgid "Restart app"
msgstr ""

#: part1-advanced.xml:1059(listitem) 
msgid "Restarts the application."
msgstr ""

#: part1-advanced.xml:1064(guibutton) 
msgid "Force layout"
msgstr ""

#: part1-advanced.xml:1065(listitem) 
msgid "Causes all currently visible layouts to recalculate their appearance. Layout components calculate the space required by all child components, so the layout appearance must be recalculated whenever the size of a child component is changed. In normal applications, this is done automatically, but when you do themeing or alter the CSS with Firebug, you may need to force all layouts to recalculate themselves, taking into account the recently made changes."
msgstr ""

#: part1-advanced.xml:1077(guibutton) 
msgid "Analyze layouts"
msgstr ""

#: part1-advanced.xml:1078(listitem) 
msgid "This is described in the following section."
msgstr ""

#: part1-advanced.xml:1084(para) 
msgid "If you use the Firebug plugin in Mozilla Firefox, the log messages will also be printed to the Firebug console. In such a case, you may want to enable client-side debugging without showing the Debug Window with \"<uri>?debug=quiet</uri>\" in the URL. In the quiet debug mode, log messages will only be printed to the Firebug console."
msgstr ""

#: part1-advanced.xml:1094(title) 
msgid "Analyzing Layouts"
msgstr ""

#: part1-advanced.xml:1095(para) 
msgid "The <guilabel>Analyze layouts</guilabel> button analyzes the currently visible layouts and makes a report of possible layout related problems. All detected layout problems are displayed in the log and also printed to the console."
msgstr ""

#: part1-advanced.xml:1102(para) 
msgid "The most common layout problem is caused by placing a component that has a relative size inside a container (layout) that has undefined size, e.g., adding a 100% wide <classname>Panel</classname> inside a <classname>HorizontalLayout</classname> with no width specification. In such a case, the error will look as shown below:"
msgstr ""

#: part1-advanced.xml:1118(para) 
msgid "This particular error tells that the <classname>Panel</classname> \"My panel\" is 100% wide while the width of the containing <classname>HorizontalLayout</classname> is undefined. The components will be rendered as if the the width of the contained <classname>Panel</classname> was undefined, which might not be what the developer wanted. There are two possible fixes for this case: if the <classname>Panel</classname> should fill the main window horizontally, set a width for the <classname>HorizontalLayout</classname> (e.g. 100% wide), or set the width of the <classname>Panel</classname> to \"undefined\" to render the it as it is currently rendered but avoiding the warning message."
msgstr ""

#: part1-advanced.xml:1132(para) 
msgid "The same error is shown in the Debug Window in a slightly different form and with an additional feature (see <xref linkend=\"figure.debug-window.analyze-layouts\"/>). Checking the <guilabel>Emphasize component in UI</guilabel> box will turn red the background of the component that caused a warning, making it easy for the developer to figure out which component each warning relates to. The messages will also be displayed hierarchically, as a warning from a containing component often causes more warnings from its child components. A good rule of thumb is to work on the upper-level problems first and only after that worry about the warnings from the children."
msgstr ""

#: part1-advanced.xml:1146(title) 
msgid "Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>."
msgstr ""

#: part1-advanced.xml:1160(title) 
msgid "Custom Layouts"
msgstr ""

#: part1-advanced.xml:1162(para) 
msgid "<classname>CustomLayout</classname> components can not be analyzed in the same way as other layouts. For custom layouts, the <guibutton>Analyze layouts</guibutton> button analyzes all contained relative-sized components and checks if any relative dimension is calculated to zero so that the component will be invisible. The error log will display a warning for each of these invisible components. It would not be meaningful to emphasize the component itself as it is not visible, so when you select such an error, the parent layout of the component is emphasized if possible."
msgstr ""

#: part1-advanced.xml:1177(title) 
msgid "Debug Functions for Component Developers"
msgstr ""

#: part1-advanced.xml:1179(para) 
msgid "You can take advantage of the debug mode when developing client-side components. The static function <methodname>ApplicationConnection.getConsole()</methodname> will return a reference to a <classname>Console</classname> object which contains logging methods such as <methodname>log(String msg)</methodname> and <methodname>error(String msg)</methodname>. These functions will print messages to the Debug Window and Firebug console in the same way as other debugging functionalities of Vaadin do. No messages will be printed if the Debug Window is not open or if the application is running in production mode."
msgstr ""

#: part1-advanced.xml:1195(title) 
msgid "Resources"
msgstr ""

#: part1-advanced.xml:1197(para) 
msgid "In addition to high-level resource classes described in <xref linkend=\"application.resources\"/>, Vaadin provides low-level facilities for retrieving the URI and other parameters of HTTP requests. In the following, we will look into low-level interfaces for handling URIs and parameters to provide resources and functionalities."
msgstr ""

#: part1-advanced.xml:1205(para) 
msgid "Notice that using URI or parameter handlers to create \"pages\" is not meaningful in Vaadin or in AJAX applications generally. See <xref linkend=\"advanced.application.pages\"/> for reasons."
msgstr ""

#: part1-advanced.xml:1212(title) 
msgid "URI Handlers"
msgstr ""

#: part1-advanced.xml:1214(para) 
msgid "The URI parameter for the application is useful mainly for two purposes: for providing some special functionality according to the URI or for providing dynamic content. Dynamic content can also be provided with <classname>StreamResource</classname>."
msgstr ""

#: part1-advanced.xml:1221(para) 
msgid "You can retrieve the URI for the HTTP request made for your application by implementing the <classname>com.vaadin.terminal.URIHandler</classname> interface. The handler class needs to be registered in the main window object of your application with the <methodname>addURIHandler()</methodname> method. You then get the URI by implementing the <methodname>handleURI()</methodname> method. The method gets two parameters: a context and a URI relative to the context. The context is the base URI for your application."
msgstr ""

#: part1-advanced.xml:1252(para) 
msgid "If you have multiple URI handlers attached to a window, they are executed after one another. The URI handlers should return <parameter>null</parameter>, unless you wish to provide dynamic content with the call. Other URI handlers attached to the window will not be executed after some handler returns non-null data. The combined parameter and URI handler example below shows how to create dynamic content with a URI handler."
msgstr ""

#: part1-advanced.xml:1262(para) 
msgid "Notice that if you do provide dynamic content with a URI handler, the dynamic content is returned in the HTTP response. If the handler makes any changes to the UI state of the application, these changes are not rendered in the browser, as they are usually returned in the HTTP response made by the Application object and now the custom URI handler overrides the default behaviour. If your client-side code makes a server call that does update the UI state, the client-side must initiate an update from the server. For example, if you have an integration situation where you make a JavaScript call to the server, handle the request with a URI handler, and the server state changes as a side-effect, you can use the <methodname>vaadin.forceSync()</methodname> method to force the update."
msgstr ""

#: part1-advanced.xml:1279(title) 
msgid "Parameter Handlers"
msgstr ""

#: part1-advanced.xml:1281(para) 
msgid "You can retrieve the parameters passed to your application by implementing the <classname>com.vaadin.terminal.ParameterHandler</classname> interface. The handler class needs to be registered in the main window object of your application with the <methodname>addParameterHandler()</methodname> method. You then get the parameters in the <methodname>handleParameters()</methodname> method. The parameters are passes as a map from string key to a vector of string values."
msgstr ""

#: part1-advanced.xml:1306(para) 
msgid "The parameter handler is not called if there are no parameters. Parameter handler is called before the URI handler, so if you handle both, you might typically want to just store the URI parameters in the parameter handler and do actual processing in URI handler. This allows you, for example, to create dynamic resources based on the URI parameters."
msgstr ""

#: part1-advanced.xml:1390(para) 
msgid "When you use the dynamic resource class in your application, you obviously need to provide the same instance of the class as both types of handler:"
msgstr ""

#: part1-advanced.xml:1400(title) 
msgid "Dynamic Resource with URI Parameters"
msgstr ""

#: part1-advanced.xml:1422(title) 
msgid "Shortcut Keys"
msgstr ""

#. UNFINISHED
#: part1-advanced.xml:1426(para) 
msgid "Shortcut keys can be defined as <emphasis>actions</emphasis> using the <classname>ShortcutAction</classname> class. ShortcutAction extends generic <classname>Action</classname> class that is used for example in <classname>Tree</classname> and <classname>Table</classname> for context menus. Currently the only classes that accept <classname>ShortcutActions</classname> are <classname>Window</classname> and <classname>Panel</classname>. This may change in the future. <classname>Table</classname> is a good candidate to support ShortcutActions."
msgstr ""

#: part1-advanced.xml:1437(para) 
msgid "To handle key presses, you need to define an action handler by implementing the <classname>Handler</classname> interface. The interface has two methods that you need to implement: <methodname>getActions()</methodname> and <methodname>handleAction()</methodname>."
msgstr ""

#: part1-advanced.xml:1444(para) 
msgid "The <methodname>getActions()</methodname> interface method must return an array of <classname>Action</classname> objects for the component specified with the second parameter for the method, the <parameter>sender</parameter> of an action. For a keyboard shortcut, you use a <classname>ShortcutAction</classname>. The implementation of the method could be following:"
msgstr ""

#: part1-advanced.xml:1471(para) 
msgid "The returned Action array may be static or created dynamically for different senders according to your needs."
msgstr ""

#: part1-advanced.xml:1476(para) 
msgid "The constructor method of <classname>ShortcutAction</classname> takes a symbolic caption for the action; this is largely irrelevant for shortcut actions in their current implementation, but might be used later if implementors use them in both menus and as shortcut actions. The second parameter is the keycode, as defined in <classname>ShortcutAction.KeyCode</classname> interface. Currently, the following keycodes are allowed:"
msgstr ""

#: part1-advanced.xml:1488(term) 
msgid "Keys <parameter>A</parameter> to <parameter>Z</parameter>"
msgstr ""

#: part1-advanced.xml:1489(listitem) 
msgid "Normal letter keys"
msgstr ""

#: part1-advanced.xml:1492(term) 
msgid "<parameter>F1</parameter> to <parameter>F12</parameter>"
msgstr ""

#: part1-advanced.xml:1494(para) 
msgid "Function keys"
msgstr ""

#: part1-advanced.xml:1498(term) 
msgid "<parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter>"
msgstr ""

#: part1-advanced.xml:1500(para) 
msgid "Control keys"
msgstr ""

#: part1-advanced.xml:1504(term) 
msgid "<parameter>NUM0</parameter> to <parameter>NUM9</parameter>"
msgstr ""

#: part1-advanced.xml:1506(para) 
msgid "Number pad keys"
msgstr ""

#: part1-advanced.xml:1510(term) 
msgid "<parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter>"
msgstr ""

#: part1-advanced.xml:1512(para) 
msgid "Arrow keys"
msgstr ""

#: part1-advanced.xml:1516(term) 
msgid "<parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter>"
msgstr ""

#: part1-advanced.xml:1518(para) 
msgid "Other movement keys"
msgstr ""

#: part1-advanced.xml:1523(para) 
msgid "The third parameter is an array of modifier keys, as defined in the <classname>ShortcutAction.ModifierKey</classname> interface. The following modifier keys are allowed: <parameter>ALT</parameter>, <parameter>CTRL</parameter>, and <parameter>SHIFT</parameter>. The modifier keys can be combined; for example, the following defines shortcut key combination <keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>S</keycap></keycombo>: <placeholder-1/>"
msgstr ""

#: part1-advanced.xml:1540(para) 
msgid "The following example demonstrates the definition of a default button for a user interface, as well as a normal shortcut key, <keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the <guibutton>Cancel</guibutton> button."
msgstr ""

#: part1-advanced.xml:1642(para) 
msgid "Notice that the keyboard actions can currently be attached only to <classname>Panel</classname>s and <classname>Window</classname>s. This can cause problems if you have components that require a certain key. For example, multi-line <classname>TextField</classname> requires the <keycap>Enter</keycap> key. There is currently no way to filter the shortcut actions out while the focus is inside some specific component, so you need to avoid such conflicts."
msgstr ""

#: part1-advanced.xml:1654(title) 
msgid "Printing"
msgstr ""

#: part1-advanced.xml:1656(para) 
msgid "Vaadin does not currently have any special support for printing. Printing on the server-side is anyhow largely independent from the web UI of an application. You just have to take care that the printing does not block server requests, possibly by running printing in another thread."
msgstr ""

#: part1-advanced.xml:1663(para) 
msgid "For client-side printing, most browsers support printing the web page. The <methodname>print()</methodname> method in JavaScript opens the print window of the browser. You can easily make a HTML button or link that prints the current page by placing the custom HTML code inside a <classname>Label</classname>."
msgstr ""

#: part1-advanced.xml:1673(para) 
msgid "This button would print the current page. Often you want to be able to print a report or receipt and it should not have any UI components. In such a case you could offer it as a PDF resource, or you could open a new window as is done below and automatically launch printing."
msgstr ""

#: part1-advanced.xml:1706(para) 
msgid "How the browser opens the window, as an actual window or just a tab, depends on the browser. Notice that above we create a new window object each time the print button is clicked, which leads to unused window objects. If this is a real problem, you might want to reuse the same window object or clean up the old ones - it's ok because the user doesn't interact with them later anyhow."
msgstr ""

#: part1-advanced.xml:1714(para) 
msgid "You will also need a custom layout that contains the <methodname>print()</methodname> JavaScript function that launches the printing. Notice that the custom layout <emphasis>must</emphasis> contain also another element (below a <literal>&lt;div&gt;</literal>) in addition to the <literal>&lt;script&gt;</literal> element."
msgstr ""

#: part1-advanced.xml:1729(para) 
msgid "Printing as PDF would not require creating a <classname>Window</classname> object, but you would need to provide the content as a static or a dynamic resource for the <methodname>open()</methodname> method. Printing a PDF file would obviously require a PDF viewer cabability (such as Adobe Reader) in the browser."
msgstr ""

#: part1-advanced.xml:1740(title) 
msgid "Portal Integration"
msgstr ""

#: part1-advanced.xml:1742(para) 
msgid "Vaadin supports running applications as portlets, as defined in the JSR-168 standard. While providing generic support for all portals implementing the standard, Vaadin especially supports the Liferay portal and the needed portal-specific configuration is given below for Liferay."
msgstr ""

#: part1-advanced.xml:1750(title) 
msgid "Portal Integration Examples"
msgstr ""

#: part1-advanced.xml:1751(para) 
msgid "You can deploy the Vaadin demo package WAR (available from the download site) directly to a portal such as Liferay. It contains all the necessary portlet configuration files. For optimal performance with Liferay, you need to install and configure the widget set and themes in Liferay as described below."
msgstr ""

#: part1-advanced.xml:1759(para) 
msgid "You can find more documentation and examples from the Vaadin Developer's Site at <uri>http://dev.vaadin.com/</uri>."
msgstr ""

#: part1-advanced.xml:1766(title) 
msgid "Deploying to a Portal"
msgstr ""

#: part1-advanced.xml:1768(para) 
msgid "Deploying a Vaadin application as a portlet is essentially just as easy as deploying a regular application to an application server. You do not need to make any changes in the application itself, but only the following:"
msgstr ""

#: part1-advanced.xml:1775(para) 
msgid "Application packaged as a WAR"
msgstr ""

#: part1-advanced.xml:1777(para) 
msgid "<filename>WEB-INF/portlet.xml</filename> descriptor"
msgstr ""

#: part1-advanced.xml:1778(para) 
msgid "<filename>WEB-INF/liferay-portlet.xml</filename> descriptor for Liferay"
msgstr ""

#: part1-advanced.xml:1779(para) 
msgid "<filename>WEB-INF/liferay-display.xml</filename> descriptor for Liferay"
msgstr ""

#: part1-advanced.xml:1783(listitem) 
msgid "Widget set installed to portal (recommended)"
msgstr ""

#: part1-advanced.xml:1784(listitem) 
msgid "Themes installed to portal (recommended)"
msgstr ""

#: part1-advanced.xml:1785(listitem) 
msgid "Portal configuration settings (optional)"
msgstr ""

#: part1-advanced.xml:1788(para) 
msgid "Installing the widget set and themes to the portal is required for running two or more Vaadin portlets simultaneously in a portal page. As this situation occurs quite easily, we recommend installing them in any case."
msgstr ""

#: part1-advanced.xml:1794(para) 
msgid "In addition to the Vaadin library, you will need to copy the <filename>portlet.jar</filename> to your project. It is included in the Vaadin installation package. Notice that you must not put the <filename>portlet.jar</filename> in the same <filename>WebContent/WEB-INF/lib</filename> directory as the Vaadin JAR or otherwise include it in the WAR to be deployed, because otherwise it will create a conflict with the internal portlet library of the portal."
msgstr ""

#: part1-advanced.xml:1804(para) 
msgid "How you actually deploy a WAR package depends on the portal. In Liferay, you simply copy it to the <filename>deploy</filename> subdirectory under the Liferay installation directory. Liferay uses Tomcat by default, so you will find the extracted package in the <filename>webapps</filename> directory under the Tomcat installation directory included in Liferay."
msgstr ""

#: part1-advanced.xml:1814(title) 
msgid "Portlet Deployment Descriptors"
msgstr ""

#: part1-advanced.xml:1816(para) 
msgid "To deploy a portlet WAR in a portal, you need to provide the basic <filename>portlet.xml</filename> descriptor specified in the Java Portlet standard. In addition, you may need to include possible portal vendor specific deployment descriptors. The ones required by Liferay are described below."
msgstr ""

#: part1-advanced.xml:1825(title) 
msgid "Basic Portlet Descriptor"
msgstr ""

#: part1-advanced.xml:1827(para) 
msgid "The portlet WAR must include a portlet descriptor located at <filename>WebContent/WEB-INF/portlet.xml</filename>. A portlet definition includes the portlet name, mapping to a servlet in <filename>web.xml</filename>, modes supported by the portlet, and other configuration. Below is an example of a simple portlet definition in <filename>portlet.xml</filename> descriptor."
msgstr ""

#: part1-advanced.xml:1836(programlisting) 
#, no-wrap
msgid "<?pocket-size 65% ?>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;portlet-app\n  version=\"1.0\"\n  xmlns=\"http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd\"\n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\n       \"http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd\n        http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd\"&gt;\n\n  &lt;portlet&gt;\n    &lt;!-- Must not be the same as servlet name. --&gt;\n    &lt;portlet-name&gt;<emphasis role=\"bold\">PortletExamplePortlet</emphasis>&lt;/portlet-name&gt;\n    &lt;display-name&gt;<emphasis role=\"bold\">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;\n\n    &lt;!-- Map portlet to a servlet. --&gt;\n    &lt;portlet-class&gt;\n      com.vaadin.terminal.gwt.server.ApplicationPortlet\n    &lt;/portlet-class&gt;\n    &lt;init-param&gt;\n      &lt;name&gt;application&lt;/name&gt;\n\n      &lt;!-- Must match the servlet name in web.xml. --&gt;\n      &lt;value&gt;<emphasis role=\"bold\">PortletExample</emphasis>&lt;/value&gt;\n    &lt;/init-param&gt;\n\n    &lt;!-- Supported portlet modes and content types. --&gt;\n    &lt;supports&gt;\n      &lt;mime-type&gt;text/html&lt;/mime-type&gt;\n      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;\n      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;\n      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;\n    &lt;/supports&gt;\n\n    &lt;!-- Not always required but Liferay requires these. --&gt;\n    &lt;portlet-info&gt;\n      &lt;title&gt;<emphasis role=\"bold\">Vaadin Portlet Example</emphasis>&lt;/title&gt;\n      &lt;short-title&gt;<emphasis role=\"bold\">Portlet Example</emphasis>&lt;/short-title&gt;\n    &lt;/portlet-info&gt;\n  &lt;/portlet&gt;\n&lt;/portlet-app&gt;"
msgstr ""

#: part1-advanced.xml:1877(para) 
msgid "Enabling portlet modes enables portlet controls in the portal user interface that allow changing the mode, as described later."
msgstr ""

#: part1-advanced.xml:1884(title) 
msgid "Using a Single Widget Set"
msgstr ""

#: part1-advanced.xml:1886(para) 
msgid "If you have just one Vaadin application that you ever need to run in your portal, you can just deploy the WAR as described above and that's it. However, if you have multiple applications, especially ones that use different custom widget sets, you run into problems, because a portal window can load only a single Vaadin widget set at a time. You can solve this problem by combining all the different widget sets in your different applications into a single widget set using inheritance or composition."
msgstr ""

#: part1-advanced.xml:1897(para) 
msgid "For example, the portal demos defined in the <filename>portlet.xml</filename> in the demo WAR have the following setting that defines every portlet to use the same widget set:"
msgstr ""

#: part1-advanced.xml:1913(para) 
msgid "The <classname>SamplerWidgetSet</classname> required by the Sampler application inherits the <classname>DefaultWidgetSet</classname> so that the latter is essentially a subset of the former. Other applications requiring only the regular <classname>DefaultWidgetSet</classname> can as well use the larger set."
msgstr ""

#: part1-advanced.xml:1922(para) 
msgid "If your portlets are contained in multiple WARs, which can happen quite typically, you need to install the widget set and theme portal-wide so that all the portlets can use them. See <xref linkend=\"advanced.liferay.widgetsets\"/> on configuring the widget sets in the portal itself."
msgstr ""

#: part1-advanced.xml:1932(title) 
msgid "Liferay Portlet Descriptor"
msgstr ""

#: part1-advanced.xml:1934(para) 
msgid "Liferay requires a special <filename>liferay-portlet.xml</filename> descriptor file that defines Liferay-specific parameters. Especially, Vaadin portlets must be defined as \"<emphasis>instanceable</emphasis>\", but not \"<emphasis>ajaxable</emphasis>\"."
msgstr ""

#: part1-advanced.xml:1942(para) 
msgid "Below is an example descriptor for the earlier portlet example:"
msgstr ""

#: part1-advanced.xml:1946(programlisting) 
#, no-wrap
msgid "<?pocket-size 65% ?>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE liferay-portlet-app PUBLIC\n  \"-//Liferay//DTD Portlet Application 4.3.0//EN\"\n  \"http://www.liferay.com/dtd/liferay-portlet-app_4_3_0.dtd\"&gt;\n\n&lt;liferay-portlet-app&gt;\n    &lt;portlet&gt;\n        &lt;!-- Matches definition in portlet.xml.          --&gt;\n        &lt;!-- Note: Must not be the same as servlet name. --&gt;\n        &lt;portlet-name&gt;<emphasis role=\"bold\">PortletExamplePortlet</emphasis>&lt;/portlet-name&gt;\n\n        &lt;instanceable&gt;true&lt;/instanceable&gt;\n        &lt;ajaxable&gt;false&lt;/ajaxable&gt;\n    &lt;/portlet&gt;\n&lt;/liferay-portlet-app&gt;"
msgstr ""

#: part1-advanced.xml:1962(para) 
msgid "See Liferay documentation for further details on the <filename>liferay-portlet.xml</filename> deployment descriptor."
msgstr ""

#: part1-advanced.xml:1970(title) 
msgid "Liferay Display Descriptor"
msgstr ""

#: part1-advanced.xml:1972(para) 
msgid "The <filename>liferay-display.xml</filename> file defines the portlet category under which portlets are organized in the <guilabel>Add Application</guilabel> window in Liferay. Without this definition, portlets will be organized under the \"Undefined\" category."
msgstr ""

#: part1-advanced.xml:1979(para) 
msgid "The following display configuration, which is included in the demo WAR, puts the Vaadin portlets under the \"Vaadin\" category, as shown in <xref linkend=\"figure.advanced.liferay.descriptor.display\"/>."
msgstr ""

#: part1-advanced.xml:1997(title) 
msgid "Portlet Categories in Add Application Window"
msgstr ""

#: part1-advanced.xml:2008(para) 
msgid "See Liferay documentation for further details on how to configure the categories in the <filename>liferay-display.xml</filename> deployment descriptor."
msgstr ""

#: part1-advanced.xml:2018(title) 
msgid "Portlet Hello World"
msgstr ""

#: part1-advanced.xml:2020(para) 
msgid "The Hello World program that runs as a portlet is no different from a regular Vaadin application, as long as it doesn't need to handle portlet actions, mode changes, and so on."
msgstr ""

#: part1-advanced.xml:2040(para) 
msgid "In addition to the application class, you need the descriptor files, libraries, and other files as described earlier. <xref linkend=\"figure.advanced.liferay.helloworld.project\"/> shows the complete project structure under Eclipse."
msgstr ""

#: part1-advanced.xml:2047(title) 
msgid "Portlet Project Structure in Eclipse"
msgstr ""

#: part1-advanced.xml:2058(para) 
msgid "Installed as a portlet in Liferay from the <guilabel>Add Application</guilabel> menu, the application will show as illustrated in <xref linkend=\"figure.advanced.liferay.helloworld\"/>."
msgstr ""

#: part1-advanced.xml:2065(title) 
msgid "Hello World Portlet"
msgstr ""

#: part1-advanced.xml:2078(title) 
msgid "Installing Widget Sets and Themes in Liferay"
msgstr ""

#: part1-advanced.xml:2080(para) 
msgid "Loading widget sets and themes from a portlet WAR is possible as long as you have a single WAR, but it will not work if you have multiple WARs. To solve this, Vaadin portlets use globally installed widget sets and themes. Liferay actually includes them and the required configuration in Liferay 5.3 and later, but if you are using an earlier version of Liferay or have a customized widget set, you will need to do the configuration manually."
msgstr ""

#: part1-advanced.xml:2090(para) 
msgid "We assume that you use the Tomcat installation included in the Liferay installation package, under the <filename>tomcat-x.x.x</filename> directory."
msgstr ""

#: part1-advanced.xml:2096(para) 
msgid "The widget set needs to be located at <filename>/html/VAADIN/widgetsets/</filename> and themes at <filename>/html/VAADIN/themes/</filename> path under the portal context. You simply need to copy the contents from under your <filename>WebContent/VAADIN</filename> directory to the <filename>tomcat-x.x.x/webapps/ROOT/html/VAADIN</filename> directory under the Liferay installation directory. If you use a widget set or theme included in Vaadin, you should copy it from the Vaadin installation directory or extract them from Vaadin JAR."
msgstr ""

#: part1-advanced.xml:2108(para) 
msgid "You need to define the widget set and the theme in the <filename>portal-ext.properties</filename> configuration file for Liferay. The file should normally be placed in the Liferay installation directory and you need to restart Liferay after creating or modifying the file. See Liferay documentation for details on the configuration file."
msgstr ""

#: part1-advanced.xml:2116(para) 
msgid "Below is an example of a <filename>portal-ext.properties</filename> file:"
msgstr ""

#: part1-advanced.xml:2130(para) 
msgid "The allowed parameters are:"
msgstr ""

#: part1-advanced.xml:2136(parameter) 
msgid "vaadin.resources.path"
msgstr ""

#: part1-advanced.xml:2138(para) 
msgid "Specifies the resource root path under the portal context. This is <filename>/html</filename> by default, pointing to the <filename>webapps/ROOT/html</filename> directory under Tomcat installation directory."
msgstr ""

#: part1-advanced.xml:2145(parameter) 
msgid "vaadin.widgetset"
msgstr ""

#: part1-advanced.xml:2147(para) 
msgid "The widget set class to use. Give the full path to the class name in the dot notation. If the parameter is not given, the default widget set is used."
msgstr ""

#: part1-advanced.xml:2153(parameter) 
msgid "vaadin.theme"
msgstr ""

#: part1-advanced.xml:2155(para) 
msgid "Name of the theme to use. If the parameter is not given, the default theme is used, which is <literal>reindeer</literal> in Vaadin 6."
msgstr ""

#: part1-advanced.xml:2165(title) 
msgid "Handling Portlet Events"
msgstr ""

#: part1-advanced.xml:2167(para) 
msgid "Portals such as Liferay are not AJAX applications but reload the page every time a user interaction requires data from the server. They consider a Vaadin application as a regular (though dynamic) web page. All the AJAX communications required by the Vaadin application are done by the Vaadin Client-Side Engine (the widget set) past the portal."
msgstr ""

#: part1-advanced.xml:2175(para) 
msgid "The only way for a portal to interact with an application is to load it with a <emphasis>render request</emphasis> (reloading does not reset the application). The render requests can be caused by user interaction with the portal or by loading action URLs launched from the portlet. You can handle render requests by implementing the <classname>PortletApplicationContext.PortletListener</classname> interface and the <methodname>handleRenderRequest()</methodname> handler method. You can use the request object passed to the handler to access certain portal data, such as user information."
msgstr ""

#: part1-advanced.xml:2187(para) 
msgid "You can also define portal actions that you can handle in the <methodname>handleActionRequest()</methodname> method of the interface."
msgstr ""

#: part1-advanced.xml:2192(para) 
msgid "You add your portlet request listener to the application context of your application, which is a <classname>PortletApplicationContext</classname> when (and only when) the application is being run as a portlet."
msgstr ""

#: part1-advanced.xml:2212(para) 
msgid "The handler methods receive references to request and response objects, which are defined in the Java Servlet API. Please refer to the Servlet API documentation for further details."
msgstr ""

#: part1-advanced.xml:2218(para) 
msgid "The PortletDemo application included in the demo WAR package includes examples of processing mode and portlet window state changes in a portlet request listener."
msgstr ""

#: part1-advanced.xml:2164(section) 
msgid "<placeholder-1/><placeholder-2/><placeholder-3/><placeholder-4/> . <placeholder-5/><placeholder-6/><placeholder-7/><placeholder-8/>"
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: part1-advanced.xml:0(None) 
msgid "translator-credits"
msgstr ""

