msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2009-09-07 14:42+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-datamodel.xml:22(None) 
msgid "@@image: 'img/arch/datamodel-sml.png'; md5=3a4315678f4a1a160faa828c4298775b"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-datamodel.xml:25(None) 
msgid "@@image: 'img/arch/datamodel-whitebg.png'; md5=a5bda7ed9159bbf6a8adc6cadb73d219"
msgstr ""

#: part1-datamodel.xml:4(title) 
msgid "Binding Components to Data"
msgstr ""

#: part1-datamodel.xml:7(title) 
msgid "Overview"
msgstr ""

#: part1-datamodel.xml:9(para) 
msgid "The Vaadin Data Model is one of the core concepts of the library. To allow the view (user interface components) to access the application data directly, we have introduced a standard data interface. Application data needs a common interface so that the data can be accessed by the view and the controller alike. In Vaadin, we have solved this with the Data Model."
msgstr ""

#: part1-datamodel.xml:19(title) 
msgid "Vaadin Data Model"
msgstr ""

#: part1-datamodel.xml:30(para) 
msgid "The Vaadin Data Model allows binding user interface components directly to the data they show and modify. There are three nested levels of hierarchy in the data model: <emphasis>property</emphasis>, <emphasis>item</emphasis> and <emphasis>container</emphasis>. Using a spreadsheet application as an analogy, these would correspond to the data underlying a cell, a row and a table, respectively. The components would display the data in these and optionally allow direct editing of the corresponding entities."
msgstr ""

#: part1-datamodel.xml:40(para) 
msgid "The Data Model is realized as a set of interface classes in the fittingly named package <classname>com.vaadin.data</classname>. The package contains the interfaces <classname>Property</classname>, <classname>Item</classname>, and <classname>Container</classname>, along with a number of more specialized interfaces and classes."
msgstr ""

#: part1-datamodel.xml:48(para) 
msgid "Notice that the Data Model does not define data representation, but only interfaces. This leaves the representation fully to the implementation of the containers. The representation can be almost anything, such as a Java object structure, a filesystem, or a database query."
msgstr ""

#: part1-datamodel.xml:55(para) 
msgid "The Data Model is used heavily in UI components of Vaadin. A key feature of all UI components is that they can either maintain their data by themselves or be bound to an external data source. Various components also implement some of these interfaces themselves, so you can actually use them as data sources for other components."
msgstr ""

#: part1-datamodel.xml:63(para) 
msgid "The Data Model has many important and useful features, such as support for change notification, transactions, validation, and lazy loading."
msgstr ""

#: part1-datamodel.xml:73(title) 
msgid "Properties"
msgstr ""

#: part1-datamodel.xml:75(para) 
msgid "Vaadin data model is one of the core concepts in the library and the <classname>Property</classname>-interface is the base of that model. Property provides a standardized API for a single data object that can be read (get) and written (set). A property is always typed, but can optionally support data type conversions. The type of a property can be any Java class. Optionally, properties can provide value change events for following their changes."
msgstr ""

#. TODO this might not be the best place to explain this - maybe split the paragraph?
#: part1-datamodel.xml:85(para) 
msgid "Properties are in themselves unnamed objects. Properties are collected in an <emphasis>item</emphasis>, which associates the properties with names, the <emphasis>Property Identifiers</emphasis> or <emphasis>PID</emphasis>s. Items can be contained in containers and are identified with <emphasis>Item Identifiers</emphasis> or <emphasis>IID</emphasis>s. In the spreadsheet analogy, <emphasis>Property Identifiers</emphasis> would correspond to column names and <emphasis>Item Identifiers</emphasis> to row names. The identifiers can be arbitrary objects, but should implement the <methodname>equals(Object)</methodname> and <methodname>hashCode()</methodname> methods so that they can be used in any standard Java <classname>Collection</classname>."
msgstr ""

#: part1-datamodel.xml:98(para) 
msgid "The most important function of the Property as well as other data models is to connect classes implementing the interface directly to editor and viewer classes. Typically this is used to connect different data sources to UI components for editing and viewing their contents."
msgstr ""

#: part1-datamodel.xml:105(para) 
msgid "Properties can be utilized either by implementing the interface or by using some of the existing property implementations. Vaadin includes <classname>Property</classname> interface implementations for arbitrary function pairs or Bean-properties as well as simple object properties."
msgstr ""

#: part1-datamodel.xml:112(para) 
msgid "Many of the UI components also implement Property interface and allow setting of other components as their data-source. Simple UI-components that control a single property (their displayed value or state) include various <classname>Field</classname> implementations such as <classname>TextField</classname>, <classname>DateField</classname> and <classname>Button</classname> as well as the <classname>Label</classname>. You can access this property through the <classname>Property</classname> interface inherited by the components."
msgstr ""

#: part1-datamodel.xml:123(para) 
msgid "In addition to the simple components, a variety of selectable components such as Select, Table and Tree have a property that contains their current selection (the identifier of the selected item or a set of item identifiers)."
msgstr ""

#: part1-datamodel.xml:129(para) 
msgid "Components manage their <emphasis>property</emphasis> by default using an internal data source object, in which case the property is contained within the component, but you can bind the the components to external data sources with the <methodname>setPropertyDataSource()</methodname> method of the <classname>com.vaadin.ui.AbstractField</classname> class inherited by such components."
msgstr ""

#: part1-datamodel.xml:141(title) 
msgid "Holding properties in Items"
msgstr ""

#: part1-datamodel.xml:143(para) 
msgid "<classname>Item</classname> is an object that contains a set of named properties. Each property is identified by a property identifier (PID) and a reference to the property can be queried from the <classname>Item</classname>. <classname>Item</classname> defines inner interfaces for maintaining the item property set and listening changes in the item property set. Concrete examples or items include a row in a table (with its properties corresponding to cells on the row), the data underlying a form (with properties corresponding to individual fields) or a node in a filesystem tree."
msgstr ""

#: part1-datamodel.xml:154(para) 
msgid "In addition to being used indirectly by many user interface components, items provide the basic data model underlying <classname>Form</classname> components. In simple cases, forms can even be generated automatically from items. The properties of the item correspond to the fields of the form."
msgstr ""

#: part1-datamodel.xml:161(para) 
msgid "Items generally represent objects in the object-oriented model, but with the exception that they are configurable and provide an event mechanism. The simplest way of utilizing <classname>Item</classname> interface is to use existing Item implementations. Provided utility classes include a configurable property set (<classname>PropertySetItem</classname>) and a bean-to-item adapter (<classname>BeanItem</classname>), in addition to which a <classname>Form</classname> can also be used directly as an item."
msgstr ""

#: part1-datamodel.xml:173(title) 
msgid "Collecting items in Containers"
msgstr ""

#: part1-datamodel.xml:175(para) 
msgid "Container is the most advanced of the data model supported by Vaadin. It provides a very flexible way of managing a set of items that share common properties. Each item is identified by an item id. Properties can be requested from container with item and property ids. Another way of accessing properties is to first request an item from container and then request its properties from it."
msgstr ""

#: part1-datamodel.xml:183(para) 
msgid "By implementing a container interface, you can bind UI components directly to data. As containers can be unordered, ordered, indexed, or hierarchical, they can interface practically any kind of data representation. Vaadin includes data connectors for some common data sources, such as the simple data tables and filesystem."
msgstr ""

#: part1-datamodel.xml:191(para) 
msgid "The <classname>Container</classname> interface was designed with flexibility and efficiency in mind. It contains inner interfaces that containers can optionally implement for ordering the items sequentially, indexing the items and accessing them hierarchically. Those ordering models provide the basis for the <classname>Table</classname>, <classname>Tree</classname>, and <classname>Select</classname> UI components. As with other data models, the containers support events for notifying about changes made to their contents."
msgstr ""

#: part1-datamodel.xml:201(para) 
msgid "In addition to separate container objects, also many UI components are containers in addition to being properties. This is especially true for selectable components (that implement <classname>Select</classname>), because they are containers that contain selectable items. Their property is the currently selected item. This is useful as it enables binding components to view and update each others' data directly, and makes it easy to reuse already constructed data models - e.g. a form could edit a row (item) of a table directly, and the table could use a database container as its underlying container. The fields of the form would correspond to the properties of the item, i.e. the cells of the table row. For more details on components, see <xref linkend=\"components\"/>."
msgstr ""

#: part1-datamodel.xml:216(para) 
msgid "The library contains a set of utilities for converting between different container implementations by adding external ordering or hierarchy into existing containers. In-memory containers implementing indexed and hierarchical models provide easy-to-use tools for setting up in-memory data storages. Such default container implementations include <classname>IndexedContainer</classname>, which can be thought of as a generalization of a two-dimensional data table, and <classname>BeanItemContainer</classname> which maps standard Java objects (beans) to items of an indexed container. In addition, the default containers include a hierarchical container for direct file system browsing."
msgstr ""

#: part1-datamodel.xml:229(title) 
msgid "Iterating Over a Container"
msgstr ""

#: part1-datamodel.xml:231(para) 
msgid "As the items in a <classname>Container</classname> are not necessarily indexed, iterating over the items has to be done using an <classname>Iterator</classname>. The <methodname>getItemIds()</methodname> method of <classname>Container</classname> returns a <classname>Collection</classname> of item identifiers over which you can iterate. The following example demonstrates a typical case where you iterate over the values of check boxes in a column of a <classname>Table</classname> component. The context of the example is the example used in <xref linkend=\"components.table\"/>."
msgstr ""

#: part1-datamodel.xml:270(para) 
msgid "Notice that the <methodname>getItemIds()</methodname> returns an <emphasis>unmodifiable collection</emphasis>, so the <classname>Container</classname> may not be modified during iteration. You can not, for example, remove items from the <classname>Container</classname> during iteration. The modification includes modification in another thread. If the <classname>Container</classname> is modified during iteration, a <classname>ConcurrentModificationException</classname> is thrown and the iterator may be left in an undefined state."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: part1-datamodel.xml:0(None) 
msgid "translator-credits"
msgstr ""

