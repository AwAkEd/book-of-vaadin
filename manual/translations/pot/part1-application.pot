msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2009-09-07 14:42+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:38(None) 
msgid "@@image: 'img/application/application-architecture-lo.png'; md5=cd359de31808375e48f5fe3075f5befe"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:41(None) 
msgid "@@image: 'img/application/application-architecture-hi.png'; md5=36a12aabe2f4342b1d06025e968980f4"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:402(None) part1-application.xml:405(None) 
msgid "@@image: 'img/layout/window_openexample.png'; md5=af813f6fc2787fd50134d9f84c2d6d8e"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:530(None) part1-application.xml:533(None) 
msgid "@@image: 'img/layout/window_modal.png'; md5=2cb5b09b32a24c7e548d8645329e5b36"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:793(None) 
msgid "@@image: 'img/application/resource_classdiagram-lo.png'; md5=50058db0c91dfc2e518d466659079aa0"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:796(None) 
msgid "@@image: 'img/application/resource_classdiagram-hi.png'; md5=cac055c6a519c79ed53ff436aa7c867b"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:981(None) part1-application.xml:984(None) 
msgid "@@image: 'img/application/application_streamresource.png'; md5=5d1d5a8e79feaf3b0dda156a8db3746b"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1165(None) part1-application.xml:1168(None) 
msgid "@@image: 'img/application/errorindicator-example2.png'; md5=fae5777fd137c55514b1d458b5f9463b"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1212(None) part1-application.xml:1215(None) 
msgid "@@image: 'img/application/notification-example2.png'; md5=78e3bca4bcf638136576c62dfc246472"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1235(None) part1-application.xml:1238(None) 
msgid "@@image: 'img/application/notification-example3.png'; md5=5b054039cb7abe6ccf6990ece76be026"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1256(None) part1-application.xml:1259(None) 
msgid "@@image: 'img/application/notification-humanized.png'; md5=c96ad7832483451d80a2a7fb8e15f960"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1276(None) part1-application.xml:1279(None) 
msgid "@@image: 'img/application/notification-warning.png'; md5=0c809981e22442bf145b7bcb5b893176"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1298(None) part1-application.xml:1301(None) 
msgid "@@image: 'img/application/notification-error.png'; md5=d7e79bb37bb39dc9a66f1ccfc6d05dae"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1323(None) part1-application.xml:1326(None) 
msgid "@@image: 'img/application/notification-tray.png'; md5=d011262e9c0dc9bdc6741a4579ea9299"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-application.xml:1467(None) part1-application.xml:1470(None) 
msgid "@@image: 'img/application/errorindicator-exception.png'; md5=72fd048e26119bec200d88c6e125868a"
msgstr ""

#: part1-application.xml:4(title) 
msgid "Writing a Web Application"
msgstr ""

#. TODO: Too much stuff in the chapter intro - move to overview.
#: part1-application.xml:8(para) 
msgid "This chapter provides the fundamentals of web application development with Vaadin, concentrating on the basic elements of an application from a practical point-of-view."
msgstr ""

#: part1-application.xml:14(para) 
msgid "If you are a newcomer to AJAX development, you may benefit from <xref linkend=\"advanced.application.pages\"/>. It explains the role of pages in AJAX web applications, and provides some basic design patterns for applications."
msgstr ""

#: part1-application.xml:21(title) 
msgid "Overview"
msgstr ""

#: part1-application.xml:23(para) 
msgid "An application made with Vaadin runs as a Java Servlet in a Servlet container. The entry-point is the application class, which needs to create and manage all necessary user interface components, including windows. User interaction is handled with event listeners, simplified by binding user interface components directly to data. Visual appearance is defined in themes as CSS files. Icons, other images, and downloadable files are handled as <emphasis>resources</emphasis>, which can be external or served by the application server or the application itself."
msgstr ""

#: part1-application.xml:35(title) 
msgid "Application Architecture"
msgstr ""

#: part1-application.xml:46(para) 
msgid "<xref linkend=\"figure.application.architecture\"/> above gives the basic architecture of an application made with the Vaadin framework, with all the major elements, which are introduced below and discussed in detail in this chapter."
msgstr ""

#: part1-application.xml:53(para) 
msgid "First of all, an application that uses Vaadin must define an application class that inherits the abstract <classname>com.vaadin.Application</classname> class. The application class must implement the <methodname>init()</methodname> method."
msgstr ""

#: part1-application.xml:67(para) 
msgid "Besides acting as the entry-point in the servlet, the <classname>Application</classname> class provides facilities for window access, execution control, and theme selection. The application API may seem similar to Java Servlet API, but that is only superficial. Vaadin framework associates requests with sessions so that an application class instance is really a session object. Because of this, you can develop web applications much like you would develop desktop applications."
msgstr ""

#: part1-application.xml:77(para) 
msgid "The most important thing in the initialization is the creation of the main window (see below), which any application has. This, and the deployment of the application as a Java Servlet in the Servlet container, as described in <xref linkend=\"application.environment\"/>, are the minimal requirements for an application."
msgstr ""

#: part1-application.xml:85(para) 
msgid "Below is a short overview of the basic elements of an application:"
msgstr ""

#: part1-application.xml:91(term) 
msgid "Windows"
msgstr ""

#: part1-application.xml:93(para) 
msgid "An application always has a <emphasis>main window</emphasis>, as described in <xref linkend=\"application.main-window\"/>. An application can actually have a number of such application-level windows, all bound to the same application session, as described in <xref linkend=\"application.windows\"/>. Application-level windows can contain non-native sub-windows, which are essentially floating layout components handled inside the browser."
msgstr ""

#: part1-application.xml:106(term) 
msgid "User Interface Components"
msgstr ""

#: part1-application.xml:108(para) 
msgid "The user interface consists of UI components that are created and laid out by the application. User interaction with the components causes events (see below) related to the component, which the application must handle. Most components are bound to some data using the Data Model (see below). You can make your own UI components through either inheritance or composition. For a thorough reference of UI components, see <xref linkend=\"components\"/>, for layout components, see <xref linkend=\"layout\"/>, and for composing components, see <xref linkend=\"components.customcomponent\"/>."
msgstr ""

#: part1-application.xml:124(term) 
msgid "Events and Listeners"
msgstr ""

#: part1-application.xml:126(para) 
msgid "Events, and listeners that handle events, are the basis of handling user interaction in an application. <xref linkend=\"architecture.events\"/> gave an introduction to events and listeners from an architectural point-of-view, while <xref linkend=\"application.events\"/> later in this chapter takes a more practical view."
msgstr ""

#: part1-application.xml:138(term) 
msgid "Resources"
msgstr ""

#: part1-application.xml:140(para) 
msgid "A user interface can display images or have links to web pages or downloadable documents. These are <emphasis>resources</emphasis>, which can be external or provided by the web server or the application itself. <xref linkend=\"application.resources\"/> gives a practical overview of the different types of resources."
msgstr ""

#: part1-application.xml:151(term) 
msgid "Themes"
msgstr ""

#: part1-application.xml:153(para) 
msgid "The presentation and logic of the user interface are separated. While the UI logic is handled as Java code, the presentation is defined in <emphasis>themes</emphasis> as CSS. Vaadin provides a default theme. User-defined themes can, in addition to style sheets, include HTML templates that define custom layouts and other theme resources, such as images. Themes are discussed in detail in <xref linkend=\"themes\"/>, custom layouts in <xref linkend=\"layout.customlayout\"/>, and theme resources in <xref linkend=\"application.resources.theme\"/>."
msgstr ""

#: part1-application.xml:168(term) 
msgid "Data Binding"
msgstr ""

#: part1-application.xml:170(para) 
msgid "Field components are essentially views to data, represented in a <emphasis>data model</emphasis>. Using the data model, the components can update the application data directly, without the need for any control code. A field component model is always bound to a <emphasis>property</emphasis>, an <emphasis>item</emphasis>, or a <emphasis>container</emphasis>, depending on the field type. While all the components have a default data model, they can be bound to a user-defined data source. For example, you can bind a table component to an SQL query response. For a complete overview of data binding in Vaadin, please refer to <xref linkend=\"datamodel\"/>."
msgstr ""

#: part1-application.xml:189(title) 
msgid "Managing the Main Window"
msgstr ""

#: part1-application.xml:191(para) 
msgid "As explained in <xref linkend=\"advanced.application.pages\"/>, an AJAX web application usually runs in a single \"web page\" in a browser window. The page is generally not reloaded after it is opened initially, but it communicates user interaction with the server through AJAX communications. A window in an AJAX application is therefore more like a window in a desktop application and less like a web page."
msgstr ""

#: part1-application.xml:200(para) 
msgid "A <classname>Window</classname> is the top-level container of a user interface displayed in a browser window. As an AJAX application typically runs on a single \"page\" (URL), there is usually just one window -- the main window. The main window can be accessed using the URL of the application. You set the main window with the <methodname>setMainWindow()</methodname> method of the <classname>Application</classname> class."
msgstr ""

#: part1-application.xml:209(programlisting) 
#, no-wrap
msgid "<?pocket-size 75% ?>import com.vaadin.ui.*;\n\npublic class HelloWorld extends com.vaadin.Application {\n    public void init() { \n        Window main = new Window(\"The Main Window\"); \n        setMainWindow(main);\n\n        <emphasis>... fill the main window with components ...</emphasis>\n    }\n}"
msgstr ""

#: part1-application.xml:220(para) 
msgid "You can add components to the main window, or to any other window, with the <classname>addComponent()</classname> method, which actually adds the given component to the root layout component bound to the window. If you wish to use other than the default root layout, you can set it with <methodname>setContent()</methodname>, as explained in <xref linkend=\"layout.root-layout\"/>."
msgstr ""

#: part1-application.xml:229(para) 
msgid "Vaadin has two basic kinds of windows: <emphasis>application-level windows</emphasis>, such as the main window, and <emphasis>child windows</emphasis> (or sub-windows) inside the application-level windows. The child windows are explained in the next section, while application-level windows are covered in <xref linkend=\"application.windows\"/>."
msgstr ""

#: part1-application.xml:239(title) 
msgid "Child Windows"
msgstr ""

#: part1-application.xml:241(para) 
msgid "An application-level window can have a number of floating child windows. They are managed by the client-side JavaScript runtime of Vaadin using HTML features. Vaadin allows opening and closing child windows, refreshing one window from another, resizing windows, and scrolling the window content. Child windows are typically used for <firstterm>Dialog Windows</firstterm> and <firstterm>Multiple Document Interface</firstterm> applications. Child windows are by default not modal; you can set them modal as described in <xref linkend=\"application.child-windows.modal\"/>."
msgstr ""

#: part1-application.xml:252(para) 
msgid "As with all user interface components, the appearance of a window and its contents is defined with themes."
msgstr ""

#: part1-application.xml:257(para) 
msgid "User control of a child window is limited to moving, resizing, and closing the window. Maximizing or minimizing are not yet supported."
msgstr ""

#: part1-application.xml:263(title) 
msgid "Opening and Closing a Child Window"
msgstr ""

#: part1-application.xml:265(para) 
msgid "You can open a new window by creating a new <classname>Window</classname> object and adding it to the main window with <methodname>addWindow()</methodname> method of the <classname>Application</classname> class."
msgstr ""

#: part1-application.xml:275(para) 
msgid "You close the window in a similar fashion, by calling the <methodname>removeWindow()</methodname> of the <classname>Application</classname> class:"
msgstr ""

#: part1-application.xml:283(para) 
msgid "The user can, by default, close a child window by clicking the close button in the upper-right corner of the window. You can disable the button by setting the window as <emphasis>read-only</emphasis> with <methodname>setReadOnly(true)</methodname>. Notice that you could disable the button also by making it invisible in CSS with a \"<parameter>display: none</parameter>\" formatting. The problem with such a cosmetic disabling is that a malicious user might re-enable the button and close the window, which might cause problems and possibly be a security hole. Setting the window as read-only not only disables the close button on the client side, but also prevents processing the close event on the server side."
msgstr ""

#: part1-application.xml:296(para) 
msgid "The following example demonstrates the use of a child window in an application. The example manages the window using a custom component that contains a button for opening and closing the window."
msgstr ""

#: part1-application.xml:371(para) 
msgid "The example implements a custom component that inherits the <classname>CustomComponent</classname> class. It consists of a <classname>Button</classname> that it uses to open a window and a <classname>Label</classname> to describe the state of the window. When the window is open, the button is disabled. When the window is closed, the button is enabled again."
msgstr ""

#: part1-application.xml:382(para) 
msgid "You can use the above custom component in the application class with:"
msgstr ""

#: part1-application.xml:386(programlisting) 
#, no-wrap
msgid "<?pocket-size 75% ?> public void init() { \n    Window main = new Window(\"The Main Window\"); \n    setMainWindow(main);\n\n    addComponent(new WindowOpener(\"Window Opener\", main));\n}"
msgstr ""

#: part1-application.xml:393(para) 
msgid "When added to an application, the screen will look as illustrated in the following screenshot:"
msgstr ""

#: part1-application.xml:399(title) 
msgid "Opening a Child Window"
msgstr ""

#: part1-application.xml:413(title) 
msgid "Window Positioning"
msgstr ""

#: part1-application.xml:415(para) 
msgid "When created, a window will have a default size and position. You can specify the size of a window with <methodname>setHeight()</methodname> and <methodname>setWidth()</methodname> methods. You can set the position of the window with <methodname>setPositionX()</methodname> and <methodname>setPositionY()</methodname> methods."
msgstr ""

#: part1-application.xml:435(para) 
msgid "Notice that the size of the main window is unknown and the <methodname>getHeight</methodname> and <methodname>getWidth</methodname> methods will return <returnvalue>-1</returnvalue>."
msgstr ""

#: part1-application.xml:512(title) 
msgid "Modal Windows"
msgstr ""

#: part1-application.xml:514(para) 
msgid "A modal window is a child window that has to be closed by the user before the use of the parent window can continue. Dialog windows are typically modal. The advantage of modal windows is the simplification of user interaction, which may contribute to the clarity of the user interface. Modal windows are also easy to use from a development perspective, because as user interaction is isolated to them, changes in application state are more limited while the modal window is open. The disadvantage of modal windows is that they can restrict workflow too much."
msgstr ""

#: part1-application.xml:527(title) 
msgid "Screenshot of the Modal Window Demo Application"
msgstr ""

#: part1-application.xml:538(para) 
msgid "Depending on theme settings, the parent window may be grayed while the modal window is open."
msgstr ""

#: part1-application.xml:543(para) 
msgid "The demo application of Vaadin includes an example of using modal windows. <xref linkend=\"figure.window.modal\"/> above is from the demo application. The example includes the source code."
msgstr ""

#: part1-application.xml:551(title) 
msgid "Security Warning"
msgstr ""

#: part1-application.xml:552(para) 
msgid "Modality of child windows is purely a client-side feature and can be circumvented with client-side attack code. You should not trust in the modality of child windows in security-critical situations such as login windows."
msgstr ""

#: part1-application.xml:563(title) 
msgid "Handling Events with Listeners"
msgstr ""

#: part1-application.xml:565(para) 
msgid "Let us put into practice what we learned of event handling in <xref linkend=\"architecture.events\"/>. You can handle events in three basic ways, as shown below."
msgstr ""

#: part1-application.xml:571(para) 
msgid "The following example follows a typical pattern where you have a <classname>Button</classname> component and a listener that handles user interaction (clicks) communicated to the application as events. Here we define a class that listens click events."
msgstr ""

#: part1-application.xml:594(para) 
msgid "As an application often receives events for several components of the same class, such as multiple buttons, it has to be able to distinguish between the individual components. There are several techniques to do this, but probably the easiest is to use the property of the received event, which is set to the object sending the event. This requires keeping at hand a reference to every object that emits events."
msgstr ""

#: part1-application.xml:628(para) 
msgid "Another solution to handling multiple events of the same class involves attaching an event source to a listener method instead of the class. An event can be attached to a method using another version of the <methodname>addListener()</methodname> method, which takes the event handler method as a parameter either as a name of the method name as a string or as a <classname>Method</classname> object. In the example below, we use the name of the method as a string."
msgstr ""

#: part1-application.xml:664(para) 
msgid "Adding a listener method with <methodname>addListener()</methodname> is really just a wrapper that creates a <classname>com.vaadin.event.ListenerMethod</classname> listener object, which is an adapter from a listener class to a method. It implements the <classname>java.util.EventListener</classname> interface and can therefore work for any event source using the interface. Notice that not all listener classes necessarily inherit the <classname>EventListener</classname> interface."
msgstr ""

#: part1-application.xml:676(para) 
msgid "The third way, which uses anonymous local class definitions, is often the easiest as it does not require cumbering the managing class with new interfaces or methods. The following example defines an anonymous class that inherits the <classname>Button.ClickListener</classname> interface and implements the <methodname>buttonClick()</methodname> method."
msgstr ""

#: part1-application.xml:712(para) 
msgid "Other techniques for separating between different sources also exist. They include using object properties, names, or captions to separate between them. Using captions or any other visible text is generally discouraged, as it may create problems for internationalization. Using other symbolic strings can also be dangerous, because the syntax of such strings is checked only runtime."
msgstr ""

#: part1-application.xml:722(para) 
msgid "Events are usually emitted by the framework, but applications may need to emit them too in some situations, such as when updating some part of the UI is required. Events can be emitted using the <methodname>fireEvent(Component.Event)</methodname> method of <classname>AbstractComponent</classname>. The event is then relayed to all the listeners of the particular event class for the object. Some components have a default event type, for example, a <classname>Button</classname> has a nested <classname>Button.ClickEvent</classname> class and a corresponding <classname>Button.ClickListener</classname> interface. These events can be triggered with <methodname>fireComponentEvent()</methodname>."
msgstr ""

#: part1-application.xml:738(title) 
msgid "Referencing Resources"
msgstr ""

#: part1-application.xml:740(para) 
msgid "Web applications work over the web and have various resources, such as images or downloadable files, that the web browser has to get from the server. These resources are typically used in <classname>Embedded</classname> (images) or <classname>Link</classname> (downloadable files) user interface components. Various components, such as <classname>TabSheet</classname>, can also include icons, which are also handled as resources."
msgstr ""

#: part1-application.xml:751(para) 
msgid "A web server can handle many of such requests for static resources without having to ask them from the application, or the <classname>Application</classname> object can provide them. For dynamic resources, the user application must be able to create them dynamically. Vaadin provides resource request interfaces for applications so that they can return various kinds of resources, such as files or dynamically created resources. These include the <classname>StreamResource</classname> class and URI and parameter handlers described in <xref linkend=\"section.application.resources.uri\"/> and <xref linkend=\"section.application.resources.parameters\"/>, respectively."
msgstr ""

#: part1-application.xml:764(para) 
msgid "Vaadin provides also low-level facilities for retrieving the URI and other parameters of a HTTP request. We will first look into how applications can provide various kinds of resources and then look into low-level interfaces for handling URIs and parameters to provide resources and functionalities."
msgstr ""

#: part1-application.xml:772(para) 
msgid "Notice that using URI or parameter handlers to create \"pages\" is not meaningful in Vaadin or in AJAX applications generally. Please see <xref linkend=\"advanced.application.pages\"/> for a detailed explanation."
msgstr ""

#: part1-application.xml:780(title) 
msgid "Resource Interfaces and Classes"
msgstr ""

#: part1-application.xml:782(para) 
msgid "Vaadin has two interfaces for resources: a generic <classname>Resource</classname> interface and a more specific <classname>ApplicationResource</classname> interface for resources provided by the application."
msgstr ""

#: part1-application.xml:790(title) 
msgid "Resource Interface and Class Diagram"
msgstr ""

#: part1-application.xml:801(para) 
msgid "<classname>ApplicationResource</classname> resources are managed by the <classname>Application</classname> class. When you create such a resource, you give the application object to the constructor. The constructor registers the resource in the application using the <classname>addResource</classname> method."
msgstr ""

#: part1-application.xml:810(para) 
msgid "<classname>Application</classname> manages requests for the resources and allows accessing resources using a URI. The URI consists of the base name of the application and a relative name of the resource. The relative name is <literal>\"APP/\"+resourceid+\"/\"+filename</literal>, for example <literal>\"APP/1/myimage.png\"</literal>. The <varname>resourceid</varname> is a generated numeric identifier to make resources unique, and <varname>filename</varname> is the file name of the resource given in the constructor of its class. However, the application using a resource does not usually need to consider its URI. It only needs to give the resource to an appropriate <classname>Embedded</classname> or <classname>Link</classname> or some other user interface component, which manages the rendering of the URI."
msgstr ""

#: part1-application.xml:832(title) 
msgid "File Resources"
msgstr ""

#: part1-application.xml:834(para) 
msgid "File resources are files stored anywhere in the file system. The use of file resources generally falls into two main categories: downloadable files and embedded images."
msgstr ""

#: part1-application.xml:840(para) 
msgid "A file object that can be accessed as a file resource is defined with the standard <classname>java.io.File</classname> class. You can create the file either with an absolute or relative path, but the base path of the relative path depends on the installation of the web server. For example, in Apache Tomcat, the default current directory is the installation path of Tomcat."
msgstr ""

#: part1-application.xml:853(title) 
msgid "Class Loader Resources"
msgstr ""

#: part1-application.xml:855(para) 
msgid "The <classname>ClassResource</classname> allows resources to be loaded from the deployed package of the application using Java Class Loader. The one-line example below loads an image resource from the application package and displays it in an <classname>Embedded</classname> component."
msgstr ""

#: part1-application.xml:870(title) 
msgid "Theme Resources"
msgstr ""

#. TODO: Extend.
#: part1-application.xml:873(para) 
msgid "Theme resources are files included in a theme, typically images. See <xref linkend=\"themes\"/> for more information on themes."
msgstr ""

#: part1-application.xml:880(title) 
msgid "Stream Resources"
msgstr ""

#: part1-application.xml:882(para) 
msgid "Stream resources are application resources that allow creating dynamic resource content. Charts are typical examples of dynamic images. To define a stream resource, you need to implement the <classname>StreamResource.StreamSource</classname> interface and its <methodname>getStream</methodname> method. The method needs to return an <classname>InputStream</classname> from which the stream can be read."
msgstr ""

#: part1-application.xml:892(para) 
msgid "The following example demonstrates the creation of a simple image in PNG image format."
msgstr ""

#: part1-application.xml:935(para) 
msgid "The content of the generated image is dynamic, as it updates the reloads counter with every call. The <classname>ImageIO</classname>.<methodname>write()</methodname> method writes the image to an output stream, while we had to return an input stream, so we stored the image contents to a temporary buffer."
msgstr ""

#: part1-application.xml:944(para) 
msgid "You can use resources in various ways. Some user interface components, such as <classname>Link</classname> and <classname>Embedded</classname>, take their parameters as a resource."
msgstr ""

#: part1-application.xml:950(para) 
msgid "Below we display the image with the <classname>Embedded</classname> component. The <classname>StreamResource</classname> constructor gets a reference to the application and registers itself in the application's resources. Assume that <varname>main</varname> is a reference to the main window and <varname>this</varname> is the application object."
msgstr ""

#: part1-application.xml:973(para) 
msgid "The image will look as follows:"
msgstr ""

#: part1-application.xml:978(title) 
msgid "Screenshot of the stream resource example with an embedded image"
msgstr ""

#: part1-application.xml:989(para) 
msgid "We named the resource as <filename>myimage.png</filename>. The application adds a resource key to the file name of the resource to make it unique. The full URI will be like <uri>http://localhost:8080/testbench/APP/1/myimage.png</uri>. The end <uri>APP/1/myimage.png</uri> is the <emphasis>relative</emphasis> part of the URI. You can get the relative part of a resource's URI from the application with <methodname>Application.getRelativeLocation()</methodname>."
msgstr ""

#: part1-application.xml:1000(para) 
msgid "Another solution for creating dynamic content is an URI handler, possibly together with a parameter handler. See <xref linkend=\"section.application.resources.uri\"/> and <xref linkend=\"section.application.resources.parameters\"/>."
msgstr ""

#: part1-application.xml:1018(title) 
msgid "Shutting Down an Application"
msgstr ""

#: part1-application.xml:1020(para) 
msgid "A user can log out or close the web page or browser, so a session and the associated application instance can end. Ending an application can be initiated by the application logic. Otherwise, it will be ended automatically when the Servlet session times out."
msgstr ""

#: part1-application.xml:1028(title) 
msgid "Closing an Application"
msgstr ""

#: part1-application.xml:1030(para) 
msgid "If the user quits the application through the user interface, an event handler should call the <methodname>close()</methodname> method in the <classname>Application</classname> class to shutdown the session."
msgstr ""

#: part1-application.xml:1036(para) 
msgid "In the following example, we have a <guibutton>Logout</guibutton> button, which ends the user session."
msgstr ""

#: part1-application.xml:1052(para) 
msgid "You will soon notice that closing the application simply reloads the application with a new <classname>Application</classname> instance. You can set the window to redirect to a different URL (that does not reload the application) with <methodname>setLogoutURL</methodname>. In your application class, write:"
msgstr ""

#: part1-application.xml:1066(title) 
msgid "Handling the Closing of a Window"
msgstr ""

#: part1-application.xml:1068(para) 
msgid "Closing the main window (or all application-level windows) does not close session and the application instance will be left hanging. You need to program such behaviour by handling the close events of the windows."
msgstr ""

#: part1-application.xml:1074(para) 
msgid "If the user closes a browser window, such as the main window or any other application-level window, the window will send a final AJAX request to the server, which will fire a <classname>Window.CloseEvent</classname> for the closed window. You can handle the event with a <classname>Window.CloseListener</classname>. In case the user closes the browser, the event is fired for every open window."
msgstr ""

#: part1-application.xml:1092(para) 
msgid "Notice that <emphasis>refreshing a window means closing and reopening it</emphasis>. Therefore, if you have a close handler as above, the user loses the possibility to refresh the browser window."
msgstr ""

#: part1-application.xml:1098(para) 
msgid "In the likely case that the browser crashes, no close event is communicated to the server. As the server has no way of knowing about the problem, and the session will be left hanging until the session timeout expires. During this time, the user can restart the browser, open the application URL, and the main window will be rendered where the user left off. This can be desired behaviour in many cases, but sometimes it is not and can create a security problem."
msgstr ""

#: part1-application.xml:1110(title) 
msgid "Handling Errors"
msgstr ""

#: part1-application.xml:1113(title) 
msgid "Error Indicator and message"
msgstr ""

#: part1-application.xml:1115(para) 
msgid "All components have a built-in error indicator that can be set explicitly with <methodname>setComponentError()</methodname> or can be turned on implicitly if validating the component fails. As with component caption, the placement of the indicator is managed by the layout in which the component is contained. Usually, the error indicator is placed right of the caption text. Hovering the mouse pointer over the field displays the error message."
msgstr ""

#: part1-application.xml:1125(para) 
msgid "The following example shows how you can set the component error explicitly. The example essentially validates field value without using an actual validator."
msgstr ""

#: part1-application.xml:1162(title) 
msgid "Error indicator active"
msgstr ""

#: part1-application.xml:1173(para) 
msgid "The <classname>Form</classname> component handles and displays also the errors of its contained fields so that it displays both the error indicator and the message in a special error indicator area. See <xref linkend=\"components.form\"/> and <xref linkend=\"components.form.validation\"/> for details on the <classname>Form</classname> component and validation of form input."
msgstr ""

#: part1-application.xml:1184(title) 
msgid "Notifications"
msgstr ""

#: part1-application.xml:1186(para) 
msgid "Notifications are error or information boxes that appear typically at the center of the screen. A notification box has a caption and optional description and icon. The box stays on the screen either for a defined time or until the user clicks it. The notification type defines the default appearance and behaviour of a notification."
msgstr ""

#: part1-application.xml:1194(para) 
msgid "Notifications are always associated with a window object, which can be a child window (the positioning is always relative to the entire browser view). The <classname>Window</classname> class provides a <methodname>showNotification()</methodname> method for displaying notifications. The method takes the caption and an optional description and notification type as parameters. The method also accepts a notification object of type <classname>Window.Notification</classname>, as described further below."
msgstr ""

#: part1-application.xml:1209(title) 
msgid "Notification"
msgstr ""

#: part1-application.xml:1220(para) 
msgid "The caption and description are, by default, written on the same line. If you want to have a line break between them, use the XHTML line break markup \"<literal>&lt;br/&gt;</literal>\". You can use any XHTML markup in the caption and description of a notification."
msgstr ""

#: part1-application.xml:1232(title) 
msgid "Notification with Formatting"
msgstr ""

#: part1-application.xml:1243(para) 
msgid "The notification type defines the overall default style and behaviour of a notification. If no notification type is given, the \"humanized\" type is used as the default. The notification types, listed below, are defined in the <classname>Window.Notification</classname> class."
msgstr ""

#: part1-application.xml:1253(parameter) 
msgid "TYPE_HUMANIZED_MESSAGE"
msgstr ""

#: part1-application.xml:1264(para) 
msgid "A user-friendly message that does not annoy too much: it does not require confirmation by clicking and disappears quickly. It is centered and has a neutral gray color."
msgstr ""

#: part1-application.xml:1273(parameter) 
msgid "TYPE_WARNING_MESSAGE"
msgstr ""

#: part1-application.xml:1284(para) 
msgid "Warnings are messages of medium importance. They are displayed with colors that are neither neutral nor too distractive. A warning is displayed for 1.5 seconds, but the user can click the message box to dismiss it. The user can continue to interact with the application while the warning is displayed."
msgstr ""

#: part1-application.xml:1295(parameter) 
msgid "TYPE_ERROR_MESSAGE"
msgstr ""

#: part1-application.xml:1306(para) 
msgid "Error messages are notifications that require the highest user attention, with alert colors and by requiring the user to click the message to dismiss it. The error message box does not itself include an instruction to click the message, although the close box in the upper right corner indicates it visually. Unlike with other notifications, the user can not interact with the application while the error message is displayed."
msgstr ""

#: part1-application.xml:1320(parameter) 
msgid "TYPE_TRAY_NOTIFICATION"
msgstr ""

#: part1-application.xml:1331(para) 
msgid "Tray notifications are displayed in the \"system tray\" area, that is, in the lower-right corner of the browser view. As they do not usually obsure any user interface, they are displayed longer than humanized or warning messages, 3 seconds by default. The user can continue to interact with the application normally while the tray notification is displayed."
msgstr ""

#: part1-application.xml:1343(para) 
msgid "All of the features of specific notification types can be controlled with the attributes of <classname>Window.Notification</classname>. You can pass an explicitly created notification object to the <methodname>showNotification()</methodname> method."
msgstr ""

#: part1-application.xml:1365(para) 
msgid "The <methodname>setPosition()</methodname> method allows setting the positioning of the notification. The method takes as its parameter any of the constants:"
msgstr ""

#: part1-application.xml:1374(parameter) 
msgid "Window.Notification.POSITION_CENTERED"
msgstr ""

#: part1-application.xml:1375(parameter) 
msgid "Window.Notification.POSITION_CENTERED_TOP"
msgstr ""

#: part1-application.xml:1376(parameter) 
msgid "Window.Notification.POSITION_CENTERED_BOTTOM"
msgstr ""

#: part1-application.xml:1377(parameter) 
msgid "Window.Notification.POSITION_TOP_LEFT"
msgstr ""

#: part1-application.xml:1378(parameter) 
msgid "Window.Notification.POSITION_TOP_RIGHT"
msgstr ""

#: part1-application.xml:1379(parameter) 
msgid "Window.Notification.POSITION_BOTTOM_LEFT"
msgstr ""

#: part1-application.xml:1380(parameter) 
msgid "Window.Notification.POSITION_BOTTOM_RIGHT"
msgstr ""

#: part1-application.xml:1385(para) 
msgid "The <methodname>setDelayMSec()</methodname> allows you to set the time in milliseconds for how long the notification is displayed. Parameter value <literal>-1</literal> means that the message is displayed until the user clicks the message box. It also prevents interaction with other parts of the application window, as is default behaviour for error messages. It does not, however, add a close box that the error notification has."
msgstr ""

#: part1-application.xml:1397(title) 
msgid "Handling Uncaught Exceptions"
msgstr ""

#: part1-application.xml:1399(para) 
msgid "Application development with Vaadin follows the event-driven programming model. Mouse and keyboard events in the client cause (usually higher-level) events on the server-side, which can be handled with listeners, and that is how most of the application logic works. Handling the events can result in exceptions either in the application logic or in the framework itself, but some of them may not be caught properly."
msgstr ""

#: part1-application.xml:1408(para) 
msgid "For example, in the following code excerpt, we throw an error in an event listener but do not catch it, so it falls to the framework."
msgstr ""

#: part1-application.xml:1422(para) 
msgid "Any such exceptions that occur in the call chain, but are not caught at any other level, are eventually caught by the terminal adapter in <classname>ApplicationServlet</classname>, the lowest-level component that receives client requests. The terminal adapter passes all such caught exceptions as events to the error listener of the <classname>Application</classname> instance through the <classname>Terminal.ErrorListener</classname> interface. The <classname>Application</classname> class does not, by default, throw such exceptions forward."
msgstr ""

#: part1-application.xml:1434(para) 
msgid "The reason for this error-handling logic lies in the logic that handles component state synchronization between the client and the server. We want to handle <emphasis>all</emphasis> the serialized variable changes in the client request, because otherwise the client-side and server-side component states would become unsynchronized very easily, which could put the entire application in an invalid state."
msgstr ""

#: part1-application.xml:1443(para) 
msgid "The default implementation of the <classname>Terminal.ErrorListener</classname> interface in the <classname>Application</classname> class simply prints the error to console. It also tries to find out a component related to the error. If the exception occurred in a listener attached to a component, that component is considered as the component related to the exception. If a related component is found, the error handler sets the <emphasis>component error</emphasis> for it, the same attribute which you can set with <methodname>setComponentError()</methodname>."
msgstr ""

#: part1-application.xml:1455(para) 
msgid "In UI, the component error is shown with a small red \"!\" -sign (in the default theme). If you hover the mouse pointer over it, you will see the entire backtrace of the exception in a large tooltip box, as illustrated in <xref linkend=\"figure.application.errors.unchecked-exceptions\"/> for the above code example."
msgstr ""

#: part1-application.xml:1464(title) 
msgid "Uncaught Exception in Component Error Indicator"
msgstr ""

#: part1-application.xml:1475(para) 
msgid "You can change the logic of handling the terminal errors easily by overriding the <methodname>terminalError()</methodname> method in your application class (the one that inherits <classname>Application</classname>) or by setting a custom error listener with the <methodname>setErrorHandler</methodname> method. You can safely discard the default handling or extend its usage with your custom error handling or logging system. In the example code below, the exceptions are also reported as notifications in the main window."
msgstr ""

#: part1-application.xml:1501(para) 
msgid "Handling other exceptions works in the usual way for Java Servlets. Uncaught exceptions are finally caught and handled by the application server."
msgstr ""

#: part1-application.xml:1512(title) 
msgid "Setting Up the Application Environment"
msgstr ""

#: part1-application.xml:1514(para) 
msgid "While more and more server based frameworks, libraries, standards, and architectures for Java are invented to make the programmer's life easier, software deployment seems to get harder and harder. For example, Java Enterprise Beans tried to make the creation of persistent and networked objects easy and somewhat automatic, but the number of deployment descriptions got enormous. As Vaadin lives in a Java Servlet container, it must follow the rules, but it tries to avoid adding extra complexity."
msgstr ""

#: part1-application.xml:1527(para) 
msgid "All Vaadin applications are deployed as Java web applications, which can be packaged as WAR files. For a detailed tutorial on how web applications are packaged, please refer to any Java book that discusses Servlets. Sun has an excellent reference online at <link href=\"http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html\"> http://java.sun.com/j2ee/tutorial/1_3-fcs/doc/WCC3.html </link>."
msgstr ""

#: part1-application.xml:1540(title) 
msgid "Creating Deployable WAR in Eclipse"
msgstr ""

#: part1-application.xml:1542(para) 
msgid "To deploy an application to a web server, you need to create a WAR package. Here we give the instructions for Eclipse."
msgstr ""

#: part1-application.xml:1547(para) 
msgid "Open project properties and first set the name and destination of the WAR file in Tomcat <guimenuitem>Export to WAR settings</guimenuitem> tab. Exporting to WAR is done by selecting <guimenuitem>Export to WAR</guimenuitem> from <guimenuitem>Tomcat Project</guimenuitem> in project context menu (just click calc with the right mouse button on <guimenuitem>Package contents tree</guimenuitem>)."
msgstr ""

#: part1-application.xml:1559(title) 
msgid "Web Application Contents"
msgstr ""

#: part1-application.xml:1561(para) 
msgid "The following files are required in a web application in order to run it."
msgstr ""

#: part1-application.xml:1567(title) 
msgid "Web application organization"
msgstr ""

#: part1-application.xml:1571(filename) 
msgid "WEB-INF/web.xml"
msgstr ""

#: part1-application.xml:1574(para) 
msgid "This is the standard web application descriptor that defines how the application is organized. You can refer to any Java book about the contents of this file. Also see an example in <xref linkend=\"ex.web.xml\"/>."
msgstr ""

#: part1-application.xml:1587(filename) 
msgid "WEB-INF/lib/vaadin-6.1.0.jar"
msgstr ""

#: part1-application.xml:1592(para) 
msgid "This is the Vaadin library. It is included in the product package in <filename>lib</filename> directory."
msgstr ""

#: part1-application.xml:1602(term) 
msgid "Your application classes"
msgstr ""

#: part1-application.xml:1604(para) 
msgid "You must include your application classes either in a JAR file in <filename>WEB-INF/lib</filename> or as classes in <filename>WEB-INF/classes</filename>"
msgstr ""

#: part1-application.xml:1615(term) 
msgid "Your own theme files (OPTIONAL)"
msgstr ""

#: part1-application.xml:1617(para) 
msgid "If your application uses a special theme (look and feel), you must include it in <filename>WEB-INF/lib/themes/themename</filename> directory."
msgstr ""

#: part1-application.xml:1630(title) 
msgid "Deployment Descriptor <filename>web.xml</filename>"
msgstr ""

#: part1-application.xml:1632(para) 
msgid "The deployment descriptor is an XML file with the name <filename>web.xml</filename> in the <filename>WEB-INF</filename> directory of a web application. It is a standard component in Java EE describing how a web application should be deployed. The structure of the deployment descriptor is illustrated by the following example. You simply deploy applications as servlets implemented by the special <methodname>com.vaadin.terminal.gwt.server.ApplicationServlet</methodname> wrapper class. The class of the actual application is specified by giving the <parameter>application</parameter> parameter with the name of the specific application class to the servlet. The servlet is then connected to a URL in a standard way for Java Servlets."
msgstr ""

#: part1-application.xml:1647(title) 
msgid "web.xml"
msgstr ""

#: part1-application.xml:1648(programlisting) 
#, no-wrap
msgid "<?pocket-size 75% ?>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;web-app\n  id=\"WebApp_ID\" version=\"2.4\"\n  xmlns=\"http://java.sun.com/xml/ns/j2ee\" \n  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n  xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee\n     http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;\n\n  &lt;servlet&gt;\n    &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/servlet-name&gt;\n    &lt;servlet-class&gt;\n        com.vaadin.terminal.gwt.server.ApplicationServlet\n    &lt;/servlet-class&gt;\n    &lt;init-param&gt;\n      &lt;param-name&gt;application&lt;/param-name&gt;\n      &lt;param-value&gt;<emphasis role=\"strong\">MyApplicationClass</emphasis>&lt;/param-value&gt;\n    &lt;/init-param&gt;\n  &lt;/servlet&gt;\n\n  &lt;servlet-mapping&gt;\n    &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/servlet-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n  &lt;/servlet-mapping&gt;\n&lt;/web-app&gt;"
msgstr ""

#: part1-application.xml:1674(para) 
msgid "The descriptor defines a servlet with name <filename>myservlet</filename>. The servlet class, <classname>com.vaadin.terminal.gwt.server.ApplicationServlet</classname>, is provided by Vaadin framework and it should be the same for all Vaadin projects. The servlet takes the class name <classname>Calc</classname> of the user application class as a parameter, including the full package path to the class. If the class is in the default package the package path is obviously not used."
msgstr ""

#: part1-application.xml:1685(para) 
msgid "The <literal>url-pattern</literal> is defined above as <literal>/*</literal>. This matches to any URL under the project context. We defined above the project context as <literal>myproject</literal> so the application URL will be <uri>http://localhost:8080/myproject/</uri>. If the project were to have multiple applications or servlets, they would have to be given different names to distinguish them. For example, <literal>url-pattern</literal><literal>/myapp/*</literal> would match a URL such as <uri>http://localhost:8080/myproject/myapp/</uri>. Notice that the slash and the asterisk <emphasis>must</emphasis> be included at the end of the pattern."
msgstr ""

#: part1-application.xml:1699(para) 
msgid "Notice also that if the URL pattern is other than root <literal>/*</literal> (such as <literal>/myapp/*</literal>), you will also need to make a servlet mapping to <literal>/VAADIN/*</literal> (unless you are serving it statically as noted below). For example:"
msgstr ""

#: part1-application.xml:1706(programlisting) 
#, no-wrap
msgid "    ...\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/myurl/*&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;\n\n    &lt;servlet-mapping&gt;\n        &lt;servlet-name&gt;<emphasis role=\"strong\">myservlet</emphasis>&lt;/servlet-name&gt;\n        &lt;url-pattern&gt;/VAADIN/*&lt;/url-pattern&gt;\n    &lt;/servlet-mapping&gt;"
msgstr ""

#: part1-application.xml:1717(para) 
msgid "You do not have to provide the above <literal>/VAADIN/*</literal> mapping if you serve both the widget sets and (custom and default) themes statically in <filename>WebContent/VAADIN/</filename> directory. The mapping simply allows serving them dynamically from the Vaadin JAR. Serving them statically is recommended for production environments as it is much faster."
msgstr ""

#: part1-application.xml:1726(para) 
msgid "For a complete example on how to deploy applications, see the demos included in the Vaadin installation package, especially the <filename>WebContent/WEB-INF</filename> directory."
msgstr ""

#: part1-application.xml:1733(title) 
msgid "Deployment Descriptor Parameters"
msgstr ""

#: part1-application.xml:1735(para) 
msgid "Deployment descriptor can have many parameters and options that control the execution of a servlet. You can find a complete documentation of the deployment descriptor in Java Servlet Specification at <uri>http://java.sun.com/products/servlet/</uri>."
msgstr ""

#: part1-application.xml:1743(para) 
msgid "By default, Vaadin applications run in <emphasis>debug mode</emphasis>, which should be used during development. This enables various debugging features. For production use, you should have put in your <filename>web.xml</filename> the following parameter:"
msgstr ""

#: part1-application.xml:1756(para) 
msgid "The parameter and the debug and production modes are described in detail in <xref linkend=\"advanced.debug-production-modes\"/>."
msgstr ""

#: part1-application.xml:1761(para) 
msgid "One often needed option is the session timeout. Different servlet containers use varying defaults for timeouts, such as 30 minutes for Apache Tomcat. You can set the timeout with:"
msgstr ""

#: part1-application.xml:1771(para) 
msgid "After the timeout expires, the <methodname>close()</methodname> method of the <classname>Application</classname> class will be called. You should implement it if you wish to handle timeout situations."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: part1-application.xml:0(None) 
msgid "translator-credits"
msgstr ""

