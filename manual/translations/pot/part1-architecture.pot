msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2009-09-07 14:42+0300\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-architecture.xml:24(None) 
msgid "@@image: 'img/intro/architecture-detailed-lo.png'; md5=30264b3e6dda48a18706f44583475986"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-architecture.xml:27(None) 
msgid "@@image: 'img/intro/architecture-detailed-hi.png'; md5=d820fcf2750125dd5693ac4923282599"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-architecture.xml:353(None) 
msgid "@@image: 'img/arch/clientside-arch-lo.png'; md5=225329f9f21ca0ac8610fb0a82803e68"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-architecture.xml:356(None) 
msgid "@@image: 'img/arch/clientside-arch-hi.png'; md5=4ee4ecb627f2c3a42b18258237571db1"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: part1-architecture.xml:470(None) part1-architecture.xml:473(None) 
msgid "@@image: 'img/arch/events-classdiagram.png'; md5=54ddbfae544fc0aa9070c33e8e81de9e"
msgstr ""

#: part1-architecture.xml:4(title) 
msgid "Architecture"
msgstr ""

#: part1-architecture.xml:6(para) 
msgid "This chapter provides an introduction to the architecture of Vaadin at somewhat technical level."
msgstr ""

#: part1-architecture.xml:12(title) 
msgid "Overview"
msgstr ""

#: part1-architecture.xml:14(para) 
msgid "In <xref linkend=\"intro\"/>, we gave a short introduction to the general architecture of Vaadin. Let us now look deeper into it. <xref linkend=\"figure.architecture.detailed\"/> below illustrates the architecture."
msgstr ""

#: part1-architecture.xml:21(title) 
msgid "Vaadin Architecture"
msgstr ""

#: part1-architecture.xml:32(para) 
msgid "Vaadin consists of a <emphasis>web application API</emphasis>, a horde of <emphasis>user interface components</emphasis>, <emphasis>themes</emphasis> for controlling the appearance, and a <emphasis>data model</emphasis> that allows binding the user interface components directly to data. Behind the curtains it also employs a <emphasis>terminal adapter</emphasis> to receive requests from web browsers and make responses by rendering the pages."
msgstr ""

#: part1-architecture.xml:43(para) 
msgid "An application using Vaadin runs as a servlet in a Java web server, serving HTTP requests. The terminal adapter receives client requests through the web server's Java Servlet API, and inteprets them to user events for a particular session. An event is associated with a UI component and delivered to the application. As the application logic makes changes to the UI components, the terminal adapter renders them in the web browser by generating a response. In AJAX rendering mode, a client-side JavaScript component receives the responses and uses them to make any necessary changes to the page in the browser."
msgstr ""

#: part1-architecture.xml:55(para) 
msgid "The top level of a user application consists of an application class that inherits <classname>com.vaadin.Application</classname>. It creates the UI components (see below) it needs, receives events regarding them, and makes necessary changes to the components. For detailed information about inheriting the <classname>Application</classname>, see <xref linkend=\"application\"/>."
msgstr ""

#: part1-architecture.xml:64(para) 
msgid "The major parts of the architecture and their function are as follows:"
msgstr ""

#: part1-architecture.xml:71(term) 
msgid "User Interface Components"
msgstr ""

#: part1-architecture.xml:73(para) 
msgid "The user interface consists of UI components that are created and laid out by the application. Each server-side component has a client-side counterpart, with which the user interacts. The server-side components can serialize themselves over the client connection using a terminal adapter. The client-side components, in turn, can serialize user interaction back to the application, which is received in the server-side components as events. The components relay these events to the application logic. Most components are bound to a data source (see below). For a complete description of UI component architecture, see <xref linkend=\"components\"/>."
msgstr ""

#: part1-architecture.xml:90(term) part1-architecture.xml:334(title) 
msgid "Client-Side Engine"
msgstr ""

#: part1-architecture.xml:92(para) 
msgid "The Client-Side Engine of Vaadin manages the rendering in the web browser using Google Web Toolkit (GWT). It communicates user interaction and UI changes with the server-side Terminal Adapter using the User Interface Definition Language (UIDL), a JSON-based language. The communications are made using asynchronous HTTP or HTTPS requests. See <xref linkend=\"architecture.client-side\"/>."
msgstr ""

#: part1-architecture.xml:105(term) 
msgid "Terminal Adapter"
msgstr ""

#: part1-architecture.xml:107(para) 
msgid "The UI components do not render themselves directly as a web page, but use a <emphasis>Terminal Adapter</emphasis>. This abstraction layer allows users to use Vaadin applications with practically any web browser. Releases 3 and 4 of Vaadin supported HTML and simple AJAX based rendering, while Release 5 supports advanced AJAX-based rendering using Google Web Toolkit (GWT). You could imagine some other browser technology, not even based on HTML, and you - or we for that matter - could make it work just by writing a new adapter. Your application would still just see the Vaadin API. To allow for this sort of abstraction, UI components communicate their changes to the Terminal Adapter, which renders them for the user's browser. When the user does something in the web page, the events are communicated to the terminal adapter (through the web server) as asynchronous AJAX requests. The terminal adapter delivers the user events to the UI components, which deliver them to the application's UI logic."
msgstr ""

#: part1-architecture.xml:129(term) 
msgid "Themes"
msgstr ""

#: part1-architecture.xml:131(para) 
msgid "The user interface separates between presentation and logic. While the UI logic is handled as Java code, the presentation is defined in <emphasis>themes</emphasis> as CSS. Vaadin provides a default themes. User themes can, in addition to style sheets, include HTML templates that define custom layouts and other resources, such as images. Themes are discussed in detail in <xref linkend=\"themes\"/>."
msgstr ""

#: part1-architecture.xml:144(term) 
msgid "UIDL"
msgstr ""

#: part1-architecture.xml:146(para) 
msgid "The Terminal Adapter draws the user interface to the web page and any changes to it using a special User Interface Definition Language (UIDL). The UIDL communications are done using JSON (JavaScript Object Notation), which is a lightweight data interchange format that is especially efficient for interfacing with JavaScript-based AJAX code in the browser. See <xref linkend=\"architecture.technology.json\"/> and <xref linkend=\"uidl\"/> for details."
msgstr ""

#: part1-architecture.xml:160(term) 
msgid "Events"
msgstr ""

#: part1-architecture.xml:162(para) 
msgid "User interaction with UI components creates events, which are first processed on the client side with JavaScript and then passed all the way through the HTTP server, terminal adapter, and user component layers to the application. See <xref linkend=\"architecture.events\"/>."
msgstr ""

#: part1-architecture.xml:172(term) 
msgid "Data Model"
msgstr ""

#: part1-architecture.xml:174(para) 
msgid "In addition to the user interface model, Vaadin provides a <emphasis>data model</emphasis> for interfacing data presented in UI components. Using the data model, the user interface components can update the application data directly, without the need for any control code. All the UI components use this data model internally, but they can be bound to a separate data source as well. For example, you can bind a table component to an SQL query response. For a complete overview of the Vaadin Data Model, please refer to <xref linkend=\"datamodel\"/>."
msgstr ""

#: part1-architecture.xml:193(title) 
msgid "Technological Background"
msgstr ""

#: part1-architecture.xml:195(para) 
msgid "This section provides an introduction to the various technologies and designs on which Vaadin is based: AJAX-based web applications in general, Google Web Toolkit, and JSON data interchange format. This knowledge is not necessary for using Vaadin, but provides some background if you need to make low-level extensions to Vaadin."
msgstr ""

#: part1-architecture.xml:204(title) 
msgid "AJAX"
msgstr ""

#: part1-architecture.xml:205(para) 
msgid "AJAX (Asynchronous JavaScript and XML) is a technique for developing web applications with responsive user interaction, similar to traditional desktop applications. While conventional JavaScript-enabled HTML pages can receive new content only with page updates, AJAX-enabled pages send user interaction to the server using an asynchronous request and receive updated content in the response. This way, only small parts of the page data can be loaded. This goal is archieved by the use of a certain set of technologies: XHTML, CSS, DOM, JavaScript, XMLHttpRequest, and XML."
msgstr ""

#: part1-architecture.xml:216(para) 
msgid "AJAX, with all the fuss and pomp it receives, is essentially made possible by a simple API, namely the <methodname>XMLHttpRequest</methodname> class in JavaScript. The API is available in all major browsers and, as of 2006, the API is under way to become a W3C standard."
msgstr ""

#: part1-architecture.xml:223(para) 
msgid "Communications between the browser and the server usually require some sort of <emphasis>serialization</emphasis> (or <emphasis>marshalling</emphasis>) of data objects. AJAX suggests the use of XML for data representation in communications between the browser and the server. While Vaadin Release 4 used XML for data interchange, Release 5 uses the more efficient JSON. For more information about JSON and its use in Vaadin, see <xref linkend=\"architecture.technology.json\"/>."
msgstr ""

#: part1-architecture.xml:234(para) 
msgid "If you're a newcomer to Ajax, <xref linkend=\"advanced.application.pages\"/> discusses the history and motivations for AJAX-based web applications, as well as some special characteristics that differ from both traditional web applications and desktop applications."
msgstr ""

#: part1-architecture.xml:243(title) 
msgid "Google Web Toolkit"
msgstr ""

#: part1-architecture.xml:245(para) 
msgid "Google Web Toolkit is a software development kit for developing client-side web applications easily, without having to use JavaScript or other browser technologies directly. Applications using GWT are developed with Java and compiled into JavaScript with the GWT Compiler."
msgstr ""

#: part1-architecture.xml:252(para) 
msgid "GWT is essentially a client-side technology, normally used to develop user interface logic in the web browser. GWT applications still need to communicate with a server using RPC calls and by serializing any data. Vaadin effectively hides all client-server communications, allows handling user interaction logic in a server application, and allows software development in a single server-side application. This makes the architecture of an AJAX-based web application much simpler."
msgstr ""

#: part1-architecture.xml:262(para) 
msgid "Vaadin uses GWT to render user interfaces in the web browser and handle the low-level tasks of user interaction in the browser. Use of GWT is largely invisible in Vaadin for applications that do not need any custom GWT components."
msgstr ""

#: part1-architecture.xml:269(para) 
msgid "See <xref linkend=\"architecture.client-side\"/> for a description of how GWT is used in the Client-Side Engine of Vaadin. <xref linkend=\"gwt\"/> provides information about the integration of GWT-based user interface components with Vaadin."
msgstr ""

#: part1-architecture.xml:278(title) 
msgid "JSON"
msgstr ""

#: part1-architecture.xml:280(para) 
msgid "JSON is a lightweight data-interchange format that is easy and fast to generate and parse. JSON messages are said to be possibly a hundred times faster to parse than XML with current browser technology. The format is a subset of the JavaScript language, which makes it possible to evaluate JSON messages directly as JavaScript expressions. This makes JSON very easy to use in JavaScript applications and therefore also for AJAX applications."
msgstr ""

#: part1-architecture.xml:290(para) 
msgid "The Client-Side Engine of Vaadin uses JSON through Google Web Toolkit, which supports JSON communications in the <classname>com.google.gwt.json.client</classname> package. Together with advanced update optimization and caching, Vaadin is able to update changes in the user interface to the browser in an extremely efficient way."
msgstr ""

#: part1-architecture.xml:299(para) 
msgid "The use of JSON is completely invisible to a developer using Vaadin. Implementation of client-server serialization in custom widgets uses abstract interfaces that may be implemented as any low-level interchange format, such as XML or JSON. Details on JSON communications are given in <xref linkend=\"uidl.json\"/>."
msgstr ""

#: part1-architecture.xml:311(title) 
msgid "Applications as Java Servlet Sessions"
msgstr ""

#: part1-architecture.xml:313(para) 
msgid "Vaadin framework does basically everything it does on top of the Java Servlet API, which lies hidden deep under the hood, with the terminal adapter being the lowest level layer for handling requests from the web container."
msgstr ""

#: part1-architecture.xml:320(para) 
msgid "When the web container gets the first request for a URL registered for an application, it creates an instance of the <classname>ApplicationServlet</classname> class in Vaadin framework that inherits the <classname>HttpServlet</classname> class defined in Java Servlet API. It follows sessions by using <classname>HttpSession</classname> interface and associates an <classname>Application</classname> instance with each session. During the lifetime of a session, the framework relays user actions to the proper application instance, and further to a user interface component."
msgstr ""

#: part1-architecture.xml:336(para) 
msgid "This section gives an overview of the client-side architecture of Vaadin. Knowledge of the client-side technologies is generally not needed unless you develop or use custom GWT components. The client-side engine is based on Google Web Toolkit (GWT), which allows the development of the engine and client-side components solely with Java."
msgstr ""

#: part1-architecture.xml:344(para) 
msgid "<xref linkend=\"gwt\"/> provides information about the integration of GWT-based user interface components with Vaadin."
msgstr ""

#: part1-architecture.xml:350(title) 
msgid "Architecture of Vaadin Client-Side Engine"
msgstr ""

#: part1-architecture.xml:361(para) 
msgid "<xref linkend=\"figure.architecture.client-side\"/> illustrates the architecture of the client-side engine using a button component as an example. The user interface is managed by the <classname>ApplicationConnection</classname> class, which handles AJAX requests to the server and renders the user interface according to responses. Communications are done over HTTP(S) using the JSON data interchange format and the User Interface Definition Language (UIDL). In the server-side application, the button is used with the <classname>Button</classname> class of Vaadin. On the client-side, the user interface consists of various GWT components that inherit <classname>Widget</classname> class. In the figure above, the GWT class <classname>Button</classname> is used to render the button in the browser (the inheritance of <classname>Button</classname> is simplified in the figure). Vaadin provides an <classname>VButton</classname> class, which implements the <classname>Paintable</classname> interface needed for rendering the component with GWT."
msgstr ""

#: part1-architecture.xml:379(para) 
msgid "The actual initial web page that is loaded in the browser is an empty page that loads the JavaScript code of the Vaadin Client-Side Engine. After it is loaded and started, it handles the AJAX requests to the server. All server communications are done through the <classname>ApplicationConnection</classname> class."
msgstr ""

#: part1-architecture.xml:387(para) 
msgid "The communication with the server is done as UIDL (User Interface Definition Language) messages using the JSON message interchange format over a HTTP(S) connection. UIDL is described in <xref linkend=\"uidl\"/> and JSON in <xref linkend=\"architecture.technology.json\"/> and <xref linkend=\"uidl.json\"/>."
msgstr ""

#: part1-architecture.xml:398(title) 
msgid "Events and Listeners"
msgstr ""

#: part1-architecture.xml:400(para) 
msgid "When a user does something, such as clicks a button or selects an item, the application needs to know about it. Many Java-based user interface frameworks follow the <emphasis>Observer</emphasis> design pattern to communicate user input to the application logic. So does Vaadin. The design pattern involves two kinds of elements: an object and a number of observers that listen for events regarding the object. When an event related to the object occurs, the observers receive a notification regarding the event. In most cases there is only one observer, defined in the application logic, but the pattern allows for multiple observers. As in the event-listener framework of Java SE, we call the observing objects <emphasis>listeners</emphasis>."
msgstr ""

#: part1-architecture.xml:413(para) 
msgid "In the ancient times of C programming, <emphasis>callback functions</emphasis> filled largely the same need as listeners do now. In object-oriented languages, we have only classes and methods, not functions, so the application has to give a class interface instead of a callback function pointer to the framework. However, Vaadin supports defining a method as a listener as well."
msgstr ""

#: part1-architecture.xml:422(para) 
msgid "Events can serve many kinds of purposes. In Vaadin, the usual purpose of events is handling user interaction in a user interface. Session management can require special events, such as time-out, in which case the event is actually the lack of user interaction. Time-out is a special case of timed or scheduled events, where an event occurs at a specific date and time or when a set time has passed. Database and other asynchronous communications can cause events too."
msgstr ""

#: part1-architecture.xml:432(para) 
msgid "To receive events of a particular type, an application must include a class that implements the corresponding listener interface. In small applications, the application class itself could implement the needed listener interfaces. Listeners are managed by the <classname>AbstractComponent</classname> class, the base class of all user interface components. This means that events regarding any component can listened to. The listeners are registered in the components with <methodname>addListener()</methodname> method."
msgstr ""

#: part1-architecture.xml:443(para) 
msgid "Most components that have related events define their own event class and corresponding listener classes. For example, the <classname>Button</classname> has <classname>Button.ClickEvent</classname> events, which can be listened to through the <classname>Button.ClickListener</classname> interface. This allows an application to listen to many different kinds of events and to distinguish between them at class level. This is usually not enough, as applications usually have many components of the same class and need to distinguish between the particular components. We will look into that more closely later. The purpose of this sort of class level separation is to avoid having to make type conversions in the handlers."
msgstr ""

#: part1-architecture.xml:458(para) 
msgid "Notice that many listener interfaces inherit the <classname>java.util.EventListener</classname> superinterface, but it is not generally necessary to inherit it."
msgstr ""

#: part1-architecture.xml:467(title) 
msgid "Class Diagram of a Button Click Listener"
msgstr ""

#: part1-architecture.xml:478(para) 
msgid "<xref linkend=\"figure.eventlistenerdiagram\"/> illustrates an example where an application-specific class inherits the <classname>Button.ClickListener</classname> interface to be able to listen for button click events. The application must instantiate the listener class and register it with <methodname>addListener()</methodname>. When an event occurs, an event object is instantiated, in this case a <classname>ClickEvent</classname>. The event object knows the related UI component, in this case the <classname>Button</classname>."
msgstr ""

#: part1-architecture.xml:490(para) 
msgid "<xref linkend=\"application.events\"/> goes into details of handling events in practice."
msgstr ""

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2.
#: part1-architecture.xml:0(None) 
msgid "translator-credits"
msgstr ""

