<?xml version="1.0" encoding="UTF-8"?>

<appendix xml:id="uidl">
	<title>User Interface Definition Language (UIDL)</title>
	
	<para>
		User Interface Definition Language (UIDL) is a language for serializing user
		interface contents and changes in responses from web server to a browser. The idea
		is that the server-side components "paint" themselves to the screen (a web page)
		with the language. The UIDL messages are parsed in the browser and translated to
		GWT widgets.
	</para>

	<para>
		The UIDL is used through both server-side and client-side APIs. The server-side
		API consists of the <classname>PaintTarget</classname> interface, described
		in <xref linkend="uidl.painting"/>. The client-side interface depends on
		the implementation of the client-side engine. In Vaadin Release 5, the
		client-side engine uses the Google Web Toolkit framework. Painting the user
		interface with a GWT widget is described in <xref linkend="gwt.widgets"/>.
	</para>

	<para>
		UIDL supports painting either the entire user interface or just fragments of
		it. When the application is started by opening the page in a web browser, the
		entire user interface is painted. If a user interface component changes, only the
		changes are painted.
	</para>

	<para>
		Since Vaadin Release 5, the UIDL communications are currently done using JSON
		(JavaScript Object Notation), which is a lightweight data interchange format that
		is especially efficient for interfacing with JavaScript-based AJAX code in the
		browser. The use of JSON as the interchange format is largely transparent; IT Mill
		Toolkit version 4 (predecessor of Vaadin released in 2006) the older versions used
		an XML-based UIDL representation with the same API. Nevertheless, the UIDL API
		uses XML concepts such as attributes and elements. Below, we show examples of a
		<classname>Button</classname> component in both XML and JSON notation.
	</para>

	<para>
		With XML notation:
	</para>

	<programlisting><![CDATA[<button id="PID2" immediate="true"
        caption="My Button" focusid="1">
    <boolean id="v1" name="state"
             value="false"></boolean>
</button>]]></programlisting>

	<para>
		With JSON notation:
	</para>

	<programlisting><![CDATA[["button",
 {"id": "PID2",
  "immediate":true,
  "caption": "My Button",
  "focusid":1,
  "v":{"state":false}
 }
]]]></programlisting>

	<para>
		Components are identified with a <emphasis>PID</emphasis> or
		<emphasis>paintable identifier</emphasis> in the <literal>id</literal>
		attribute. Each component instance has its individual PID, which is usually an
		automatically generated string, but can be set manually with
		<methodname>setDebugId()</methodname> method.
	</para>
			
	<para>
		<xref linkend="uidl.json"/> gives further details on JSON. For more
		information about handling UIDL messages in the client-side components, see <xref
		linkend="gwt"/>.
	</para>

	<para>
		You can track and debug UIDL communications easily with the Firebug extension for
		Mozilla Firefox, as illustrated in <xref linkend="uidl.json"/> below. <!--
		For more information about debugging with Firebug, see <xref
		linkend="section.debugging.firebug"/>. -->
	</para>

	<section xml:id="uidl.painting">
		<title>API for Painting Components</title>
		
		<para>
			Serialization or "painting" of user interface components from server to the
			client-side engine running in the browser is done through the
			<classname>PaintTarget</classname> interface. In Vaadin Release 5,
			the only implementation of the interface is the
			<classname>JsonPaintTarget</classname>, detailed in <xref
			linkend="uidl.json"/> below.
		</para>

		<para>
			The abstract <classname>AbstractComponent</classname> class allows easy
			painting of user interface components by managing many basic tasks, such as
			attributes common for all components. Components that inherit the class need
			to implement the abstract <methodname>getTag()</methodname> method that
			returns the UIDL tag of the component. For example, the implementation for the
			<classname>Button</classname> component is as follows:
		</para>

		<programlisting><![CDATA[public String getTag() {
    return "button";
}]]></programlisting>

		<para>
			<classname>AbstractComponent</classname> implements the
			<methodname>paint()</methodname> method of the
			<classname>Paintable</classname> interface to handle basic tasks in painting,
			and provides <methodname>paintContent()</methodname> method for components to
			paint their special contents. The method gets the
			<classname>PaintTarget</classname> interface as its parameter. The method
			should call the default implementation to paint any common attributes.
		</para>

		<programlisting><?pocket-size 70% ?><![CDATA[/* Paint (serialize) the component for the client. */
public void paintContent(PaintTarget target)
                throws PaintException {
    // Superclass writes any common attributes in
    // the paint target.
    super.paintContent(target);
    
    // Set any values as variables of the paint target.
    target.addVariable(this, "colorname", getColor());
}]]></programlisting>

		<para>
			Serialized data can be attributes or variables, serialized with the
			<methodname>addAttribute()</methodname> and
			<methodname>addVariable()</methodname> methods, respectively. You must always
			serialize the attributes first and the variables only after that.
		</para>

		<para>
			The API provides a number of variations of the methods for serializing
			different basic data types. The methods support the native Java data types and
			strings of the <classname>String</classname>
			class. <methodname>addVariable()</methodname> also supports vectors of
			strings.
		</para>

		<para>
			Contained components are serialized by calling the
			<methodname>paint()</methodname> method of a sub-component, which will call
			the <methodname>paintContent()</methodname> for the sub-component, allowing
			the serialization of user interfaces recursively. The
			<methodname>paint()</methodname> method is declared in the server-side
			<classname>Paintable</classname> interface and implemented in the abstract
			base classes, <classname>AbstractComponent</classname> and
			<classname>AbstractComponentContainer</classname> (for layouts).
		</para>

		<para>
			Layout components have to serialize the essential attributes and variables
			they need, but not the contained components. The
			<classname>AbstractComponentContainer</classname> and
			<classname>AbstractLayout</classname> baseclasses manage the recursive
			painting of all the contained components in layouts.
		</para>

		<para>
			The <classname>AbstractField</classname> provides an even higher-level base
			class for user interface components. The field components hold a value or a
			<emphasis>property</emphasis>, and implement the
			<classname>Property</classname> interface to access this property. For example
			the property of a <classname>Button</classname> is a
			<classname>Boolean</classname> value.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[public void paintContent(PaintTarget target)
                 throws PaintException {
    super.paintContent(target);

    // Serialize the switchMode as an attribute
    if (isSwitchMode())
        target.addAttribute("type", "switch");

    // Get the state of the Button safely
    boolean state;
    try {
        state = ((Boolean) getValue()).booleanValue();
    } catch (NullPointerException e) {
        state = false;
    }
    target.addVariable(this, "state", state);

}]]></programlisting>

	</section>

	<section xml:id="uidl.json">
		<title>JSON Rendering</title>

		<para>
			Vaadin 5 uses JSON, a lightweight data-interchange format, to communicate UI
			rendering with the browser, because it is very fast to parse compared to
			XML. JSON messages are essentially JavaScript statements that can be directly
			evaluated by the browser. The client-side engine of Vaadin parses and
			evaluates the UIDL messages with the JSON library that comes with the Google
			Web Toolkit.
		</para>

		<para>
			<xref linkend="architecture.technology.json"/> gave a general introduction to
			JSON as part of the architecture of Vaadin. In this section, we look
			into the technical details of the format. The technical details of the JSON
			messages are useful mainly for debugging purposes, for example using the
			Firebug plugin for Mozilla Firefox.
		</para>

		<para>
			To view a UIDL message, open the Firebug panel in Firefox, select
			<guilabel>Net</guilabel> tab, select a "<literal>POST UIDL</literal>" request,
			open the <guilabel>Response</guilabel> tab, and click <guibutton>Load
			Response</guibutton>. This displays the entire UIDL message, as shown in <xref
			linkend="figure.uidl.json.firebug"/> below.
		</para>

		<figure xml:id="figure.uidl.json.firebug">
			<title>Debugging UIDL Messages with Firebug</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/debug/firebug-net-uidl.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/debug/firebug-net-uidl.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			JSON messages are represented as nested lists and associative arrays (objects
			with named properties) in JavaScript syntax. At the top level, we can find an
			associative array with the following fields:
		</para>

		<variablelist>
			<varlistentry>
				<term>changes</term>
				<listitem>
					<para>Changes to the UI caused by the request.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>meta</term>
				<listitem>
					<para>Meta-information regarding the response and the application
					state.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>resources</term>
				<listitem>
					<para>Information about application resources.</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>locales</term>
				<listitem>
					<para>Locale-specific data for locale-dependent components, such as
					names of months and weekdays.</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
			The "<literal>changes</literal>" field contains the actual UI changes as a
			list of components. Components that can contain other components are
			represented in a recursive list structure.
		</para>

		<para>
			A component is represented as a list that first contains the UIDL tag of the
			component, which identifies its class, followed by data fields. The basic
			representation of component data as attributes and variables is defined in the
			base classes of the framework. Attributes are represented as an associative
			array and variables as a separate associative array inside the special
			"<literal>v</literal>" attribute. For example, a <classname>Button</classname>
			component is communicated with a JSON representation such as the following:
		</para>

		<programlisting><![CDATA[["button",
 {"id": "PID5",
  "immediate": true,
  "caption": "7",
  "v":{"state":false}}
] ]]></programlisting>

		<para>
			A component can give its data also in additional fields in the list instead of
			the attributes or variables, as is done for the <classname>Label</classname>
			component:
		</para>

		<programlisting><![CDATA[["label",
 {"id": "PID4",
  "width": "100.0%"},
 "Some text here"] ]]></programlisting>

		<para>
			The meta-information field can contain certain types of information, which are
			not displayed in the UI, but used by the client-side engine. The
			<literal>repaintAll</literal> parameter tells that the changes include the
			entire window contents, not just partial changes. Other data includes
			redirection details for expired sessions.
		</para>
	</section>

    <!--
	<section xml:id="uidl.syntax">
		<title>UIDL Syntax</title>

		<para>
			The syntax of UIDL covers UIDL tags, their attributes, and allowed contents.
		</para>

		UNFINISHED
	</section>
    -->
</appendix>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

