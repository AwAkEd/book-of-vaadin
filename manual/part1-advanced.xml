<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various features and topics often needed in
        applications. While other topics could be considered as "advanced", the first
        section gives a brief introduction to AJAX development for beginners.
    </para>

	<section xml:id="advanced.application.pages">
		<title>Special Characteristics of AJAX Applications</title>
		
		<para>
            New to AJAX? This section is intended for people familiar with the development
            of either traditional web applications or desktop applications, who are
            entering AJAX-enabled web application development. AJAX application
            development has a few special characteristics with respect to other types of
            applications. Possibly the most important one is how the display is managed in
            the web browser.
		</para>

		<para>
			The web was originally not built for applications, but for hypertext
			pages that you can view with a browser. The purpose of web pages is
			to provide <emphasis>content</emphasis> for the user. Application
			software has a somewhat different purpose; usually to allow you to
			work on some data or content, much of which is not ever intended to
			be accessible through a web browser as web pages. As the web is
			inherently page-based, conventional web applications had to work with
			page requests and output HTML as response. JavaScript and AJAX have
			made it possible to let go of the pages.
		</para>

		<para>
			Pages are largely an unknown concept to conventional desktop
			applications. At most, desktop applications can open multiple
			windows, but usually they work with a single main window, with an
			occasional dialog window here and there. Same goes usually for web
			applications developed with Vaadin: an application typically
			runs on a single page, changing the layout as needed and popping up
			dialog boxes.
		</para>

		<para>
			Not having to load pages and use hyperlinks to communicate all user
			interaction is a relief for application development. However, they
			are an important feature that ordinary desktop applications
			lack. They allow referencing different functionalities of an
			application or resources managed by the application. They are also
			important for integration with external applications.
		</para>

		<para>
			Certain resources can be identified through a
			<firstterm>URI</firstterm> or <firstterm>Universal Resource
			Identifier</firstterm>.  A URI can easily be passed around or stored
			as a bookmark. We will see in <xref
			linkend="section.application.resources.uri"/> how you can retrieve
			the URI of a page request. Similarly, a page request can have query
			parameters, which can be handled as detailed in <xref
			linkend="section.application.resources.parameters"/>.
		</para>

		<para>
			Using URIs or request parameters to access functionalities or content
			is not as straight-forward as in conventional page-based web
			applications. Vaadin, just as any other AJAX framework, uses
			browser cookies not just for tracking users but also for tracking the
			application state. Cookies are unique in a browser, so any two
			windows share the same cookies and therefore also the state. The
			advantage is that you can close your browser and open it again and
			the application will be in the state where you left off (except for
			components such as text fields which did not have the immediate
			attribute enabled). The disadvantage is that there is no good way to
			distinguish between the windows, so there can usually be only a
			single application window. Even if there were several, you would have
			trouble with synchronization of application data between
			windows. Many conventional page-based web applications simply ignore
			out-of-sync situations, but such situations are risky for application
			platforms that are intended to be stable. Therefore it is safer to work with a
			single browser window. If you wish to have multiple windows in your
			application, you can create them inside the main window as
			<classname>Window</classname> objects. A URI can be used to fetch
			resources that have no particular state or to provide an entry point
			to the application.
		</para>

	</section>

	<section xml:id="application.windows">
		<title>Application-Level Windows</title>

		<para>
			Vaadin Release 5 introduces support for multiple application-level
			windows that can be used just like the main window. All such windows use the
			same application session. Each window is identified with a URL that is used to
			access it. This makes it possible to bookmark application-level windows. Such
			windows can even be created dynamically based on URLs.
		</para>

		<para>
			Application-level windows allow several uses important for the usability of
			browser-based applications.
		</para>

		<itemizedlist>
			<listitem>
				<emphasis>Native child windows</emphasis>. An application can open child
				windows that are not floating windows inside a parent window.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding windows</emphasis>. Windows can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="application.embedding"/>.
			</listitem>
		</itemizedlist>

		<para>
			Because of the special nature of AJAX applications, these uses require some
			caveats. We will go through them later in <xref
			linkend="application.windows.caveats"/>.
		</para>
		
		<section>
			<title>Creating New Application-Level Windows</title>

			<para>
				Creating a new application-level window is much like creating a child
				window (see <xref linkend="application.child-windows"/>), except that the
				window is added with <methodname>addWindow()</methodname> to the application
				object instead of the main window.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    public void init() {
        // First create the main window.
        final Window main = new Window ("My Test Application");
        setMainWindow(main);
         
        // Create another application-level window.
        final Window mywindow = new Window("Second Window");
        
        // Manually set the name of the window.
        mywindow.setName("mywindow");
        
        // Add some content to the window.
        mywindow.addComponent(new Label("Has content."));

        // Add the window to the application.
        addWindow(mywindow);
    }
}]]></programlisting>

			<para>
				This creates the window object that a user can view by opening a URL in
				a browser. Creating an application-level window object does not open a new
				browser window automatically to view the object, but if you wish to open
				one, you have to do it explicitly as shown below. An application-level
				window has a unique URL, which is based on the application URL and the
				name of the window given with the <methodname>setName()</methodname>
				method. For example, if the application URL is
				<uri>http://localhost:8080/myapp/</uri> and the window name is
				<literal>mywindow</literal>, the URL for the window will be
				<uri>http://localhost:8080/myapp/mywindow/</uri>. If the name of a window
				is not explicitly set with <methodname>setName()</methodname>, an
				automatically generated name will be used. The name can be retrieved with
				the <methodname>getName()</methodname> method and the entire URL with
				<methodname>getURL()</methodname>.
			</para>

			<para>
				There are three typical ways to open a new window: using the
				<methodname>open()</methodname> method of <classname>Window</classname>
				class, a <classname>Link</classname>, or referencing it from HTML or
				JavaScript code written inside a <classname>Label</classname> component.
			</para>

			<para>
				The <classname>Window</classname> <methodname>open()</methodname> method
				takes as parameters a resource to open and the target name. You can use
				<classname>ExternalResource</classname> to open a specific URL, which you
				get from the window to be opened with the
				<methodname>getURL()</methodname> method.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Create a button to open a new window. */
main.addComponent(new Button("Click to open new window",
                  new Button.ClickListener() { 
    public void buttonClick(ClickEvent event) {
        // Open the window.
        main.open(new ExternalResource(mywindow.getURL()),
                  "_new");
    }      
}));]]></programlisting>

			<para>
				The target name is one of the default HTML target names (<parameter>_new</parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, etc.) or a custom target name.  How the window is
				exactly opened depends on the browser. Browsers that support tabbed
				browsing can open the window in another tab, depending on the browser
				settings.
			</para>

			<para>
				Another typical way to open windows is to use a <classname>Link</classname>
				component with the window URL as an
				<classname>ExternalResource</classname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Add a link to the second window. */
Link link = new Link("Click to open second window",
                     new ExternalResource(mywindow.getURL()));
link.setTargetName("second");
link.setTargetHeight(300);
link.setTargetWidth(300);
link.setTargetBorder(Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);]]></programlisting>

			<para>
				Using a <classname>Link</classname> allows you to specify parameters for
				the window that opens by clicking on the link. Above, we set the
				dimensions of the window and specify what window controls the window
				should contain. The <parameter>Link.TARGET_BORDER_DEFAULT</parameter>
				specifies to use the default, which includes most of the usual window
				controls, such as the menu, the toolbar, and the status bar.
			</para>

			<para>
				Another way to allow the user to open a window is to insert the URL in
				HTML code inside a <classname>Label</classname>. This allows even more
				flexibility in specifying how the window should be opened.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Add the link manually inside a Label.
main.addComponent(
    new Label("Second window: <a href='" + mywindow.getURL()
              + "' target='second'>click to open</a>",
              Label.CONTENT_XHTML));
main.addComponent(
    new Label("The second window can be accessed through URL: "
              + mywindow.getURL()));]]></programlisting>

			<para>
				When an application-level window is closed in the browser the
				<methodname>close()</methodname> method is normally called just like
				for a child window and the <classname>Window</classname> object is
				purged from the application. However, there are situations where
				<methodname>close()</methodname> might not be called. See
				<xref linkend="application.windows.closing"/> for more information. 
			</para>

		</section>

		<section xml:id="application.windows.dynamic">
			<title>Creating Windows Dynamically</title>
			
			<para>
				You can create a window object dynamically by its URL path by overriding
				the <methodname>getWindow()</methodname> method of the
				<classname>Application</classname> class. The method gets a window name as
				its parameter and must return the corresponding
				<classname>Window</classname> object. The window name is determined from
				the first URL path element after the application URL (window name may not
				contain slashes). See the notes below for setting the actual name of the
				dynamically created windows below.
			</para>

			<para>
				The following example allows opening windows with a window name that
				begins with "<literal>planet-</literal>" prefix. Since the method is
				called for <emphasis>every</emphasis> browser request for the application,
				we filter only the requests where a window with the given name does not
				yet exist.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    ...

    @Override
    public Window getWindow(String name) {
        // If a dynamically created window is requested, but
        // it does not exist yet, create it.
        if (name.startsWith("planet-") &&
              super.getWindow(name) == null) {
            String planetName =
                    name.substring("planet-".length());

            // Create the window object.
            Window newWindow =
                    new Window("Window about " + planetName);
            
            // DANGEROUS: Set the name explicitly. Otherwise,
            // an automatically generated name is used, which
            // is usually safer.
            newWindow.setName(name);

            // Put some content in it.
            newWindow.addComponent(
                new Label("This window contains details about " +
                          planetName + "."));
            
            // Add it to the application as a regular
            // application-level window.
            addWindow(newWindow);
            
            return newWindow;
        }

        // Otherwise the Application object manages existing
        // windows by their name.
        return super.getWindow(name);
    }]]></programlisting>

			<para>
				The window name is and must be a unique indentifier for each
				<classname>Window</classname> object instance. If you use
				<methodname>setName()</methodname> to set the window name explicitly, as
				we did above, any browser window that has the same URL (within the same
				browser) would open the <emphasis>same</emphasis> window object. This is
				dangerous and <emphasis>generally not recommended</emphasis>, because the
				browser windows would share the same window object. Opening two windows
				with the same static name would immediately lead to a synchronization
				error, as is shown in <xref
				linkend="figure.application.window.dynamic.error"/> below. (While also the
				window captions are same, they are irrelevant for this problem.)
			</para>

			<figure xml:id="figure.application.window.dynamic.error">
				<title>Synchronization Error Between Windows with the Same Name</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				There are some cases where setting the name explicitly is useful. The
				launch application below is one example, as it always opens the other
				windows in a window target that is specific to the window name, thereby
				never creating two windows with the same URL. Similarly, if you had
				embedded the application in a browser frame and the link would open the
				window in a frame, you would not have problems. Having a single window
				instance for a URL is also useful if the browser crashes and the user
				opens the window again, as it will have kept its previous (server-side)
				state.
			</para>

			<para>
				Leaving the window name to be automatically generated allows opening
				multiple windows with the same URL, while each of the windows will have a
				separate state. The URL in the location bar stays unchanged and the
				generated window name is used only for the Ajax communications to identify
				the window object. A generated name is a string representation of a unique
				random number, such as "<literal>1928676448</literal>". You should be
				aware of the generated window names when overriding the
				<methodname>getWindow()</methodname> method (and not unintentionally
				create a new window instance dynamically for each such request). The
				condition in the above example would also filter out the requests for an
				already existing window with a generated name.
			</para>

			<para>
				<xref linkend="figure.application.window.dynamic.new"/> shows a
				dynamically created application-level window with the URL shown in the
				address bar. The URL for the application is here
				<uri>http://localhost:8080/tk5/windowexample/</uri>, including the
				application context, and the dynamically created window's name is
				<uri>planet-mars</uri>.
			</para>

			<figure xml:id="figure.application.window.dynamic.new">
				<title>A Dynamically Created Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The application knows the windows it already has and can return them after
				the creation. The application also handles closing and destruction of
				application-level window objects, as discussed in <xref
				linkend="application.windows.closing"/>.
			</para>

			<para>
				Such dynamic windows could be opened as in the following example:
			</para>
			
			<programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Window Test");
    setMainWindow(main);

    // Have some IDs for the dynamically creatable windows.
    final String[] items = new String[] { "mercury", "venus",
            "earth", "mars", "jupiter", "saturn", "uranus",
            "neptune" };
    
    // Create a list of links to each of the available window.
    for (int i = 0; i < items.length; i++) {
        // Create a URL for the window.
        String windowUrl = getURL() + "planet-" + items[i];
        
        // Create a link to the window URL. Using the 
        // item ID for the target also opens it in a new
        // browser window (or tab) unique to the window name.
        main.addComponent(
            new Link("Open window about " + items[i],
                     new ExternalResource(windowUrl),
                     items[i], -1, -1, Window.BORDER_DEFAULT));
    }
}]]></programlisting>
        			
			<figure xml:id="figure.application.window.dynamic.main">
				<title>Opening Windows</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="application.windows.closing">
			<title>Closing Windows</title>

			<para>
				When the user closes an application-level window, the Client-Side Engine
				running in the browser will report the event to the server before the page
				is actually removed. You can catch the event with a
				<classname>Window.CloseListener</classname>, as is done in the example
				below.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[newWindow.addListener(new Window.CloseListener() {
    @Override
    public void windowClose(CloseEvent e) {
        // Do something.
        System.out.println(e.getWindow().getName() +
                           " was closed");

        // Add a text to the main window about closing.
        // (This does not update the main window.)
        getMainWindow().addComponent(
            new Label("Window '" + e.getWindow().getName() +
                      "' was closed."));
    }
});]]></programlisting>

			<para>
				Notice that the change to the server-side state of the main window (or
				another application-level window) does not refresh the window in the
				browser, so the change will be unseen until user interaction or polling
				refreshes the window. This problem and its dangers are discussed in <xref
				linkend="application.windows.caveats"/> below.
			</para>

			<para>
				The close event does not occur if the browser crashes or the connection
				is otherwise severed violently. In such a situation, the window object will
				be left hanging, which could become a resource problem if you allow the
				users to open many such application-level windows. The positive side is
				that the user can reconnect to the window using the window URL.
			</para>
		</section>

		<section xml:id="application.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
					For cases where you need communication between windows, we recommend
					using floating child windows. In Vaadin Release 5, an
					application window can not update the data in other windows. The
					contents of a window can only be updated when the particular window makes
					a request to the server. The request can be caused by user input or
					through polling.
				</para>

				<para>
					Changing the server-side state of a window while processing a user event
					from another window can potentially cause serious problems. Changing
					the client-side state of a window does not always immediately
					communicate the changes to the server. The server-side state can therefore
					be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.window.polling">
					<title>Communication Between Two Application-Level Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					The following example creates a second window that changes the
					contents of the main window, as illustrated in the figure above. In
					this simple case, changing the main window contents is safe.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table in the main window to hold items added
// in the second window
final Table table = new Table();
table.setPageLength(5);
table.getSize().setWidth(100, Size.UNITS_PERCENTAGE);
table.addContainerProperty("Name", String.class, "");
main.addComponent(table);

// Create the second window
final Window adderWindow = new Window("Add Items");
adderWindow.setName("win-adder");
main.getApplication().addWindow(adderWindow);

// Create selection component to add items to the table
final NativeSelect select = new NativeSelect("Select item to add");
select.setImmediate(true);
adderWindow.addComponent(select);

// Add some items to the selection
String items[] = new String[]{"-- Select --", "Mercury", "Venus", 
        "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int i=0; i<items.length; i++)
    select.addItem(items[i]);
select.setNullSelectionItemId(items[0]);

// When an item is selected in the second window, add
// table in the main window
select.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // If the selected value is something else
        // but a null selection item.
        if (select.getValue() != null) {
            // Add the selected item to the table
            // in the main window
            table.addItem(new Object[]{select.getValue()},
                          new Integer(table.size()));
        }
    }
});

// Link to open the selection window
Link link = new Link("Click to open second window",
                     new ExternalResource(adderWindow.getURL()),
                     "_new", 50, 200,
                     Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);

// Enable polling to update the main window
ProgressIndicator poller = new ProgressIndicator();
poller.addStyleName("invisible");
main.addComponent(poller);]]></programlisting>

				<para>
					The example uses an invisible <classname>ProgressIndicator</classname>
					to implement polling. This is sort of a trick and a more proper API
					for polling is under design. Making the progress indicator invisible
					requires the following CSS style definition:
				</para>

				<programlisting><![CDATA[.v-progressindicator-invisible {
    display: none;
}]]></programlisting>


			</section>
		</section>
	</section>

	<section xml:id="application.embedding">
		<title>Embedding Applications in Web Pages</title>

		<para>
			Many web applications and especially web sites are not all AJAX, but AJAX is
			used only for specific functionalities. In practice, many web applications are
			a mixture of dynamic web pages and AJAX applications embedded to such
			pages.
		</para>

		<para>
			Embedding Vaadin applications is easy. There are two basic ways to
			embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the web application and load the Vaadin Client-Side Engine with a
			simple JavaScript code. The second method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element.  Both of these methods have
			advantages and disadvantages. The <literal>&lt;div&gt;</literal> method can
			only embed one application in a page, while the
			<literal>&lt;iframe&gt;</literal> method can embed as many as needed. One
			disadvantage of the <literal>&lt;iframe&gt;</literal> method is that the size
			of the <literal>&lt;iframe&gt;</literal> element is not flexible according to
			the content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods.
		</para>

		<section>
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<!-- OUTDATED? Check that this is current. -->

			<para>
                <emphasis>The loading code for the Client-Side Engine changed in IT Mill
                toolkit version 5.1.2 and the explanation below is no longer compatible
                with Vaadin. Please view the source code of the initial page of your
                application in your browser.</emphasis>

                <!-- TODO: ... or see the <filename>WebContent/multiapp.html</filename>
                for an example -->
            </para>

			<para>
				You can embed a Vaadin application inside a web page with a
				method that is equivalent to loading the initial page content from the
				application servlet in a non-embedded application. Normally, the
				<classname>ApplicationServlet</classname> servlet generates an initial
				page that contains the correct parameters for the specific
				application. You can easily configure it to load multiple Vaadin
				applications on the same page, assuming that they use the same widget set.
			</para>

			<para>
				 You can view the initial page for your application easily simply by
				 opening the application in a web browser and viewing the HTML source
				 code. You could just copy and paste the embedding code from the default
				 initial page. It has, however, some extra functionality that is not
				 normally needed: it generates some of the script content with
				 <methodname>document.write()</methodname> calls, which is useful only
				 when you are running the application as a portlet in a portal. The method
				 outlined below is much simpler.
			</para>

			<para>
				The <filename>WebContent/multiapp.html</filename> file included in the
				Vaadin installation package provides an example of embedding (multiple)
				Vaadin applications in a page. After launching the demo application, you
				can view the example at URL
				<uri>http://localhost:8888/multiapp.html</uri>. Notice that the example
				assumes the use of root context for the applications
				(<parameter>/</parameter>).
			</para>

			<!-- figure xml:id="figure.embedding.source">
				<title>Source Code of an Initial Page</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
				</mediaobject>
			</figure -->

			<para>
				Embedding requires four elements inside the HTML document:
			</para>

			<orderedlist>
				<listitem>
					<para>
						In the <literal>&lt;head&gt;</literal> element, you need to define
						the application URI and parameters and load the Vaadin
						Client-Side Engine. The <varname>vaadin</varname> variable is an
						associative map that can contain various runtime data used by the
						Client-Side Engine of Vaadin. The
						<varname>vaadinConfigurations</varname> item is itself an
						associate map that contains parameters for each of the
						applications embedded in the page. The map must contain the
						following items:
					</para>

                    <variablelist>
                        <varlistentry>
                            <term><classname>appUri</classname></term>
                            <listitem>
                                The application URI consists of the context and the
                                application path. If the context is
                                <literal>/mycontext</literal> and the application path is
                                <literal>myapp</literal>, the
                                <parameter>appUri</parameter> would be
                                <literal>/mycontext/myapp</literal>. The
                                <filename>multiapp.html</filename> example assumes the use
                                of root context, which is used in the demo application.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>pathInfo</classname></term>
                            <listitem>
                                The <parameter>PATHINFO</parameter> parameter for the
                                Servlet.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>themeUri</classname></term>
                            <listitem>
                                URI of the application theme. The URI must include
                                application context and the path to the theme
                                directory. Themes are, by default, stored under the
                                <filename>/VAADIN/themes/</filename> path.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>versionInfo</classname></term>
                            <listitem>
                                This item is itself an associative map that contains two
                                parameters: <parameter>vaadinVersion</parameter> contains
                                the version number of the Vaadin version used by the
                                application. The <parameter>applicationVersion</parameter>
                                parameter contains the version of the particular
                                application.
                            </listitem>
                        </varlistentry>
                    </variablelist>

					<para>
						The following example defines two applications to run in the same
						window: the Calculator and Hello World examples. In the example,
						the application context is <literal>/tk5</literal>.
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script type="text/javascript"&gt;
    var vaadin = {
        vaadinConfigurations: {
            '<emphasis role="bold">calc</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/Calc</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                         NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            },
            '<emphasis role="bold">hello</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/HelloWorld</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                          NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            }
        }};
&lt;/script&gt;</programlisting>
				</listitem>

				<listitem>
					<para>
						Loading the Vaadin Client-Side Engine is done with the
						following kind of line in the <literal>&lt;head&gt;</literal>
						element:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script language='javascript' src='/<emphasis>vaadin-examples</emphasis>/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'&gt;&lt;/script&gt;</programlisting>

					<para>
						The engine URI consists of the context of the web application,
						<literal>vaadin-examples</literal> above, followed by the path
						to the JavaScript (<filename>.js</filename>) file of the widget
						set, relative to the <filename>WebContent</filename>
						directory. The file contains the Client-Side Engine compiled for
						the particular widget set. The line above assumes the use of the
						default widget set of Vaadin. If you have made custom
						widgets that are defined in a custom widget set, you need to use
						the path to the compiled widget set file. Widget sets must be
						compiled under the
						<filename>WebContent/VAADIN/widgetsets</filename> directory.
					</para>

				</listitem>
				<listitem>
					<para>
						In the <literal>&lt;html&gt;</literal> element, you need to do a
						routine inclusion of GWT history <literal>iframe</literal>
						element as follows:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;iframe id="__gwt_historyFrame"
        style="width:0;height:0;border:0"&gt;&lt;/iframe&gt;</programlisting>

				</listitem>
				<listitem>
					<para>
						The location of the Vaadin application is defined with a
						<literal>div</literal> placeholder element having
						<literal>id="itmill-ajax-window"</literal> as follows:
					</para>

					<programlisting>&lt;div id="itmill-ajax-window"/&gt;</programlisting>
				</listitem>
			</orderedlist>

			<para>
				Below is a complete example of embedding an application. It works
				out-of-the-box with the <application>Calculator</application> demo
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding Example</title>

    <!-- Set parameters for the Vaadin Client-Side Engine. -->
    <script type="text/javascript">
	    var vaadin = {appUri:'Calc', pathInfo: '/'};
    </script>
    
    <!-- Load the Vaadin Client-Side Engine. -->
    <script language='javascript' src='/vaadin-examples/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'></script>

    <!-- We can stylize the web application. -->
    <style>
        #vaadin-ajax-window {background: #c0c0ff;}
        .v-button {background: pink;}
    </style>
  </head>

  <body>
    <!-- This <iframe> element is required by GWT. -->
    <iframe id="__gwt_historyFrame"
            style="width:0;height:0;border:0"></iframe>
    
    <h1>This is a HTML page</h1>
    <p>Below is the Vaadin application inside a table:</p>
    <table align="center" border="3" style="background: yellow;">
      <tr><th>The Calculator</th></tr>
      <tr>
        <td>
          <!-- Placeholder <div> for the Vaadin application -->
          <div id="vaadin-ajax-window"/>
        </td>
      </tr>
    </table>	
  </body>
</html>]]></programlisting>

			<para>
				The page will look as follows:
			</para>

			<figure xml:id="figure.embedding.div">
				<title>Embedded Application</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can style the web application with themes as described in <xref
				linkend="themes"/>. The Client-Side Engine loads the style sheets
				required by the application. In addition, you can do styling in the
				embedding page, as was done in the example above.
			</para>

			<para>
				The <application>Reservation Demo</application> and <application>Windowed
				Demos</application> provide similar examples of embedding an application
				in a web page. The embedding web pages are
				<filename>WebContent/reservr.html</filename> and
				<filename>WebContent/windoweddemos.html</filename>, respectively.
			</para>

			<para>
				The disadvantage of this embedding method is that there can only be one
				web application embedded in a page. One is usually enough, but if it is
				not, you need to use the <literal>&lt;iframe&gt;</literal> method below.
			</para>

		</section>

		<section>
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding a Vaadin application inside an
				<literal>&lt;iframe&gt;</literal> element is even easier than the method
				described above, as it does not require definition of any Vaadin specific
				definitions. The use of <literal>&lt;iframe&gt;</literal> makes it
				possible to embed multiple web applications or two different views to the
				same application on the same page.
			</para>

			<para>
				You can embed an application with an element such as the following:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<iframe src="/vaadin-examples/Calc"></iframe>]]></programlisting>

			<para>
				The problem with <literal>&lt;iframe&gt;</literal> elements is that their
				size of is not flexible depending on the content of the frame, but the
				content must be flexible to accommodate in the frame. You can set the size
				of an <literal>&lt;iframe&gt;</literal> element with
				<literal>height</literal> and <literal>width</literal> attributes.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside
       a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker"
                  height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="advanced.debug-production-modes">
		<title>Debug and Production Mode</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug
			mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode,
			which is on by default, enables a number of built-in debug features for the
			developers. The features include:
		</para>

		<itemizedlist>
			<listitem>Debug Window for accessing debug functionalities</listitem>
			<listitem>Display debug information in the Debug Window and server console.</listitem>
			<listitem><guibutton>Analyze layouting</guibutton> button that analyzes the layout for possible problems.</listitem>
		</itemizedlist>

		<para>
			All applications are run in the debug mode by default (since IT Mill Toolkit
			version 5.3.0). The production mode can be enabled, and debug mode thereby
			disabled, by adding a <parameter>productionMode=true</parameter> parameter to
			the servlet context in the <filename>web.xml</filename> deployment descriptor:
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[<context-param>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
  <description>Vaadin production mode</description>
</context-param>]]></programlisting>
		
		<para>
			Enabling the production mode disables the debug features, thereby preventing
			users from easily inspecting the inner workings of the application from the
			browser.
		</para>
		
		<section xml:id="advanced.debug-production-modes.debug.mode">
			<title>Debug Mode</title>
			
			<para>
				Running an application in the debug mode enables the client-side Debug
				Window in the browser. You can open the Debug Window by adding
				"<uri>?debug</uri>" to the application URL, e.g.,
				<uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in
				<xref linkend='figure.debug.window'/>, consists of buttons controlling the
				debugging features and a scrollable log of debug messages.
			</para>

			<figure id="figure.debug.window">
				<title>Debug Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<variablelist>
				<varlistentry>
					<term><guibutton>Clear console</guibutton></term>
					<listitem>
						Clears the log in the Debug Window.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Restart app</guibutton></term>
					<listitem>
						Restarts the application.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Force layout</guibutton></term>
					<listitem>
						Causes all currently visible layouts to recalculate their
						appearance. Layout components calculate the space required by all
						child components, so the layout appearance must be recalculated
						whenever the size of a child component is changed. In normal
						applications, this is done automatically, but when you do themeing
						or alter the CSS with Firebug, you may need to force all layouts
						to recalculate themselves, taking into account the recently made
						changes.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Analyze layouts</guibutton></term>
					<listitem>
						This is described in the following section.
					</listitem>
				</varlistentry>
			</variablelist>

			<para>
				If you use the Firebug plugin in Mozilla Firefox, the log messages will
				also be printed to the Firebug console. In such a case, you may want to
				enable client-side debugging without showing the Debug Window with
				"<uri>?debug=quiet</uri>" in the URL. In the quiet debug mode, log
				messages will only be printed to the Firebug console.
			</para>
		</section>

 		<section>
			<title>Analyzing Layouts</title>
			<para>
				The <guilabel>Analyze layouts</guilabel> button analyzes the currently
				visible layouts and makes a report of possible layout related
				problems. All detected layout problems are displayed in the log and also
				printed to the console.
			</para>

			<para>
				The most common layout problem is caused by placing a component that has a
				relative size inside a container (layout) that has undefined size, e.g.,
				adding a 100% wide <classname>Panel</classname> inside a
				<classname>HorizontalLayout</classname> with no width specification. In
				such a case, the error will look as shown below:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Vaadin DEBUG
- Window/1a8bd74 "My window" (width: MAIN WINDOW)
  - HorizontalLayout/1cf243b (width: UNDEFINED)
    - Panel/12e43f1 "My panel" (width: RELATIVE, 100.0 %)
Layout problem detected: Component with relative width inside a HorizontalLayout with no width defined
Relative sizes were replaced by undefined sizes, components may not render as expected.]]>
			</programlisting>
			
			<para>
				This particular error tells that the <classname>Panel</classname> "My
				panel" is 100% wide while the width of the containing
				<classname>HorizontalLayout</classname> is undefined. The components will
				be rendered as if the the width of the contained
				<classname>Panel</classname> was undefined, which might not be what the
				developer wanted. There are two possible fixes for this case: if the
				<classname>Panel</classname> should fill the main window horizontally, set
				a width for the <classname>HorizontalLayout</classname> (e.g. 100% wide),
				or set the width of the <classname>Panel</classname> to "undefined" to
				render the it as it is currently rendered but avoiding the warning
				message.
			</para>

			<para>
				The same error is shown in the Debug Window in a slightly different form
				and with an additional feature (see <xref
				linkend='figure.debug-window.analyze-layouts'/>). Checking the
				<guilabel>Emphasize component in UI</guilabel> box will turn red the
				background of the component that caused a warning, making it easy for
				the developer to figure out which component each warning relates to. The
				messages will also be displayed hierarchically, as a warning from a
				containing component often causes more warnings from its child
				components. A good rule of thumb is to work on the upper-level problems
				first and only after that worry about the warnings from the children.
			</para>
			
			<figure id="figure.debug-window.analyze-layouts">
				<title>Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
				</mediaobject>
			</figure>
						
		</section>

		<section>
			<title>Custom Layouts</title>

			<para>
				<classname>CustomLayout</classname> components can not be analyzed in the
				same way as other layouts. For custom layouts, the <guibutton>Analyze
				layouts</guibutton> button analyzes all contained relative-sized
				components and checks if any relative dimension is calculated to zero so
				that the component will be invisible. The error log will display a warning
				for each of these invisible components. It would not be meaningful to
				emphasize the component itself as it is not visible, so when you select
				such an error, the parent layout of the component is emphasized if
				possible.
			</para>

		</section>

		<section>
			<title>Debug Functions for Component Developers</title>

			<para>
				You can take advantage of the debug mode when developing client-side
				components. The static function
				<methodname>ApplicationConnection.getConsole()</methodname> will return a
				reference to a <classname>Console</classname> object which contains
				logging methods such as <methodname>log(String msg)</methodname> and
				<methodname>error(String msg)</methodname>.  These functions will print
				messages to the Debug Window and Firebug console in the same way as other
				debugging functionalities of Vaadin do. No messages will be
				printed if the Debug Window is not open or if the application is running
				in production mode.
			</para>
		</section>
	</section>

	<section xml:id="advanced.resources">
		<title>Resources</title>

		<para>
			In addition to high-level resource classes described in <xref
			linkend="application.resources"/>, Vaadin provides low-level facilities
			for retrieving the URI and other parameters of HTTP requests. In the
			following, we will look into low-level interfaces for handling URIs and
			parameters to provide resources and functionalities.
		</para>

		<para>
			Notice that using URI or parameter handlers to create "pages" is not
			meaningful in Vaadin or in AJAX applications generally. See <xref
			linkend="advanced.application.pages"/> for reasons.
		</para>

		<section xml:id="section.application.resources.uri">
			<title>URI  Handlers</title>

			<para>
				The URI parameter for the application is useful mainly for two purposes:
				for providing some special functionality according to the URI or for
				providing dynamic content. Dynamic content can also be provided with
				<classname>StreamResource</classname>.
			</para>

			<para>
				You can retrieve the URI for the HTTP request made for your
				application by implementing the
				<classname>com.vaadin.terminal.URIHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addURIHandler()</methodname> method. You then get the
				URI by implementing the <methodname>handleURI()</methodname>
				method. The method gets two parameters: a context and a URI
				relative to the context. The context is the base URI for your
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Hello window");
    setMainWindow(main);

    URIHandler uriHandler = new URIHandler() {
        public DownloadStream handleURI(URL context,
                                        String relativeUri) {
            // Do something here
            System.out.println("handleURI=" + relativeUri);

            // Should be null unless providing dynamic data.
            return null;
        }
    };
    main.addURIHandler(uriHandler);

}]]></programlisting>

			<para>
				If you have multiple URI handlers attached to a window, they are executed
				after one another. The URI handlers should return
				<parameter>null</parameter>, unless you wish to provide dynamic content
				with the call. Other URI handlers attached to the window will not be
				executed after some handler returns non-null data. The combined parameter
				and URI handler example below shows how to create dynamic content with a
				URI handler.
			</para>

			<para>
				Notice that if you do provide dynamic content with a URI handler, the
				dynamic content is returned in the HTTP response. If the handler makes any
				changes to the UI state of the application, these changes are not rendered
				in the browser, as they are usually returned in the HTTP response made by
				the Application object and now the custom URI handler overrides the
				default behaviour. If your client-side code makes a server call that does
				update the UI state, the client-side must initiate an update from the
				server. For example, if you have an integration situation where you make a
				JavaScript call to the server, handle the request with a URI handler,
				and the server state changes as a side-effect, you can use the
				<methodname>vaadin.forceSync()</methodname> method to force the update.
			</para>

		</section>

		<section xml:id="section.application.resources.parameters">
			<title>Parameter Handlers</title>
		
			<para>
				You can retrieve the parameters passed to your application by
				implementing the
				<classname>com.vaadin.terminal.ParameterHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addParameterHandler()</methodname> method. You then
				get the parameters in the
				<methodname>handleParameters()</methodname> method. The
				parameters are passes as a map from string key to a vector of
				string values.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[class MyParameterHandler implements ParameterHandler {
    public void handleParameters(Map parameters) {
        // Print out the parameters to standard output
        for (Iterator it = parameters.keySet().iterator();
             it.hasNext();) {
            String key   = (String) it.next();
            String value = ((String[]) parameters.get(key))[0];
            System.out.println("Key: "+key+", value: "+value);
        }
    }
}]]></programlisting>

			<para>
				The parameter handler is not called if there are no parameters. Parameter
				handler is called before the URI handler, so if you handle both, you might
				typically want to just store the URI parameters in the parameter handler
				and do actual processing in URI handler. This allows you, for example, to
				create dynamic resources based on the URI parameters.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.util.Map;
import javax.imageio.ImageIO;
import com.vaadin.terminal.*;

/**
 * Demonstrates handling URI parameters and the URI itself to
 * create a dynamic resource.
 */
public class MyDynamicResource implements URIHandler,
                                          ParameterHandler {
    String textToDisplay = "- no text given -";

    /**
     * Handle the URL parameters and store them for the URI
     * handler to use.
     */
    public void handleParameters(Map parameters) {
        // Get and store the passed HTTP parameter.
        if (parameters.containsKey("text"))
            textToDisplay =
                ((String[])parameters.get("text"))[0];
    }

    /**
     * Provides the dynamic resource if the URI matches the
     * resource URI. The matching URI is "/myresource" under
     * the application URI context.
     * 
     * Returns null if the URI does not match. Otherwise
     * returns a download stream that contains the response
     * from the server.
     */
    public DownloadStream handleURI(URL context,
                                    String relativeUri) {
        // Catch the given URI that identifies the resource,
        // otherwise let other URI handlers or the Application
        // to handle the response.
        if (!relativeUri.startsWith("myresource"))
            return null;
        
        // Create an image and draw some background on it.
        BufferedImage image = new BufferedImage (200, 200,
                                    BufferedImage.TYPE_INT_RGB);
        Graphics drawable = image.getGraphics();
        drawable.setColor(Color.lightGray);
        drawable.fillRect(0,0,200,200);
        drawable.setColor(Color.yellow);
        drawable.fillOval(25,25,150,150);
        drawable.setColor(Color.blue);
        drawable.drawRect(0,0,199,199);
        
        // Use the parameter to create dynamic content.
        drawable.setColor(Color.black);
        drawable.drawString("Text: "+textToDisplay, 75, 100);

        try {
            // Write the image to a buffer.
            ByteArrayOutputStream imagebuffer =
                    new ByteArrayOutputStream();
            ImageIO.write(image, "png", imagebuffer);

            // Return a stream from the buffer.
            ByteArrayInputStream istream =
                    new ByteArrayInputStream(
                            imagebuffer.toByteArray());
            return new DownloadStream (istream,null,null);
        } catch (IOException e) {
            return null;
        }
    }
}]]></programlisting>

			<para>
				When you use the dynamic resource class in your application, you obviously
				need to provide the same instance of the class as both types of handler:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[MyDynamicResource myresource = new MyDynamicResource();
mainWindow.addParameterHandler(myresource);
mainWindow.addURIHandler(myresource);]]></programlisting>

			<figure>
				<title>Dynamic Resource with URI Parameters</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" smallscale="100%" align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

    <!--
	<section xml:id="advanced.servlet">
		<title>Java Servlet Parameters</title>

       UNFINISHED
	</section>
    -->

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

		<!-- UNFINISHED -->

		<para>
			Shortcut keys can be defined as <emphasis>actions</emphasis> using the
			<classname>ShortcutAction</classname> class. ShortcutAction extends generic 
			<classname>Action</classname> class that is used for example in 
			<classname>Tree</classname> and <classname>Table</classname> for context menus.
			Currently the only classes that accept <classname>ShortcutActions</classname> 
			are <classname>Window</classname> and <classname>Panel</classname>.
			This may change in the future. <classname>Table</classname> is a good
			candidate to support ShortcutActions. 
		</para>
		
		<para>		
			To handle key presses, you need	to define an action handler by implementing 
			the <classname>Handler</classname> interface. The interface has two methods 
			that you need to implement: <methodname>getActions()</methodname> and
			<methodname>handleAction()</methodname>.
		</para>

		<para>
			The <methodname>getActions()</methodname> interface method must return an
			array of <classname>Action</classname> objects for the component specified
			with the second parameter for the method, the <parameter>sender</parameter> of
			an action. For a keyboard shortcut, you use a
			<classname>ShortcutAction</classname>. The implementation of the method could
			be following:
		</para>

        <programlisting language="java"><?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an event
Action action_ok = new ShortcutAction("Default key",
        ShortcutAction.KeyCode.ENTER, null);

// Have the C key modified with Alt cause an event
Action action_cancel = new ShortcutAction("Alt+C",
        ShortcutAction.KeyCode.C,
        new int[] { ShortcutAction.ModifierKey.ALT });

Action[] actions = new Action[] {action_cancel, action_ok};

public Action[] getActions(Object target, Object sender) {
    if(sender == myPanel)
        return actions;

    return null;
}]]></programlisting>

		<para>
			The returned Action array may be static or created dynamically for different
			senders according to your needs. 
		</para>

		<para>
			The constructor method of <classname>ShortcutAction</classname> takes a 
			symbolic caption for the action; this is largely irrelevant
			for shortcut actions in their current implementation, but might be used 
			later if implementors use them in both menus and as shortcut actions.
			The second parameter is the keycode, as defined in 
			<classname>ShortcutAction.KeyCode</classname> interface. Currently, the 
			following keycodes are allowed:
		</para>

		<variablelist>
			<varlistentry>
				<term>Keys <parameter>A</parameter> to <parameter>Z</parameter></term>
				<listitem>Normal letter keys</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>F1</parameter> to <parameter>F12</parameter></term>
				<listitem>
					<para>Function keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter></term>
				<listitem>
					<para>Control keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>NUM0</parameter> to <parameter>NUM9</parameter></term>
				<listitem>
					<para>Number pad keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter></term>
				<listitem>
					<para>Arrow keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term><parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter></term>
				<listitem>
					<para>Other movement keys</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
			The third parameter is an array of modifier keys, as defined in the
			<classname>ShortcutAction.ModifierKey</classname> interface. The
			following modifier keys are allowed: <parameter>ALT</parameter>,
			<parameter>CTRL</parameter>, and <parameter>SHIFT</parameter>. The modifier
			keys can be combined; for example, the following defines shortcut key
			combination
			<keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>S</keycap></keycombo>:


		<programlisting language="java"><?pocket-size 65% ?><![CDATA[ShortcutAction("Ctrl+Shift+S",
               ShortcutAction.KeyCode.S, new int[] {
                      ShortcutAction.ModifierKey.CTRL,
                      ShortcutAction.ModifierKey.SHIFT});]]></programlisting>

		</para>

		<para>
			The following example demonstrates the definition of a default button for a
			user interface, as well as a normal shortcut key,
			<keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
			<guibutton>Cancel</guibutton> button.
		</para>

		<programlisting language="java"><?pocket-size 65% ?><![CDATA[import com.vaadin.event.Action;
import com.vaadin.event.ShortcutAction;
import com.vaadin.event.Action.Handler;
import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.FormLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Panel;
import com.vaadin.ui.TextField;

public class DefaultButtonExample extends CustomComponent
                                  implements Handler {
    // Define and create user interface components
    Panel panel = new Panel("Login");
    FormLayout formlayout = new FormLayout();
    TextField username = new TextField("Username");
    TextField password = new TextField("Password");
    HorizontalLayout buttons = new HorizontalLayout();

    // Create buttons and define their listener methods.
    Button ok = new Button("OK", this, "okHandler");
    Button cancel = new Button("Cancel", this, "cancelHandler");

    // Have the unmodified Enter key cause an event
    Action action_ok = new ShortcutAction("Default key",
            ShortcutAction.KeyCode.ENTER, null);

    // Have the C key modified with Alt cause an event
    Action action_cancel = new ShortcutAction("Alt+C",
            ShortcutAction.KeyCode.C,
            new int[] { ShortcutAction.ModifierKey.ALT });

    public DefaultButtonExample() {
        // Set up the user interface
        setCompositionRoot(panel);
        panel.addComponent(formlayout);
        formlayout.addComponent(username);
        formlayout.addComponent(password);
        formlayout.addComponent(buttons);
        buttons.addComponent(ok);
        buttons.addComponent(cancel);

        // Set focus to username
        username.focus();

        // Set this object as the action handler
        System.out.println("adding ah");
        panel.addActionHandler(this);

        System.out.println("start done.");
    }

    /**
     * Retrieve actions for a specific component. This method
     * will be called for each object that has a handler; in
     * this example just for login panel. The returned action
     * list might as well be static list.
     */
    public Action[] getActions(Object target, Object sender) {
        System.out.println("getActions()");
        return new Action[] { action_ok, action_cancel };
    }

    /**
     * Handle actions received from keyboard. This simply directs
     * the actions to the same listener methods that are called
     * with ButtonClick events.
     */
    public void handleAction(Action action, Object sender,
                             Object target) {
        if (action == action_ok) {
            okHandler();
        }
        if (action == action_cancel) {
            cancelHandler();
        }
    }

    public void okHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("OK clicked. "
                + "User=" + username.getValue() + ", password="
                + password.getValue()));
        //  
    }

    public void cancelHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("Cancel clicked. User="
                + username.getValue() + ", password="
                + password.getValue()));
    }
}]]></programlisting>

		<para>
			Notice that the keyboard actions can currently be attached only to 
			<classname>Panel</classname>s and <classname>Window</classname>s. This can
			cause problems if you have components that require a certain key. For example,
			multi-line <classname>TextField</classname> requires the
			<keycap>Enter</keycap> key. There is currently no way to filter the shortcut
			actions out while the focus is inside some specific component, so you need to
			avoid such conflicts.
		</para>
	</section>

	<section xml:id="advanced.printing">
		<title>Printing</title>

		<para>
			Vaadin does not currently have any special support for
			printing. Printing on the server-side is anyhow largely independent from the
			web UI of an application. You just have to take care that the printing does
			not block server requests, possibly by running printing in another thread.
		</para>

		<para>
			For client-side printing, most browsers support printing the web page. The
			<methodname>print()</methodname> method in JavaScript opens the print window
			of the browser. You can easily make a HTML button or link that prints the
			current page by placing the custom HTML code inside a
			<classname>Label</classname>.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[main.addComponent(new Label("<input type='button' onClick='print()' value='Click to Print'/>", Label.CONTENT_XHTML));]]></programlisting>

		<para>
			This button would print the current page. Often you want to be able to print a
			report or receipt and it should not have any UI components. In such a case you
			could offer it as a PDF resource, or you could open a new window as is done
			below and automatically launch printing.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[// A button to open the printer-friendly page.
Button printButton = new Button("Click to Print");
main.addComponent(printButton);
printButton.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        // Create a window that contains stuff you want to print.
        Window printWindow = new Window("Window to Print");
        
        // Have some content to print.
        printWindow.addComponent(
                new Label("Here's some dynamic content."));
        
        // To execute the print() JavaScript, we need to run it
        // from a custom layout.
        CustomLayout scriptLayout = new CustomLayout("printpage");
        printWindow.addComponent (scriptLayout);
        
        // Add the printing window as an application-level window.
        main.getApplication().addWindow(printWindow);

        // Open the printing window as a new browser window
        main.open(new ExternalResource(printWindow.getURL()),
                  "_new");
    } 
});]]></programlisting>

		<para>
			How the browser opens the window, as an actual window or just a tab, depends
			on the browser. Notice that above we create a new window object each time the
			print button is clicked, which leads to unused window objects. If this is a
			real problem, you might want to reuse the same window object or clean up the
			old ones - it's ok because the user doesn't interact with them later anyhow.
		</para>

		<para>
			You will also need a custom layout that contains the
			<methodname>print()</methodname> JavaScript function that launches the
			printing. Notice that the custom layout <emphasis>must</emphasis> contain also
			another element (below a <literal>&lt;div&gt;</literal>) in addition to the
			<literal>&lt;script&gt;</literal> element.
		</para>

		<programlisting><![CDATA[<div>This is some static content.</div>

<script type='text/javascript'>
    print();
</script>
]]></programlisting>

		<para>
			Printing as PDF would not require creating a <classname>Window</classname>
			object, but you would need to provide the content as a static or a dynamic
			resource for the <methodname>open()</methodname> method. Printing a PDF file
			would obviously require a PDF viewer cabability (such as Adobe Reader) in the
			browser.
		</para>

	</section>

	<section>
		<title>Portal Integration</title>

		<para>
			Vaadin supports running applications as portlets, as defined in the JSR-168
			standard. While providing generic support for all portals implementing the
			standard, Vaadin especially supports the Liferay portal and the needed
			portal-specific configuration is given below for Liferay.
		</para>

		<note>
			<title>Portal Integration Examples</title>
			<para>
				You can deploy the Vaadin demo package WAR (available from the download
				site) directly to a portal such as Liferay. It contains all the necessary
				portlet configuration files. For optimal performance with Liferay, you
				need to install and configure the widget set and themes in Liferay as
				described below.
			</para>

			<para>
				You can find more documentation and examples from the Vaadin Developer's
				Site at <uri>http://dev.vaadin.com/</uri>.
			</para>
		</note>

		<section>
			<title>Deploying to a Portal</title>

			<para>
				Deploying a Vaadin application as a portlet is essentially just as easy as
				deploying a regular application to an application server. You do not need
				to make any changes in the application itself, but only the following:
			</para>

			<itemizedlist spacing="compact">
				<listitem><para>Application packaged as a WAR</para>
					<itemizedlist spacing="compact" mark="disc">
						<listitem><para><filename>WEB-INF/portlet.xml</filename> descriptor</para></listitem>
						<listitem><para><filename>WEB-INF/liferay-portlet.xml</filename> descriptor for Liferay</para></listitem>
						<listitem><para><filename>WEB-INF/liferay-display.xml</filename> descriptor for Liferay</para></listitem>
					</itemizedlist>
				</listitem>

				<listitem>Widget set installed to portal (recommended)</listitem>
				<listitem>Themes installed to portal (recommended)</listitem>
                <listitem>Portal configuration settings (optional)</listitem>
			</itemizedlist>

			<para>
				Installing the widget set and themes to the portal is required for running
				two or more Vaadin portlets simultaneously in a portal page. As this
				situation occurs quite easily, we recommend installing them in any case.
			</para>

			<para>
				In addition to the Vaadin library, you will need to copy the
				<filename>portlet.jar</filename> to your project. It is included in the
				Vaadin installation package. Notice that you must not put the
				<filename>portlet.jar</filename> in the same
				<filename>WebContent/WEB-INF/lib</filename> directory as the Vaadin JAR or
				otherwise include it in the WAR to be deployed, because otherwise it will
				create a conflict with the internal portlet library of the portal.
			</para>

			<para>
				How you actually deploy a WAR package depends on the portal. In Liferay,
				you simply copy it to the <filename>deploy</filename> subdirectory under
				the Liferay installation directory. Liferay uses Tomcat by default, so you
				will find the extracted package in the <filename>webapps</filename>
				directory under the Tomcat installation directory included in Liferay.
			</para>
		</section>

		<section>
			<title>Portlet Deployment Descriptors</title>

			<para>
				To deploy a portlet WAR in a portal, you need to provide the basic
				<filename>portlet.xml</filename> descriptor specified in the Java Portlet
				standard. In addition, you may need to include possible portal vendor
				specific deployment descriptors. The ones required by Liferay are
				described below.
			</para>

			<simplesect>
				<title>Basic Portlet Descriptor</title>

				<para>
					The portlet WAR must include a portlet descriptor located at
					<filename>WebContent/WEB-INF/portlet.xml</filename>. A portlet
					definition includes the portlet name, mapping to a servlet in
					<filename>web.xml</filename>, modes supported by the portlet, and
					other configuration. Below is an example of a simple portlet
					definition in <filename>portlet.xml</filename> descriptor.
				</para>

				<programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;portlet-app
  xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"
  version="1.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd
                      http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"&gt;

  &lt;portlet&gt;
    &lt;!-- Must not be the same as servlet name. --&gt;
    &lt;portlet-name&gt;<emphasis role="bold">PortletExamplePortlet</emphasis>&lt;/portlet-name&gt;
    &lt;display-name&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;

    &lt;!-- Map portlet to a servlet. --&gt;
    &lt;portlet-class&gt;com.vaadin.terminal.gwt.server.ApplicationPortlet&lt;/portlet-class&gt;
    &lt;init-param&gt;
      &lt;name&gt;application&lt;/name&gt;

      &lt;!-- Must match the servlet name in web.xml. --&gt;
      &lt;value&gt;<emphasis role="bold">PortletExample</emphasis>&lt;/value&gt;
    &lt;/init-param&gt;

    &lt;!-- Supported portlet modes and content types. --&gt;
    &lt;supports&gt;
      &lt;mime-type&gt;text/html&lt;/mime-type&gt;
      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;
    &lt;/supports&gt;

    &lt;!-- Not always required but Liferay requires these. --&gt;
    &lt;portlet-info&gt;
      &lt;title&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/title&gt;
      &lt;short-title&gt;<emphasis role="bold">Portlet Example</emphasis>&lt;/short-title&gt;
    &lt;/portlet-info&gt;
  &lt;/portlet&gt;
&lt;/portlet-app&gt;</programlisting>

				<para>
					Enabling portlet modes enables portlet controls in the portal user interface
					that allow changing the mode, as described later.
				</para>

				<section>
					<title>Using a Single Widget Set</title>

					<para>
						If you have just one Vaadin application that you ever need to run
						in your portal, you can just deploy the WAR as described above and
						that's it. However, if you have multiple applications, especially
						ones that use different custom widget sets, you run into problems,
						because a portal window can load only a single Vaadin widget set
						at a time. You can solve this problem by combining all the
						different widget sets in your different applications into a single
						widget set using inheritance or composition.
					</para>

					<para>
						For example, the portal demos defined in the
						<filename>portlet.xml</filename> in the demo WAR have the
						following setting that defines every portlet to use the same
						widget set:
					</para>

					<programlisting><?pocket-size 75% ?><![CDATA[<portlet>
  ...
  <!-- Use the Sampler widget set for all portal demos. -->
  <init-param>
    <name>widgetset</name>
    <value>com.vaadin.demo.sampler.gwt.SamplerWidgetSet</value>
  </init-param>
  ...]]></programlisting>

					<para>
						The <classname>SamplerWidgetSet</classname> required by the
						Sampler application inherits the
						<classname>DefaultWidgetSet</classname> so that the latter is
						essentially a subset of the former. Other applications requiring
						only the regular <classname>DefaultWidgetSet</classname> can as
						well use the larger set.
					</para>

					<para>
						If your portlets are contained in multiple WARs, which can happen
						quite typically, you need to install the widget set and theme
						portal-wide so that all the portlets can use them. See <xref
						linkend="advanced.liferay.widgetsets"/> on configuring the widget
						sets in the portal itself.
					</para>
				</section>
			</simplesect>

			<simplesect>
				<title>Liferay Portlet Descriptor</title>

				<para>
					Liferay requires a special <filename>liferay-portlet.xml</filename>
					descriptor file that defines Liferay-specific parameters. Especially,
					Vaadin portlets must be defined as
					"<emphasis>instanceable</emphasis>", but not
					"<emphasis>ajaxable</emphasis>".
				</para>

				<para>
					Below is an example descriptor for the earlier portlet example:
				</para>

				<programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE liferay-portlet-app PUBLIC
  "-//Liferay//DTD Portlet Application 4.3.0//EN"
  "http://www.liferay.com/dtd/liferay-portlet-app_4_3_0.dtd"&gt;

&lt;liferay-portlet-app&gt;
    &lt;portlet&gt;
        &lt;!-- Matches definition in portlet.xml.          --&gt;
        &lt;!-- Note: Must not be the same as servlet name. --&gt;
        &lt;portlet-name&gt;<emphasis role="bold">PortletExamplePortlet</emphasis>&lt;/portlet-name&gt;

        &lt;instanceable&gt;true&lt;/instanceable&gt;
        &lt;ajaxable&gt;false&lt;/ajaxable&gt;
    &lt;/portlet&gt;
&lt;/liferay-portlet-app&gt;</programlisting>

				<para>
					See Liferay documentation for further details on the
					<filename>liferay-portlet.xml</filename> deployment descriptor.
				</para>

			</simplesect>

			<simplesect xml:id="advanced.liferay.descriptor.display">
				<title>Liferay Display Descriptor</title>
				
				<para>
					The <filename>liferay-display.xml</filename> file defines the portlet
					category under which portlets are organized in the <guilabel>Add
					Application</guilabel> window in Liferay. Without this definition,
					portlets will be organized under the "Undefined" category.
				</para>

				<para>
					The following display configuration, which is included in the demo
					WAR, puts the Vaadin portlets under the "Vaadin" category, as shown in
					<xref linkend="figure.advanced.liferay.descriptor.display"/>.
				</para>

				<programlisting><?pocket-size 75% ?><![CDATA[<?xml version="1.0"?>
<!DOCTYPE display PUBLIC
  "-//Liferay//DTD Display 4.0.0//EN"
  "http://www.liferay.com/dtd/liferay-display_4_0_0.dtd">

<display>
    <category name="Vaadin">
        <portlet id="PortletExamplePortlet" />
    </category>
</display>]]></programlisting>

				<figure xml:id="figure.advanced.liferay.descriptor.display">
					<title>Portlet Categories in Add Application Window</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/advanced/liferay-display-lo.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/liferay-display-hi.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					See Liferay documentation for further details on how to configure the
					categories in the <filename>liferay-display.xml</filename> deployment
					descriptor.
				</para>
			</simplesect>

		</section>

		<section xml:id="advanced.liferay.helloworld">
			<title>Portlet Hello World</title>

			<para>
				The Hello World program that runs as a portlet is no different from a
				regular Vaadin application, as long as it doesn't need to handle portlet
				actions, mode changes, and so on.
			</para>

			<programlisting><?pocket-size 75% ?><![CDATA[import com.vaadin.Application;
import com.vaadin.ui.*;

public class PortletExample extends Application {
    @Override 
    public void init() {
        Window mainWindow = new Window("Portlet Example");

        Label label = new Label("Hello Vaadin user");
        mainWindow.addComponent(label);
        setMainWindow(mainWindow);
    }
}]]></programlisting>

			<para>
				In addition to the application class, you need the descriptor files,
				libraries, and other files as described earlier. <xref linkend="figure.advanced.liferay.helloworld.project"/> shows
				the complete project structure under Eclipse.
			</para>

			<figure xml:id="figure.advanced.liferay.helloworld.project">
				<title>Portlet Project Structure in Eclipse</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/liferay-project.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/advanced/liferay-project.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Installed as a portlet in Liferay from the <guilabel>Add
				Application</guilabel> menu, the application will show as illustrated in
				<xref linkend="figure.advanced.liferay.helloworld"/>.
			</para>

			<figure xml:id="figure.advanced.liferay.helloworld">
				<title>Hello World Portlet</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/liferay-helloworld.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/liferay-helloworld.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="advanced.liferay.widgetsets">
			<title>Installing Widget Sets and Themes in Liferay</title>
			
			<para>
				Loading widget sets and themes from a portlet WAR is possible as long as
				you have a single WAR, but it will not work if you have multiple WARs. To
				solve this, Vaadin portlets use globally installed widget sets and
				themes. Liferay actually includes them and the required configuration in
				Liferay 5.3 and later, but if you are using an earlier version of Liferay
				or have a customized widget set, you will need to do the configuration
				manually.
			</para>

			<para>
				We assume that you use the Tomcat installation included in the Liferay
				installation package, under the <filename>tomcat-x.x.x</filename>
				directory.
			</para>

			<para>
				The widget set needs to be located at
				<filename>/html/VAADIN/widgetsets/</filename> and themes at
				<filename>/html/VAADIN/themes/</filename> path under the portal
				context. You simply need to copy the contents from under your
				<filename>WebContent/VAADIN</filename> directory to the
				<filename>tomcat-x.x.x/webapps/ROOT/html/VAADIN</filename> directory under
				the Liferay installation directory. If you use a widget set or theme
				included in Vaadin, you should copy it from the Vaadin installation
				directory or extract them from Vaadin JAR.
			</para>

			<para>
				You need to define the widget set and the theme in the
				<filename>portal-ext.properties</filename> configuration file for
				Liferay. The file should normally be placed in the Liferay installation
				directory and you need to restart Liferay after creating or modifying the
				file. See Liferay documentation for details on the configuration file.
			</para>

			<para>
				Below is an example of a <filename>portal-ext.properties</filename> file:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[# Path under which the VAADIN directory is located.
# (/html is the default so it is not needed.)
# vaadin.resources.path=/html

# Portal-wide widget set
vaadin.widgetset=com.vaadin.demo.sampler.gwt.SamplerWidgetSet

# Theme to use
vaadin.theme=reindeer]]></programlisting>

			<para>
				The allowed parameters are:
			</para>

			<variablelist>
				<varlistentry>
					<term><parameter>vaadin.resources.path</parameter></term>
					<listitem>
						<para>Specifies the resource root path under the portal
						context. This is <filename>/html</filename> by default, pointing
						to the <filename>webapps/ROOT/html</filename> directory under
						Tomcat installation directory.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><parameter>vaadin.widgetset</parameter></term>
					<listitem>
						<para>The widget set class to use. Give the full path to the class
						name in the dot notation. If the parameter is not given, the
						default widget set is used.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><parameter>vaadin.theme</parameter></term>
					<listitem>
						<para>Name of the theme to use. If the parameter is not given, the
						default theme is used, which is <literal>reindeer</literal> in
						Vaadin 6.</para>
					</listitem>
				</varlistentry>
			</variablelist>

		</section>

		<section>
			<title>Handling Portlet Events</title>

			<para>
				Portals such as Liferay are not AJAX applications but reload the page
				every time a user interaction requires data from the server. They consider
				a Vaadin application as a regular (though dynamic) web page. All the AJAX
				communications required by the Vaadin application are done by the Vaadin
				Client-Side Engine (the widget set) past the portal.
			</para>

			<para>
				The only way for a portal to interact with an application is to load it
				with a <emphasis>render request</emphasis> (reloading does not reset the
				application). The render requests can be caused by user interaction with
				the portal or by loading action URLs launched from the portlet. You can
				handle render requests by implementing the
				<classname>PortletApplicationContext.PortletListener</classname> interface
				and the <methodname>handleRenderRequest()</methodname> handler method. You
				can use the request object passed to the handler to access certain portal
				data, such as user information.
			</para>

			<para>
				You can also define portal actions that you can handle in the
				<methodname>handleActionRequest()</methodname> method of the interface.
			</para>
				.
			<para>
				You add your portlet request listener to the application context of your
				application, which is a <classname>PortletApplicationContext</classname>
				when (and only when) the application is being run as a portlet.
			</para>

			<programlisting><![CDATA[// Check that we are running as a portlet.
if (getContext() instanceof PortletApplicationContext) {
    PortletApplicationContext ctx = (PortletApplicationContext) getContext();

    // Add a custom listener to handle action and render requests.
    ctx.addPortletListener(this, new MyPortletListener());
} else {
    getMainWindow().showNotification("Not initialized via Portal!",
            Notification.TYPE_ERROR_MESSAGE);
}]]></programlisting>

			<para>
				The handler methods receive references to request and response objects,
				which are defined in the Java Servlet API. Please refer to the Servlet API
				documentation for further details.
			</para>

			<para>
				The PortletDemo application included in the demo WAR package includes
				examples of processing mode and portlet window state changes in a portlet
				request listener.
			</para>
		</section>

	</section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

