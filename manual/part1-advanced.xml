<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various features and topics often needed in
        applications. While other topics could be considered as "advanced", the first
        section gives a brief introduction to AJAX development for beginners.
    </para>

	<section xml:id="advanced.application.pages">
		<title>Special Characteristics of AJAX Applications</title>
		
		<para>
            New to AJAX? This section is intended for people familiar with the development
            of either traditional web applications or desktop applications, who are
            entering AJAX-enabled web application development. AJAX application
            development has a few special characteristics with respect to other types of
            applications. Possibly the most important one is how the display is managed in
            the web browser.
		</para>

		<para>
			The web was originally not built for applications, but for hypertext
			pages that you can view with a browser. The purpose of web pages is
			to provide <emphasis>content</emphasis> for the user. Application
			software has a somewhat different purpose; usually to allow you to
			work on some data or content, much of which is not ever intended to
			be accessible through a web browser as web pages. As the web is
			inherently page-based, conventional web applications had to work with
			page requests and output HTML as response. JavaScript and AJAX have
			made it possible to let go of the pages.
		</para>

		<para>
			Pages are largely an unknown concept to conventional desktop
			applications. At most, desktop applications can open multiple
			windows, but usually they work with a single main window, with an
			occasional dialog window here and there. Same goes usually for web
			applications developed with Vaadin: an application typically
			runs on a single page, changing the layout as needed and popping up
			dialog boxes.
		</para>

		<para>
			Not having to load pages and use hyperlinks to communicate all user
			interaction is a relief for application development. However, they
			are an important feature that ordinary desktop applications
			lack. They allow referencing different functionalities of an
			application or resources managed by the application. They are also
			important for integration with external applications.
		</para>

		<para>
			Certain resources can be identified through a
			<firstterm>URI</firstterm> or <firstterm>Universal Resource
			Identifier</firstterm>.  A URI can easily be passed around or stored
			as a bookmark. We will see in <xref
			linkend="section.application.resources.uri"/> how you can retrieve
			the URI of a page request. Similarly, a page request can have query
			parameters, which can be handled as detailed in <xref
			linkend="section.application.resources.parameters"/>.
		</para>

		<para>
			Using URIs or request parameters to access functionalities or content
			is not as straight-forward as in conventional page-based web
			applications. Vaadin, just as any other AJAX framework, uses
			browser cookies not just for tracking users but also for tracking the
			application state. Cookies are unique in a browser, so any two
			windows share the same cookies and therefore also the state. The
			advantage is that you can close your browser and open it again and
			the application will be in the state where you left off (except for
			components such as text fields which did not have the immediate
			attribute enabled). The disadvantage is that there is no good way to
			distinguish between the windows, so there can usually be only a
			single application window. Even if there were several, you would have
			trouble with synchronization of application data between
			windows. Many conventional page-based web applications simply ignore
			out-of-sync situations, but such situations are risky for application
			platforms that are intended to be stable. Therefore it is safer to work with a
			single browser window. If you wish to have multiple windows in your
			application, you can create them inside the main window as
			<classname>Window</classname> objects. A URI can be used to fetch
			resources that have no particular state or to provide an entry point
			to the application.
		</para>

	</section>

	<section xml:id="application.windows">
		<title>Application-Level Windows</title>

		<para>
            Vaadin supports two types of windows: <emphasis>application-level
            windows</emphasis> and <emphasis>sub-windows</emphasis>. The application-level
            windows are native browser windows or tabs.  The <emphasis>main
            window</emphasis> is the special initial application-level window created when
            the user first started the application session by opening the URL in the
            browser. Sub-windows are freely floating HTML windows inside a browser window,
            as described in <xref linkend="application.child-windows"/>.
        </para>

        <para>
            Application-level windows of the same application use the same
            <classname>Application</classname> object and therefore share the same
            session. Each window is identified with a URL that is used to access it. This
            makes it possible to bookmark application-level windows. Such windows can even
            be created dynamically based on the URLs.
		</para>

		<para>
			Application-level windows allow several common use cases for browser-based
			applications.
		</para>

		<itemizedlist>
			<listitem>
				<emphasis>Native popup windows</emphasis>. An application can open popup
				windows for sub-tasks.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding windows</emphasis>. Windows can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="application.embedding"/>.
			</listitem>
		</itemizedlist>

		<para>
			Because of the special nature of AJAX applications, these uses require some
			caveats. We will go through them later in <xref
			linkend="application.windows.caveats"/>.
		</para>
		
		<section>
			<title>Creating New Application-Level Windows</title>

			<para>
				Creating a new application-level window is much like creating a child
				window (see <xref linkend="application.child-windows"/>), except that the
				window is added with <methodname>addWindow()</methodname> to the application
				object instead of the main window.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    public void init() {
        // First create the main window.
        final Window main = new Window ("My Test Application");
        setMainWindow(main);
         
        // Create another application-level window.
        final Window mywindow = new Window("Second Window");
        
        // Manually set the name of the window.
        mywindow.setName("mywindow");
        
        // Add some content to the window.
        mywindow.addComponent(new Label("Has content."));

        // Add the window to the application.
        addWindow(mywindow);
    }
}]]></programlisting>

			<para>
				This creates the window object that a user can view by opening a URL in
				a browser. Creating an application-level window object does not open a new
				browser window automatically to view the object, but if you wish to open
				one, you have to do it explicitly as shown below. An application-level
				window has a unique URL, which is based on the application URL and the
				name of the window given with the <methodname>setName()</methodname>
				method. For example, if the application URL is
				<uri>http://localhost:8080/myapp/</uri> and the window name is
				<literal>mywindow</literal>, the URL for the window will be
				<uri>http://localhost:8080/myapp/mywindow/</uri>. If the name of a window
				is not explicitly set with <methodname>setName()</methodname>, an
				automatically generated name will be used. The name can be retrieved with
				the <methodname>getName()</methodname> method and the entire URL with
				<methodname>getURL()</methodname>.
			</para>

			<para>
				There are three typical ways to open a new window: using the
				<methodname>open()</methodname> method of <classname>Window</classname>
				class, a <classname>Link</classname>, or referencing it from HTML or
				JavaScript code written inside a <classname>Label</classname> component.
			</para>

			<para>
				The <classname>Window</classname> <methodname>open()</methodname> method
				takes as parameters a resource to open and the target name. You can use
				<classname>ExternalResource</classname> to open a specific URL, which you
				get from the window to be opened with the
				<methodname>getURL()</methodname> method.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Create a button to open a new window. */
main.addComponent(new Button("Click to open new window",
                  new Button.ClickListener() { 
    public void buttonClick(ClickEvent event) {
        // Open the window.
        main.open(new ExternalResource(mywindow.getURL()),
                  "_new");
    }      
}));]]></programlisting>

			<para>
				The target name is one of the default HTML target names (<parameter>_new</parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, etc.) or a custom target name.  How the window is
				exactly opened depends on the browser. Browsers that support tabbed
				browsing can open the window in another tab, depending on the browser
				settings.
			</para>

			<para>
				Another typical way to open windows is to use a <classname>Link</classname>
				component with the window URL as an
				<classname>ExternalResource</classname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Add a link to the second window. */
Link link = new Link("Click to open second window",
                     new ExternalResource(mywindow.getURL()));
link.setTargetName("second");
link.setTargetHeight(300);
link.setTargetWidth(300);
link.setTargetBorder(Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);]]></programlisting>

			<para>
				Using a <classname>Link</classname> allows you to specify parameters for
				the window that opens by clicking on the link. Above, we set the
				dimensions of the window and specify what window controls the window
				should contain. The <parameter>Link.TARGET_BORDER_DEFAULT</parameter>
				specifies to use the default, which includes most of the usual window
				controls, such as the menu, the toolbar, and the status bar.
			</para>

			<para>
				Another way to allow the user to open a window is to insert the URL in
				HTML code inside a <classname>Label</classname>. This allows even more
				flexibility in specifying how the window should be opened.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Add the link manually inside a Label.
main.addComponent(
    new Label("Second window: <a href='" + mywindow.getURL()
              + "' target='second'>click to open</a>",
              Label.CONTENT_XHTML));
main.addComponent(
    new Label("The second window can be accessed through URL: "
              + mywindow.getURL()));]]></programlisting>

			<para>
				When an application-level window is closed in the browser the
				<methodname>close()</methodname> method is normally called just like
				for a child window and the <classname>Window</classname> object is
				purged from the application. However, there are situations where
				<methodname>close()</methodname> might not be called. See
				<xref linkend="application.windows.closing"/> for more information. 
			</para>

		</section>

		<section xml:id="application.windows.adhoc">
			<title>Creation of Windows When Requested</title>
			
			<para>
				You can create a window object dynamically by its URL sub-path when it is
				first requested by overriding the <methodname>getWindow()</methodname>
				method of the <classname>Application</classname> class. The method gets a
				window name as its parameter and must return the corresponding
				<classname>Window</classname> object. The window name is determined from
				the first URL path element after the application URL (the name may not
				contain slashes). See the notes below for setting the actual name of the
				dynamically created windows below.
			</para>

            <para>
                The following example allows opening windows with a window name that
                begins with "<literal>planet-</literal>" prefix. Since the method is
                called for <emphasis>every</emphasis> browser request for the
                application, we filter only the requests where a window with the given
                name does not yet exist.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    ...

    @Override
    public Window getWindow(String name) {
        // If a dynamically created window is requested, but
        // it does not exist yet, create it.
        if (name.startsWith("planet-") &&
              super.getWindow(name) == null) {
            String planetName =
                    name.substring("planet-".length());

            // Create the window object.
            Window newWindow =
                    new Window("Window about " + planetName);
            
            // DANGEROUS: Set the name explicitly. Otherwise,
            // an automatically generated name is used, which
            // is usually safer.
            newWindow.setName(name);

            // Put some content in it.
            newWindow.addComponent(
                new Label("This window contains details about " +
                          planetName + "."));
            
            // Add it to the application as a regular
            // application-level window.
            addWindow(newWindow);
            
            return newWindow;
        }

        // Otherwise the Application object manages existing
        // windows by their name.
        return super.getWindow(name);
    }]]></programlisting>

            <para>
                The window name must be a unique indentifier for each
                <classname>Window</classname> object instance. If you use
                <methodname>setName()</methodname> to set the window name explicitly, as
                we did above, any browser window that has the same URL (within the same
                browser) would open the <emphasis>same</emphasis> window object. This is
                dangerous and <emphasis>generally not recommended</emphasis>, because the
                browser windows would share the same window object. Opening two windows
                with the same static name would immediately lead to a synchronization
                error, as is shown in <xref
                linkend="figure.application.window.dynamic.error"/> below. (While also the
                window captions are same, they are irrelevant for this problem.)
            </para>

            <figure xml:id="figure.application.window.dynamic.error">
                <title>Synchronization Error Between Windows with the Same Name</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/window-application-dynamic-3.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="70" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-3.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                <!-- TODO: "below" -->
                There are some cases where setting the name explicitly is useful. The
                launch application below is one example, as it always opens the other
                windows in a window target that is specific to the window name, thereby
                never creating two windows with the same URL. Similarly, if you had
                embedded the application in a browser frame and the link would open the
                window in a frame, you would not have problems. Having a single window
                instance for a URL is also useful if the browser crashes and the user
                opens the window again, as it will have kept its previous (server-side)
                state.
            </para>
        </section>

        <section xml:id="application.windows.dynamic">
            <title>Dynamic Multi-Window Applications</title>
            
            <para>
                Having multiple browser windows or tabs open in the same website and even
                the same page is one of the basic use cases of web browsing. The creation
                of <classname>Window</classname> objects described in the previous section
                allows opening multiple special-purpose windows with different URLs, but
                how to open multiple windows with the same URL? The solution is based on
                the fact that Vaadin doesn't identify windows only by their URL subpath,
                but also by an invisible window name.
            </para>

            <para>
                Leaving the window name to be automatically generated allows opening
                multiple windows with the same URL, while each of the windows will have a
                separate state. The URL in the location bar stays unchanged and the
                generated window name is used only for the Ajax communications to identify
                the window object. A generated name is a string representation of a unique
                random number, such as "<literal>1928676448</literal>". You should be
                aware of the generated window names when overriding the
                <methodname>getWindow()</methodname> method (and not unintentionally
                create a new window instance dynamically for each such request). The
                condition in the above example would also filter out the requests for an
                already existing window with a generated name.
            </para>

            <para>
                <xref linkend="figure.application.window.dynamic.new"/> shows a
                dynamically created application-level window with the URL shown in the
                address bar. The URL for the application is here
                <uri>http://localhost:8080/book-examples/windowexample/</uri>, including
                the application context, application path. The dynamically created
                window's name is <uri>planet-mars</uri>.
            </para>

            <figure xml:id="figure.application.window.dynamic.new">
                <title>A Dynamically Created Window</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/application/window-application-dynamic-1.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-1.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The application knows the windows it already has and can return them
                after the creation. The application also handles closing and
                destruction of application-level window objects, as discussed in <xref
                    linkend="application.windows.closing"/>.
            </para>

            <para>
                Such dynamic windows could be opened as in the following example:
            </para>
			
            <programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Window Test");
    setMainWindow(main);

    // Have some IDs for the dynamically creatable windows.
    final String[] items = new String[] { "mercury", "venus",
            "earth", "mars", "jupiter", "saturn", "uranus",
            "neptune" };
    
    // Create a list of links to each of the available window.
    for (int i = 0; i < items.length; i++) {
        // Create a URL for the window.
        String windowUrl = getURL() + "planet-" + items[i];
        
        // Create a link to the window URL. Using the 
        // item ID for the target also opens it in a new
        // browser window (or tab) unique to the window name.
        main.addComponent(
            new Link("Open window about " + items[i],
                     new ExternalResource(windowUrl),
                     items[i], -1, -1, Window.BORDER_DEFAULT));
    }
}]]></programlisting>
        			
			<figure xml:id="figure.application.window.dynamic.main">
				<title>Opening Windows</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="application.windows.closing">
			<title>Closing Windows</title>

			<para>
				When the user closes an application-level window, the Client-Side Engine
				running in the browser will report the event to the server before the page
				is actually removed. You can catch the event with a
				<classname>Window.CloseListener</classname>, as is done in the example
				below.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[newWindow.addListener(new Window.CloseListener() {
    @Override
    public void windowClose(CloseEvent e) {
        // Do something.
        System.out.println(e.getWindow().getName() +
                           " was closed");

        // Add a text to the main window about closing.
        // (This does not update the main window.)
        getMainWindow().addComponent(
            new Label("Window '" + e.getWindow().getName() +
                      "' was closed."));
    }
});]]></programlisting>

			<para>
				Notice that the change to the server-side state of the main window (or
				another application-level window) does not refresh the window in the
				browser, so the change will be unseen until user interaction or polling
				refreshes the window. This problem and its dangers are discussed in <xref
				linkend="application.windows.caveats"/> below.
			</para>

			<para>
				The close event does not occur if the browser crashes or the connection
				is otherwise severed violently. In such a situation, the window object will
				be left hanging, which could become a resource problem if you allow the
				users to open many such application-level windows. The positive side is
				that the user can reconnect to the window using the window URL.
			</para>
		</section>

		<section xml:id="application.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
					For cases where you need communication between windows, we recommend
					using floating child windows. In Vaadin Release 5, an
					application window can not update the data in other windows. The
					contents of a window can only be updated when the particular window makes
					a request to the server. The request can be caused by user input or
					through polling.
				</para>

				<para>
					Changing the server-side state of a window while processing a user event
					from another window can potentially cause serious problems. Changing
					the client-side state of a window does not always immediately
					communicate the changes to the server. The server-side state can therefore
					be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.window.polling">
					<title>Communication Between Two Application-Level Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					The following example creates a second window that changes the
					contents of the main window, as illustrated in the figure above. In
					this simple case, changing the main window contents is safe.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table in the main window to hold items added
// in the second window
final Table table = new Table();
table.setPageLength(5);
table.getSize().setWidth(100, Size.UNITS_PERCENTAGE);
table.addContainerProperty("Name", String.class, "");
main.addComponent(table);

// Create the second window
final Window adderWindow = new Window("Add Items");
adderWindow.setName("win-adder");
main.getApplication().addWindow(adderWindow);

// Create selection component to add items to the table
final NativeSelect select = new NativeSelect("Select item to add");
select.setImmediate(true);
adderWindow.addComponent(select);

// Add some items to the selection
String items[] = new String[]{"-- Select --", "Mercury", "Venus", 
        "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int i=0; i<items.length; i++)
    select.addItem(items[i]);
select.setNullSelectionItemId(items[0]);

// When an item is selected in the second window, add
// table in the main window
select.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // If the selected value is something else
        // but a null selection item.
        if (select.getValue() != null) {
            // Add the selected item to the table
            // in the main window
            table.addItem(new Object[]{select.getValue()},
                          new Integer(table.size()));
        }
    }
});

// Link to open the selection window
Link link = new Link("Click to open second window",
                     new ExternalResource(adderWindow.getURL()),
                     "_new", 50, 200,
                     Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);

// Enable polling to update the main window
ProgressIndicator poller = new ProgressIndicator();
poller.addStyleName("invisible");
main.addComponent(poller);]]></programlisting>

				<para>
					The example uses an invisible <classname>ProgressIndicator</classname>
					to implement polling. This is sort of a trick and a more proper API
					for polling is under design. Making the progress indicator invisible
					requires the following CSS style definition:
				</para>

				<programlisting><![CDATA[.v-progressindicator-invisible {
    display: none;
}]]></programlisting>


			</section>
		</section>
	</section>

	<section xml:id="application.embedding">
		<title>Embedding Applications in Web Pages</title>

        <!-- TODO: Is this up-to-date? -->

		<para>
			Many web sites are not all Ajax, but Ajax is used only for specific
			functionalities. In practice, many web applications are a mixture of dynamic
			web pages and Ajax applications embedded in such pages.
		</para>

		<para>
			Embedding Vaadin applications is easy and there are several different ways to
			embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the web application and load the Vaadin Client-Side Engine with a simple
			JavaScript code. Another method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element.  Both of these methods have
			advantages and disadvantages. The <literal>&lt;div&gt;</literal> method can
			only embed one application in a page, while the
			<literal>&lt;iframe&gt;</literal> method can embed as many as needed. One
			disadvantage of the <literal>&lt;iframe&gt;</literal> method is that the size
			of the <literal>&lt;iframe&gt;</literal> element is not flexible according to
			the content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods. Additionally, the Vaadin XS add-on allows embedding Vaadin
			applications in websites running in another server.
		</para>

		<section xml:id="application.embedding.div">
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<para>
				You can embed a Vaadin application inside a web page with a
				method that is equivalent to loading the initial page content from the
				application servlet in a non-embedded application. Normally, the
				<classname>ApplicationServlet</classname> servlet generates an initial
				page that contains the correct parameters for the specific
				application. You can easily configure it to load multiple Vaadin
				applications on the same page, assuming that they use the same widget set.
			</para>

			<para>
				 You can view the initial page for your application easily simply by
				 opening the application in a web browser and viewing the HTML source
				 code. You could just copy and paste the embedding code from the default
				 initial page. It has, however, some extra functionality that is not
				 normally needed: it generates some of the script content with
				 <methodname>document.write()</methodname> calls, which is useful only
				 when you are running the application as a portlet in a portal. The method
				 outlined below is much simpler.
			</para>

			<!-- figure xml:id="figure.embedding.source">
				<title>Source Code of an Initial Page</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
				</mediaobject>
			</figure -->

			<para>
				Embedding requires four elements inside the HTML document:
			</para>

			<orderedlist>
				<listitem>
					<para>
						In the <literal>&lt;head&gt;</literal> element, you need to define
						the application URI and parameters and load the Vaadin
						Client-Side Engine. The <varname>vaadin</varname> variable is an
						associative map that can contain various runtime data used by the
						Client-Side Engine of Vaadin. The
						<varname>vaadinConfigurations</varname> item is itself an
						associate map that contains parameters for each of the
						applications embedded in the page. The map must contain the
						following items:
					</para>

                    <variablelist>
                        <varlistentry>
                            <term><classname>appUri</classname></term>
                            <listitem>
                                The application URI consists of the context and the
                                application path. If the context is
                                <literal>/mycontext</literal> and the application path is
                                <literal>myapp</literal>, the
                                <parameter>appUri</parameter> would be
                                <literal>/mycontext/myapp</literal>. The
                                <filename>multiapp.html</filename> example assumes the use
                                of root context, which is used in the demo application.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>pathInfo</classname></term>
                            <listitem>
                                The <parameter>PATHINFO</parameter> parameter for the
                                Servlet.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>themeUri</classname></term>
                            <listitem>
                                URI of the application theme. The URI must include
                                application context and the path to the theme
                                directory. Themes are, by default, stored under the
                                <filename>/VAADIN/themes/</filename> path.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>versionInfo</classname></term>
                            <listitem>
                                This item is itself an associative map that contains two
                                parameters: <parameter>vaadinVersion</parameter> contains
                                the version number of the Vaadin version used by the
                                application. The <parameter>applicationVersion</parameter>
                                parameter contains the version of the particular
                                application.
                            </listitem>
                        </varlistentry>
                    </variablelist>

					<para>
						The following example defines two applications to run in the same
						window: the Calculator and Hello World examples. In the example,
						the application context is <literal>/tk5</literal>.
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script type="text/javascript"&gt;
    var vaadin = {
        vaadinConfigurations: {
            '<emphasis role="bold">calc</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/Calc</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                         NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            },
            '<emphasis role="bold">hello</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/HelloWorld</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                          NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            }
        }};
&lt;/script&gt;</programlisting>
				</listitem>

				<listitem>
					<para>
						Loading the Vaadin Client-Side Engine is done with the
						following kind of line in the <literal>&lt;head&gt;</literal>
						element:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script language='javascript' src='/<emphasis>vaadin-examples</emphasis>/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'&gt;&lt;/script&gt;</programlisting>

					<para>
						The engine URI consists of the context of the web application,
						<literal>vaadin-examples</literal> above, followed by the path
						to the JavaScript (<filename>.js</filename>) file of the widget
						set, relative to the <filename>WebContent</filename>
						directory. The file contains the Client-Side Engine compiled for
						the particular widget set. The line above assumes the use of the
						default widget set of Vaadin. If you have made custom
						widgets that are defined in a custom widget set, you need to use
						the path to the compiled widget set file. Widget sets must be
						compiled under the
						<filename>WebContent/VAADIN/widgetsets</filename> directory.
					</para>

				</listitem>
				<listitem>
					<para>
						In the <literal>&lt;html&gt;</literal> element, you need to do a
						routine inclusion of GWT history <literal>iframe</literal>
						element as follows:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;iframe id="__gwt_historyFrame"
        style="width:0;height:0;border:0"&gt;&lt;/iframe&gt;</programlisting>

				</listitem>
				<listitem>
					<para>
						The location of the Vaadin application is defined with a
						<literal>div</literal> placeholder element having
						<literal>id="calc"</literal>, where the identifier is the
						same as in the <parameter>vaadinConfigurations</parameter>
						parameter, as follows:
					</para>

					<programlisting>&lt;div id="calc"/&gt;</programlisting>
				</listitem>
			</orderedlist>

			<para>
				Below is a complete example of embedding an application. It works
				out-of-the-box with the <application>Calculator</application> demo
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding Example</title>

    <!-- Set parameters for the Vaadin Client-Side Engine. -->
    <script type="text/javascript">
	    var vaadin = {appUri:'Calc', pathInfo: '/'};
    </script>
    
    <!-- Load the Vaadin Client-Side Engine. -->
    <script language='javascript' src='/vaadin-examples/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'></script>

    <!-- We can stylize the web application. -->
    <style>
        #vaadin-ajax-window {background: #c0c0ff;}
        .v-button {background: pink;}
    </style>
  </head>

  <body>
    <!-- This <iframe> element is required by GWT. -->
    <iframe id="__gwt_historyFrame"
            style="width:0;height:0;border:0"></iframe>
    
    <h1>This is a HTML page</h1>
    <p>Below is the Vaadin application inside a table:</p>
    <table align="center" border="3" style="background: yellow;">
      <tr><th>The Calculator</th></tr>
      <tr>
        <td>
          <!-- Placeholder <div> for the Vaadin application -->
          <div id="vaadin-ajax-window"/>
        </td>
      </tr>
    </table>	
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.div"/>.
			</para>

			<figure xml:id="figure.embedding.div" float="center" floatstyle="before">
				<title>Embedded Application</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can style the web application with themes as described in <xref
				linkend="themes"/>. The Client-Side Engine loads the style sheets
				required by the application. In addition, you can do styling in the
				embedding page, as was done in the example above.
			</para>

			<para>
				The disadvantage of this embedding method is that there can only be one
				web application embedded in a page. One is usually enough, but if it is
				not, you need to use the <literal>&lt;iframe&gt;</literal> method below.
			</para>

		</section>

		<section xml:id="application.embedding.iframe">
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding a Vaadin application inside an
				<literal>&lt;iframe&gt;</literal> element is even easier than the method
				described above, as it does not require definition of any Vaadin specific
				definitions. The use of <literal>&lt;iframe&gt;</literal> makes it
				possible to embed multiple web applications or two different views to the
				same application on the same page.
			</para>

			<para>
				You can embed an application with an element such as the following:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<iframe src="/vaadin-examples/Calc"></iframe>]]></programlisting>

			<para>
				The problem with <literal>&lt;iframe&gt;</literal> elements is that their
				size of is not flexible depending on the content of the frame, but the
				content must be flexible to accommodate in the frame. You can set the size
				of an <literal>&lt;iframe&gt;</literal> element with
				<literal>height</literal> and <literal>width</literal> attributes.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside
       a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker"
                  height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                You can embed almost anything in an iframe, which essentially acts as a
                browser window. However, this creates various problems. The iframe must
                have a fixed size, inheritance of CSS from the embedding page is not
                possible, and neither is interaction with JavaScript, which makes mashups
                impossible, and so on. Even bookmarking with URI fragments will not work.
            </para>

            <para>
                Note also that websites can forbid iframe embedding by specifying an
                <literal>X-Frame-Options: SAMEORIGIN</literal> header in the HTTP
                response.
            </para>
		</section>

		<section xml:id="application.embedding.xs">
            <title>Cross-Site Embedding with the Vaadin XS Add-on</title>

            <para>
                In the previous sections, we described the two basic methods for embedding
                Vaadin applications: in a <literal>&lt;div&gt;</literal> element and in an
                <literal>&lt;iframe&gt;</literal>. One problem with div embedding is that
                it does not work between different Internet domains, which is a problem if
                you want to have your website running in one server and your Vaadin
                application in another. The security model in browsers effectively
                prevents such cross-site embedding of Ajax applications by enforcing the
                <emphasis>same origin policy</emphasis> for XmlHttpRequest calls, even if
                the server is running in the same domain but different port. While iframe
                is more permissive, allowing embedding almost anything in anywhere, it has
                many disadvantanges, as described earlier.
            </para>

            <para>
                The Vaadin XS (Cross-Site) add-on works around the limitation in div
                embedding by using JSONP-style communication instead of the standard
                XmlHttpRequests.
            </para>

            <para>
                Embedding is done simply with:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>]]></programlisting>

            <para>
                This includes an automatically generated embedding script in the page,
                thereby making embedding effortless.
            </para>

            <para>
                This assumes that the main layout of the application has undefined
                height. If the height is 100%, you have to wrap it inside an element with
                a defined height. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[ <div style="height: 500px;">
  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>
</div>]]></programlisting>

            <para>
                It is possible to restrict where the application can be embedded by using
                a whitelist. The add-on also encrypts the client-server communication,
                which is more important for embedded applications than usual.
            </para>

            <para>
                You can get the Vaadin XS add-on from Vaadin Directory. It is provided as
                a Zip package. Download and extract the installation package to a local
                folder. Instructions for installation and further information is given in
                the <filename>README.html</filename> file in the package.
            </para>

            <para>
                Some restrictions apply. You can have only one embedded application in one
                page. Also, some third-party libraries may interfere with the
                communication. Other notes are given in the README.
            </para>
        </section>
	</section>

	<section xml:id="advanced.debug-production-modes">
		<title>Debug and Production Mode</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug
			mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode,
			which is on by default, enables a number of built-in debug features for the
			developers. The features include:
		</para>

		<itemizedlist>
			<listitem>Debug Window for accessing debug functionalities</listitem>
			<listitem>Display debug information in the Debug Window and server console.</listitem>
			<listitem><guibutton>Analyze layouting</guibutton> button that analyzes the layout for possible problems.</listitem>
		</itemizedlist>

		<para>
			All applications are run in the debug mode by default (since IT Mill Toolkit
			version 5.3.0). The production mode can be enabled, and debug mode thereby
			disabled, by adding a <parameter>productionMode=true</parameter> parameter to
			the servlet context in the <filename>web.xml</filename> deployment descriptor:
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[<context-param>
  <description>Vaadin production mode</description>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
</context-param>]]></programlisting>
		
		<para>
			Enabling the production mode disables the debug features, thereby preventing
			users from easily inspecting the inner workings of the application from the
			browser.
		</para>
		
		<section xml:id="advanced.debug-production-modes.debug.mode">
			<title>Debug Mode</title>
			
			<para>
				Running an application in the debug mode enables the client-side Debug
				Window in the browser. You can open the Debug Window by adding
				"<uri>?debug</uri>" to the application URL, for example,
				<uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in
				<xref linkend='figure.debug.window'/>, consists of buttons controlling the
				debugging features and a scrollable log of debug messages.
			</para>

			<figure id="figure.debug.window">
				<title>Debug Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<variablelist>
				<varlistentry>
					<term><guibutton>Clear console</guibutton></term>
					<listitem>
						Clears the log in the Debug Window.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Restart app</guibutton></term>
					<listitem>
						Restarts the application.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Force layout</guibutton></term>
					<listitem>
						Causes all currently visible layouts to recalculate their
						appearance. Layout components calculate the space required by all
						child components, so the layout appearance must be recalculated
						whenever the size of a child component is changed. In normal
						applications, this is done automatically, but when you do themeing
						or alter the CSS with Firebug, you may need to force all layouts
						to recalculate themselves, taking into account the recently made
						changes.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Analyze layouts</guibutton></term>
					<listitem>
						This is described in the following section.
					</listitem>
				</varlistentry>
			</variablelist>

			<para>
				If you use the Firebug plugin in Mozilla Firefox, the log messages will
				also be printed to the Firebug console. In such a case, you may want to
				enable client-side debugging without showing the Debug Window with
				"<uri>?debug=quiet</uri>" in the URL. In the quiet debug mode, log
				messages will only be printed to the Firebug console.
			</para>
		</section>

 		<section>
			<title>Analyzing Layouts</title>
			<para>
				The <guilabel>Analyze layouts</guilabel> button analyzes the currently
				visible layouts and makes a report of possible layout related
				problems. All detected layout problems are displayed in the log and also
				printed to the console.
			</para>

			<para>
				The most common layout problem is caused by placing a component that has a
				relative size inside a container (layout) that has undefined size, for
				example, adding a 100% wide <classname>Panel</classname> inside a
				<classname>HorizontalLayout</classname> with no width specification. In
				such a case, the error will look as shown below:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Vaadin DEBUG
- Window/1a8bd74 "My window" (width: MAIN WINDOW)
  - HorizontalLayout/1cf243b (width: UNDEFINED)
    - Panel/12e43f1 "My panel" (width: RELATIVE, 100.0 %)
Layout problem detected: Component with relative width inside a HorizontalLayout with no width defined
Relative sizes were replaced by undefined sizes, components may not render as expected.]]>
			</programlisting>
			
			<para>
				This particular error tells that the <classname>Panel</classname> "My
				panel" is 100% wide while the width of the containing
				<classname>HorizontalLayout</classname> is undefined. The components will
				be rendered as if the the width of the contained
				<classname>Panel</classname> was undefined, which might not be what the
				developer wanted. There are two possible fixes for this case: if the
				<classname>Panel</classname> should fill the main window horizontally, set
				a width for the <classname>HorizontalLayout</classname> (for example 100%
				wide), or set the width of the <classname>Panel</classname> to "undefined"
				to render the it as it is currently rendered but avoiding the warning
				message.
			</para>

			<para>
				The same error is shown in the Debug Window in a slightly different form
				and with an additional feature (see <xref
				linkend='figure.debug-window.analyze-layouts'/>). Checking the
				<guilabel>Emphasize component in UI</guilabel> box will turn red the
				background of the component that caused a warning, making it easy for
				the developer to figure out which component each warning relates to. The
				messages will also be displayed hierarchically, as a warning from a
				containing component often causes more warnings from its child
				components. A good rule of thumb is to work on the upper-level problems
				first and only after that worry about the warnings from the children.
			</para>
			
			<figure id="figure.debug-window.analyze-layouts">
				<title>Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
				</mediaobject>
			</figure>
						
		</section>

		<section>
			<title>Custom Layouts</title>

			<para>
				<classname>CustomLayout</classname> components can not be analyzed in the
				same way as other layouts. For custom layouts, the <guibutton>Analyze
				layouts</guibutton> button analyzes all contained relative-sized
				components and checks if any relative dimension is calculated to zero so
				that the component will be invisible. The error log will display a warning
				for each of these invisible components. It would not be meaningful to
				emphasize the component itself as it is not visible, so when you select
				such an error, the parent layout of the component is emphasized if
				possible.
			</para>

		</section>

		<section>
			<title>Debug Functions for Component Developers</title>

			<para>
				You can take advantage of the debug mode when developing client-side
				components. The static function
				<methodname>ApplicationConnection.getConsole()</methodname> will return a
				reference to a <classname>Console</classname> object which contains
				logging methods such as <methodname>log(String msg)</methodname> and
				<methodname>error(String msg)</methodname>.  These functions will print
				messages to the Debug Window and Firebug console in the same way as other
				debugging functionalities of Vaadin do. No messages will be
				printed if the Debug Window is not open or if the application is running
				in production mode.
			</para>
		</section>
	</section>

	<section xml:id="advanced.resources">
		<title>Resources</title>

		<para>
			In addition to high-level resource classes described in <xref
			linkend="application.resources"/>, Vaadin provides low-level facilities
			for retrieving the URI and other parameters of HTTP requests. In the
			following, we will look into low-level interfaces for handling URIs and
			parameters to provide resources and functionalities.
		</para>

		<para>
			Notice that using URI or parameter handlers to create "pages" is not
			meaningful in Vaadin or in AJAX applications generally. See <xref
			linkend="advanced.application.pages"/> for reasons.
		</para>

		<section xml:id="section.application.resources.uri">
			<title>URI  Handlers</title>

			<para>
				The URI parameter for the application is useful mainly for two purposes:
				for providing some special functionality according to the URI or for
				providing dynamic content. Dynamic content can also be provided with
				<classname>StreamResource</classname>.
			</para>

			<para>
				You can retrieve the URI for the HTTP request made for your
				application by implementing the
				<classname>com.vaadin.terminal.URIHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addURIHandler()</methodname> method. You then get the
				URI by implementing the <methodname>handleURI()</methodname>
				method. The method gets two parameters: a context and a URI
				relative to the context. The context is the base URI for your
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Hello window");
    setMainWindow(main);

    URIHandler uriHandler = new URIHandler() {
        public DownloadStream handleURI(URL context,
                                        String relativeUri) {
            // Do something here
            System.out.println("handleURI=" + relativeUri);

            // Should be null unless providing dynamic data.
            return null;
        }
    };
    main.addURIHandler(uriHandler);

}]]></programlisting>

			<para>
				If you have multiple URI handlers attached to a window, they are executed
				after one another. The URI handlers should return
				<parameter>null</parameter>, unless you wish to provide dynamic content
				with the call. Other URI handlers attached to the window will not be
				executed after some handler returns non-null data. The combined parameter
				and URI handler example below shows how to create dynamic content with a
				URI handler.
			</para>

			<para>
				Notice that if you do provide dynamic content with a URI handler, the
				dynamic content is returned in the HTTP response. If the handler makes any
				changes to the UI state of the application, these changes are not rendered
				in the browser, as they are usually returned in the HTTP response made by
				the Application object and now the custom URI handler overrides the
				default behaviour. If your client-side code makes a server call that does
				update the UI state, the client-side must initiate an update from the
				server. For example, if you have an integration situation where you make a
				JavaScript call to the server, handle the request with a URI handler,
				and the server state changes as a side-effect, you can use the
				<methodname>vaadin.forceSync()</methodname> method to force the update.
			</para>

		</section>

		<section xml:id="section.application.resources.parameters">
			<title>Parameter Handlers</title>
		
			<para>
				You can retrieve the parameters passed to your application by
				implementing the
				<classname>com.vaadin.terminal.ParameterHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addParameterHandler()</methodname> method. You then
				get the parameters in the
				<methodname>handleParameters()</methodname> method. The
				parameters are passes as a map from string key to a vector of
				string values.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[class MyParameterHandler implements ParameterHandler {
    public void handleParameters(Map parameters) {
        // Print out the parameters to standard output
        for (Iterator it = parameters.keySet().iterator();
             it.hasNext();) {
            String key   = (String) it.next();
            String value = ((String[]) parameters.get(key))[0];
            System.out.println("Key: "+key+", value: "+value);
        }
    }
}]]></programlisting>

			<para>
				The parameter handler is not called if there are no parameters. Parameter
				handler is called before the URI handler, so if you handle both, you might
				typically want to just store the URI parameters in the parameter handler
				and do actual processing in URI handler. This allows you, for example, to
				create dynamic resources based on the URI parameters.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.util.Map;
import javax.imageio.ImageIO;
import com.vaadin.terminal.*;

/**
 * Demonstrates handling URI parameters and the URI itself to
 * create a dynamic resource.
 */
public class MyDynamicResource implements URIHandler,
                                          ParameterHandler {
    String textToDisplay = "- no text given -";

    /**
     * Handle the URL parameters and store them for the URI
     * handler to use.
     */
    public void handleParameters(Map parameters) {
        // Get and store the passed HTTP parameter.
        if (parameters.containsKey("text"))
            textToDisplay =
                ((String[])parameters.get("text"))[0];
    }

    /**
     * Provides the dynamic resource if the URI matches the
     * resource URI. The matching URI is "/myresource" under
     * the application URI context.
     * 
     * Returns null if the URI does not match. Otherwise
     * returns a download stream that contains the response
     * from the server.
     */
    public DownloadStream handleURI(URL context,
                                    String relativeUri) {
        // Catch the given URI that identifies the resource,
        // otherwise let other URI handlers or the Application
        // to handle the response.
        if (!relativeUri.startsWith("myresource"))
            return null;
        
        // Create an image and draw some background on it.
        BufferedImage image = new BufferedImage (200, 200,
                                    BufferedImage.TYPE_INT_RGB);
        Graphics drawable = image.getGraphics();
        drawable.setColor(Color.lightGray);
        drawable.fillRect(0,0,200,200);
        drawable.setColor(Color.yellow);
        drawable.fillOval(25,25,150,150);
        drawable.setColor(Color.blue);
        drawable.drawRect(0,0,199,199);
        
        // Use the parameter to create dynamic content.
        drawable.setColor(Color.black);
        drawable.drawString("Text: "+textToDisplay, 75, 100);

        try {
            // Write the image to a buffer.
            ByteArrayOutputStream imagebuffer =
                    new ByteArrayOutputStream();
            ImageIO.write(image, "png", imagebuffer);

            // Return a stream from the buffer.
            ByteArrayInputStream istream =
                    new ByteArrayInputStream(
                            imagebuffer.toByteArray());
            return new DownloadStream (istream,null,null);
        } catch (IOException e) {
            return null;
        }
    }
}]]></programlisting>

			<para>
				When you use the dynamic resource class in your application, you obviously
				need to provide the same instance of the class as both types of handler:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[MyDynamicResource myresource = new MyDynamicResource();
mainWindow.addParameterHandler(myresource);
mainWindow.addURIHandler(myresource);]]></programlisting>

			<figure>
				<title>Dynamic Resource with URI Parameters</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" smallscale="100%" align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

    <!--
	<section xml:id="advanced.servlet">
		<title>Java Servlet Parameters</title>

       UNFINISHED
	</section>
    -->

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

        <para>
            Vaadin provides simple ways for defining shortcut keys for field components
            and a default button, and a lower-level generic shortcut key binding API based
            on actions.
        </para>

        <section xml:id="advanced.shortcuts.defaultbutton">
            <title>Click Shortcuts for Default Buttons</title>

            <para>
                You can add or set a <emphasis>click shortcut</emphasis> to a button to
                set it as "default" button; pressing the defined key, typically
                <keycap>Enter</keycap>, in any component in the window causes a click
                event for the button.
            </para>

            <para>
                You can define a click shortcut with the
                <methodname>setClickShortcut()</methodname> shorthand method:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an OK button and set it as the default button
Button ok = new Button("OK");
ok.setClickShortcut(KeyCode.ENTER);
ok.addStyleName("primary");]]></programlisting>

            <para>
                The <literal>primary</literal> style name highlights a button to show the
                default button status; usually with a bolder font than usual, depending on
                the theme. The result can be seen in <xref
                linkend="figure.advanced.shortcuts.defaultbutton"/>.
            </para>

			<figure xml:id="figure.advanced.shortcuts.defaultbutton">
				<title>Default Button with Click Shortcut</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="advanced.shortcuts.focus">
            <title>Field Focus Shortcuts</title>

            <para>
                You can define a shortcut key that sets the focus to a field component
                (any component that inherits <classname>AbstractField</classname>) by
                adding a <classname>FocusShortcut</classname> as a shortcut listener to
                the field.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A field with Alt+N bound to it
TextField name = new TextField("Name (Alt+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.ALT));
layout.addComponent(name);

// A field with Alt+A bound to it
TextField address = new TextField("Address (Alt+A)");
address.addShortcutListener(
        new AbstractField.FocusShortcut(address, KeyCode.A,
                                        ModifierKey.ALT));
layout.addComponent(address);]]></programlisting>

            <para>
                The constructor of the <classname>FocusShortcut</classname> takes the
                field component as its first parameter, followed by the key code, and an
                optional list of modifier keys, as listed in <xref
                    linkend="advanced.shortcuts.keycodes"/>.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.actions">
            <title>Generic Shortcut Actions</title>

            <para>
                Shortcut keys can be defined as <emphasis>actions</emphasis> using the
                <classname>ShortcutAction</classname> class. ShortcutAction extends the
                generic <classname>Action</classname> class that is used for example in
                <classname>Tree</classname> and <classname>Table</classname> for context
                menus.  Currently, the only classes that accept
                <classname>ShortcutAction</classname>s are <classname>Window</classname>
                and <classname>Panel</classname>.
            </para>
		
            <para>
                To handle key presses, you need to define an action handler by
                implementing the <classname>Handler</classname> interface. The interface
                has two methods that you need to implement:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>.
            </para>

            <para>
                The <methodname>getActions()</methodname> method must return an array of
                <classname>Action</classname> objects for the component, specified with the
                second parameter for the method, the <parameter>sender</parameter> of an
                action. For a keyboard shortcut, you use a
                <classname>ShortcutAction</classname>. The implementation of the method
                could be following:
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an event
Action action_ok = new ShortcutAction("Default key",
        ShortcutAction.KeyCode.ENTER, null);

// Have the C key modified with Alt cause an event
Action action_cancel = new ShortcutAction("Alt+C",
        ShortcutAction.KeyCode.C,
        new int[] { ShortcutAction.ModifierKey.ALT });

Action[] actions = new Action[] {action_cancel, action_ok};

public Action[] getActions(Object target, Object sender) {
    if (sender == myPanel)
        return actions;

    return null;
}]]></programlisting>

            <para>
                The returned <classname>Action</classname> array may be static or you can
                create it dynamically for different senders according to your needs.
            </para>

            <para>
                The constructor of <classname>ShortcutAction</classname> takes a symbolic
                caption for the action; this is largely irrelevant for shortcut actions in
                their current implementation, but might be used later if implementors use
                them both in menus and as shortcut actions.  The second parameter is the
                key code and the third a list of modifier keys, which are listed in <xref
                linkend="advanced.shortcuts.keycodes"/>.
            </para>

            <para>
                The following example demonstrates the definition of a default button for a
                user interface, as well as a normal shortcut key,
                <keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
                <guibutton>Cancel</guibutton> button.
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[public class DefaultButtonExample extends CustomComponent
                                  implements Handler {
    // Define and create user interface components
    Panel panel = new Panel("Login");
    FormLayout formlayout = new FormLayout();
    TextField username = new TextField("Username");
    TextField password = new TextField("Password");
    HorizontalLayout buttons = new HorizontalLayout();

    // Create buttons and define their listener methods.
    Button ok = new Button("OK", this, "okHandler");
    Button cancel = new Button("Cancel", this, "cancelHandler");

    // Have the unmodified Enter key cause an event
    Action action_ok = new ShortcutAction("Default key",
            ShortcutAction.KeyCode.ENTER, null);

    // Have the C key modified with Alt cause an event
    Action action_cancel = new ShortcutAction("Alt+C",
            ShortcutAction.KeyCode.C,
            new int[] { ShortcutAction.ModifierKey.ALT });

    public DefaultButtonExample() {
        // Set up the user interface
        setCompositionRoot(panel);
        panel.addComponent(formlayout);
        formlayout.addComponent(username);
        formlayout.addComponent(password);
        formlayout.addComponent(buttons);
        buttons.addComponent(ok);
        buttons.addComponent(cancel);

        // Set focus to username
        username.focus();

        // Set this object as the action handler
        System.out.println("adding ah");
        panel.addActionHandler(this);

        System.out.println("start done.");
    }

    /**
     * Retrieve actions for a specific component. This method
     * will be called for each object that has a handler; in
     * this example just for login panel. The returned action
     * list might as well be static list.
     */
    public Action[] getActions(Object target, Object sender) {
        System.out.println("getActions()");
        return new Action[] { action_ok, action_cancel };
    }

    /**
     * Handle actions received from keyboard. This simply directs
     * the actions to the same listener methods that are called
     * with ButtonClick events.
     */
    public void handleAction(Action action, Object sender,
                             Object target) {
        if (action == action_ok) {
            okHandler();
        }
        if (action == action_cancel) {
            cancelHandler();
        }
    }

    public void okHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("OK clicked. "
                + "User=" + username.getValue() + ", password="
                + password.getValue()));
    }

    public void cancelHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("Cancel clicked. User="
                + username.getValue() + ", password="
                + password.getValue()));
    }
}]]></programlisting>

            <para>
                Notice that the keyboard actions can currently be attached only to
                <classname>Panel</classname>s and <classname>Window</classname>s. This can
                cause problems if you have components that require a certain key. For
                example, multi-line <classname>TextField</classname> requires the
                <keycap>Enter</keycap> key. There is currently no way to filter the
                shortcut actions out while the focus is inside some specific component, so
                you need to avoid such conflicts.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.keycodes">
            <title>Supported Key Codes and Modifier Keys</title>
            
            <para>
                The shortcut key definitions require a key code to identify the pressed
                key and modifier keys, such as Shift, Alt, or Ctrl, to specify a key
                combination.
            </para>

            <para>
                The key codes are defined in the
                <classname>ShortcutAction.KeyCode</classname> interface and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term>Keys <parameter>A</parameter> to <parameter>Z</parameter></term>
                    <listitem>Normal letter keys</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>F1</parameter> to <parameter>F12</parameter></term>
                    <listitem>
                        <para>Function keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter></term>
                    <listitem>
                        <para>Control keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>NUM0</parameter> to <parameter>NUM9</parameter></term>
                    <listitem>
                        <para>Number pad keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter></term>
                    <listitem>
                        <para>Arrow keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter></term>
                    <listitem>
                        <para>Other movement keys</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Modifier keys are defined in
                <classname>ShortcutAction.ModifierKey</classname> and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>ModifierKey.ALT</parameter></term>
                    <listitem>Alt key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.CTRL</parameter></term>
                    <listitem>Ctrl key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.SHIFT</parameter></term>
                    <listitem>Shift key</listitem>
                </varlistentry>
            </variablelist>

            <para>
                All constructors and methods accepting modifier keys take them as a
                variable argument list following the key code, separated with commas. For
                example, the following defines a
                <keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>N</keycap></keycombo>
                key combination for a shortcut.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField name = new TextField("Name (Ctrl+Shift+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.CTRL,
                                        ModifierKey.SHIFT));]]></programlisting>

            <section>
                <title>Supported Key Combinations</title>

                <para>
                    The actual possible key combinations vary greatly between browsers, as
                    most browsers have a number of built-in shortcut keys, which can not
                    be used in web applications. For example, Mozilla Firefox allows
                    binding almost any key combination, while Opera does not even allow
                    binding Alt shortcuts. Other browsers are generally in between these
                    two. Also, the operating system can reserve some key combinations and
                    some computer manufacturers define their own system key combinations.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="advanced.printing">
		<title>Printing</title>

        <indexterm xml:id="term.advanced.printing" class="startofrange">
            <primary>printing</primary>
        </indexterm>

		<para>
			Vaadin does not currently have any special support for
			printing. Printing on the server-side is, in any case, largely independent from the
			web UI of an application. You just have to take care that the printing does
			not block server requests, possibly by running printing in another thread.
		</para>

		<para>
            <indexterm xml:id="term.advanced.printing.print" class="startofrange">
                <primary><methodname>print()</methodname></primary>
            </indexterm>
            <indexterm xml:id="term.advanced.printing.JavaScript.print" class="startofrange">
                <primary>JavaScript</primary>
                <secondary><methodname>print()</methodname></secondary>
            </indexterm>
            
			For client-side printing, most browsers support printing the web page. Vaadin
			does not explicitly support launching the printing in browser, but you can
			easily use the JavaScript <methodname>print()</methodname> method that opens
			the print window of the browser.
		</para>

        <indexterm><primary>JavaScript</primary><secondary><methodname>executeJavaScript()</methodname></secondary></indexterm>
        <indexterm><primary><methodname>executeJavaScript()</methodname></primary></indexterm>

		<programlisting><?pocket-size 65% ?><![CDATA[final Button print = new Button("Print This Page");
print.addListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        print.getWindow().executeJavaScript("print();");
    }
});]]></programlisting>

		<para>
			This button would print the current page, including the button itself. Often,
			you want to be able to print a report or receipt and it should not have any
			visible UI components. In such a case, you could offer it as a PDF resource,
			or you could open a new window, as is done below, and automatically launch
			printing.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[// A button to open the printer-friendly page.
Button print = new Button("Click to Print");

print.addListener(new Button.ClickListener() {
	public void buttonClick(ClickEvent event) {
        // Create a window that contains what you want to print
        Window window = new Window("Window to Print");

        // Have some content to print
        window.addComponent(new Label(
                "<h1>Here's some dynamic content</h1>\n" +
                "<p>This is to be printed to the printer.</p>",
                Label.CONTENT_XHTML));

        // Add the printing window as a new application-level
        // window
        getApplication().addWindow(window);

        // Open it as a popup window with no decorations
        getWindow().open(new ExternalResource(window.getURL()),
                "_blank", 500, 200,  // Width and height 
                Window.BORDER_NONE); // No decorations

        // Print automatically when the window opens.
        // This call will block until the print dialog exits!
        window.executeJavaScript("print();");

        // Close the window automatically after printing
        window.executeJavaScript("self.close();");
    }
});]]></programlisting>

		<para>
			How the browser opens the window, as an actual (popup) window or just a tab, depends
			on the browser. Notice that calling the <methodname>print()</methodname> method in the
            window will block the entire application until the print dialog exits.

            <indexterm><primary><classname>Window</classname></primary><secondary>closing</secondary></indexterm>

            After printing, we automatically close the window with another JavaScript
            call, as there is no <methodname>close()</methodname> method in
            <classname>Window</classname>.
		</para>

        <indexterm startref="term.advanced.printing.print" class="endofrange"/>
        <indexterm startref="term.advanced.printing.JavaScript.print" class="endofrange"/>

		<para>
            <indexterm><primary>PDF</primary></indexterm>

			Printing as PDF would not require creating a <classname>Window</classname>
			object, but you would need to provide the content as a static or a dynamic
			resource for the <methodname>open()</methodname> method. Printing a PDF file
			would obviously require a PDF viewer cabability (such as Adobe Reader) in the
			browser.
		</para>

        <indexterm startref="term.advanced.printing" class="endofrange"/>
	</section>

	<section xml:id="advanced.gae">
		<title>Google App Engine Integration</title>

		<para>
			Vaadin includes support to run Vaadin applications in the Google App Engine
			(GAE). The most essential requirement for GAE is the ability to serialize the
			application state. Vaadin applications are serializable through the
			<classname>java.io.Serializable</classname> interface.
		</para>

		<para>
			To run as a GAE application, an application must use
			<classname>GAEApplicationServlet</classname> instead of
			<classname>ApplicationServlet</classname> in <filename>web.xml</filename>, and
			of course implement the <classname>java.io.Serializable</classname> interface
			for all persistent classes.  You also need to enable session support in
			<filename>appengine-web.xml</filename> with:
		</para>
		
		<programlisting><![CDATA[<sessions-enabled>true</sessions-enabled>]]></programlisting>

		<para>
			The Vaadin Project wizard can create the configuration files needed for GAE
			deployment. See <xref linkend="getting-started.first-project.creation"/>. When
			the Google App Engine deployment configuration is selected, the wizard will
			create the project structure following the GAE Servlet convention instead of
			the regular Servlet convention. The main differences are:
		</para>

		<itemizedlist>
			<listitem>Source directory: <filename>src/main/java</filename></listitem>
			<listitem>Output directory: <filename>war/WEB-INF/classes</filename></listitem>
			<listitem>Content directory: <filename>war</filename></listitem>
		</itemizedlist>

		<simplesect>
			<title>Rules and Limitations</title>

			<para>
				Running Vaadin applications in Google App Engine has the following rules
				and limitations:
			</para>
			
			<itemizedlist>
				<listitem><para>Avoid using the session for storage, usual App Engine
				limitations apply (no synchronization, that is, it is
				unreliable).</para></listitem>

				<listitem><para>Vaadin uses memcache for mutex, the key is of the form
				<parameter>_vmutex&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para>The Vaadin <classname>WebApplicationContext</classname>
				class is serialized separately into memcache and datastore; the memcache
				key is <parameter>_vac&lt;sessionid&gt;</parameter> and the datastore
				entity kind is <parameter>_vac</parameter> with identifiers of the type
				<parameter>_vac&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para><emphasis>Do not</emphasis> update the application state when serving an
				<classname>ApplicationResource</classname> (such as
				<classname>ClassResource</classname>.<methodname>getStream()</methodname>).</para></listitem>

				<listitem><para><emphasis>Avoid</emphasis> (or be very careful when)
				updating application state in a <classname>TransactionListener</classname>
				- it is called even when the application is not locked and won't be
				serialized (such as with <classname>ApplicationResource</classname>), and
				changes can therefore be lost (it should be safe to update things that can
				be safely discarded later, that is, valid only for the current
				request).</para></listitem>

				<listitem><para>The application remains locked during uploads - a progress
				bar is not possible.</para></listitem>
			</itemizedlist>
		</simplesect>
	</section>

	<section xml:id="advanced.security">
		<title>Common Security Issues</title>

		<section xml:id="advanced.security.sanitizing">
			<title>Sanitizing User Input to Prevent Cross-Site Scripting</title>
			
			<para>
				You can put raw XHTML content in many components, such as the
				<classname>Label</classname> and <classname>CustomLayout</classname>, as
				well as in tooltips and notifications. In such cases, you should make sure
				that if the content has any possibility to come from user input, the input
				is well sanitized before displaying it. Otherwise, a malicious user can
				easily make a cross-site scripting attack by injecting offensive
				JavaScript code in such components.
			</para>

			<para>
				Offensive code can easily be injected with
				<literal>&lt;script&gt;</literal> markup or in tag attributes as events,
				such as <parameter>onLoad</parameter>. Cross-site scripting
				vulnerabilities are browser dependent, depending on the situations in
				which different browsers execute scripting markup.
			</para>

			<para>
				There is no generic way to sanitize user input as different applications
				can allow different kinds of input. Pruning (X)HTML tags out is somewhat
				simple, but some applications may need to allow (X)HTML.  It is therefore
				the responsibility of the application to sanitize the input.
			</para>

			<para>
				Character encoding can make sanitization more difficult, as offensive tags
				can be encoded so that they are not recognized by a sanitizer. This can be
				done, for example, with HTML character entities and with variable-width
				encodings such as UTF-8 or various CJK encodings, by abusing multiple
				representations of a character. Most trivially, you could input
				<literal>&lt;</literal> and <literal>&gt;</literal> with
				<literal>&amp;lt;</literal> and <literal>&amp;gt;</literal>,
				respectively. The input could also be malformed and the sanitizer must be
				able to interpret it exactly as the browser would, and different browsers
				can interpret malformed HTML and variable-width character encodings
				differently.
			</para>

			<para>
				Notice that the problem applies also to user input from a
				<classname>RichTextArea</classname> is transmitted as XHTML from the
				browser to server-side and is not sanitized. As the entire purpose of the
				<classname>RichTextArea</classname> component is to allow input of
				formatted text, you can not just remove all HTML tags. Also many
				attributes, such as <parameter>style</parameter>, should pass through the
				sanitization.
			</para>

			<!-- NOTE: Document the rude HTML sanitization method when #3382 is closed. -->
		</section>
	</section>

	<section xml:id="advanced.urifu">
		<title>URI Fragment and History Management with <classname>UriFragmentUtility</classname></title>

        <para>
            A major issue in AJAX applications is that as they run in a single web page,
            bookmarking the application URL (or more generally the
            <emphasis>URI</emphasis>) can only bookmark the application, not an
            application state. This is a problem for many applications such as product
            catalogs and forums, in which it would be good to provide links to specific
            products or messages. Consequently, as browsers remember the browsing history
            by URI, the history and the <guibutton>Back</guibutton> button do not normally
            work. The solution is to use the <emphasis>fragment</emphasis> part of the
            URI, which is separated from the primary part (address + path + optional query
            parameters) of the URI with the hash (#) character. For example:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[http://example.com/path#myfragment]]></programlisting>

        <para>
            The exact syntax of the fragment part is defined in RFC 3986 (Internet
            standard STD 66) that defines the URI syntax. A fragment may only contain the
            regular URI <emphasis>path characters</emphasis> (see the standard) and
            additionally the slash and the question mark.
        </para>

        <para>
            The <classname>UriFragmentUtility</classname> is a special-purpose component
            that manages the URI fragment; it allows setting the fragment and to handle
            user-made changes to it. As it is a regular component, though invisible, you
            must add it to a layout in an application window with the
            <methodname>addComponent()</methodname>, as usual.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    Window main = new Window("URI Fragment Example");
    setMainWindow(main);

    // Create the URI fragment utility
    final UriFragmentUtility urifu = new UriFragmentUtility();
    main.addComponent(urifu);]]></programlisting>

        <para>
            Notice that the utility component can work only when it is attached to the
            window, so in practice it must be added in the <methodname>init()</methodname>
            method of the application and must afterwards always remain in the
            application's user interface.
        </para>

        <para>
            You can set the URI fragment with the <methodname>setFragment()</methodname>
            method of the <classname>UriFragmentUtility</classname> object. The method takes the
            fragment as a string parameter. In the following example, we have a menu, from
            which the user can select the URI fragment.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Application state menu
final ListSelect menu = new ListSelect("Select a URI Fragment");
menu.addItem("mercury");
menu.addItem("venus");
menu.addItem("earth");
menu.addItem("mars");
menu.setImmediate(true);
main.addComponent(menu);

// Set the URI Fragment when menu selection changes
menu.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        String itemid = (String) event.getProperty().getValue();
        urifu.setFragment(itemid);
    }
});]]></programlisting>

        <para>
            The URI fragment and any changes to it are passed to an application as
            <classname>FragmentChangedEvent</classname>s, which you can handle with a
            <classname>FragmentChangedListener</classname>. You can get the new fragment
            value with the <methodname>getFragment()</methodname> method from the URI
            fragment utility component.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// When the URI fragment is given, use it to set menu selection 
urifu.addListener(new FragmentChangedListener() {
    public void fragmentChanged(FragmentChangedEvent source) {
        String fragment =
                  source.getUriFragmentUtility().getFragment();
        if (fragment != null)
            menu.setValue(fragment);
    }
});]]></programlisting>

        <para>
            <xref linkend="figure.advanced.urifu"/> shows an application that allows
            specifying the menu selection with a URI fragment and correspondingly sets the
            fragment when the user selects a menu item, as done in the code examples
            above.
        </para>

        <figure xml:id="figure.advanced.urifu">
            <title>Application State Management with URI Fragment Utility</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

    <section xml:id="advanced.httpservletrequestlistener">
        <title>Capturing HTTP Requests</title>

        <indexterm xml:id="term.advanced.httpservletrequestlistener" class="startofrange">
            <primary>HttpServletRequestListener</primary>
        </indexterm>

        <para>
            Behind the event-driven processing model of Vaadin lies the Java Servlet API,
            which is based on processing HTTP requests. These requests are normally
            hidden from Vaadin applications, but can be caught using the
            <classname>HttpServletRequestListener</classname> interface. You must
            implement the interface in your application class. The two methods defined in
            the interface, <methodname>onRequestStart()</methodname> and
            <methodname>onRequestEnd()</methodname>, allow processing the request before
            and after other processing.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.vaadin.Application;
import com.vaadin.terminal.gwt.server.HttpServletRequestListener;
import com.vaadin.ui.*;

public class HttpServletRequestApplication extends Application
       implements HttpServletRequestListener {

    @Override
    public void init() {
        System.out.println("  Application.init() called.");
        
        Window main = new Window("URI Fragment Example");
        setMainWindow(main);
        setTheme("book-examples");
                
        // Does nothing but causes a request
        Button button = new Button ("Make a request");
        main.addComponent(button);
    }

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        System.out.println("[Start of request");
        System.out.println(" Query string: " +
                           request.getQueryString());
        System.out.println(" Path: " +
                           request.getPathInfo());
    }

    public void onRequestEnd(HttpServletRequest request,
                             HttpServletResponse response) {
        System.out.println(" End of request]");
    }
}]]></programlisting>

        <para>
            The <methodname>onRequestStart()</methodname> is called for the first time
            when the application class is loaded but the <methodname>init()</methodname>
            is not yet called. This can be seen in the output of the above code example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[[Start of request
 Query string: null
 Path: null
  Application.init() called.
 End of request]
[Start of request
 Query string: repaintAll=1&sh=1050&sw=1680&cw=500&ch=300&vw=500
 Path: /UIDL/
 End of request]
[Start of request
 Query string: windowName=1071684214
 Path: /UIDL/
 End of request]]]></programlisting>

        <para>
            The first call is a regular HTML page load, so the URL path is simply the
            application path. The subsequent calls are AJAX calls made using the UIDL
            protocol, so the request path includes the <literal>/UIDL/</literal> part. This is
            important to know when using cookies, as explained later.
        </para>

        <section>
            <title>Using Request and Response Objects</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletrequest" class="startofrange">
                <primary>HttpServletRequest</primary>
            </indexterm>
            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletresponse" class="startofrange">
                <primary>HttpServletResponse</primary>
            </indexterm>
            
            <para>
                The <classname>HttpServletRequest</classname> object provides access to
                the request data, such as request headers, path info, and query string, as
                well as to some higher-level information such as cookies.
            </para>

            <para>
                The <classname>HttpServletResponse</classname> object is somewhat
                different, as most write operations write data directly to the output
                stream of the server request. It is therefore possible to add new headers
                and cookies in the <methodname>onRequestStart()</methodname>, and make
                other settings, but not later on, especially not in the
                <methodname>onRequestEnd()</methodname>, as all the UIDL response data has
                already been written to the output stream. The framework writes the UIDL
                response to the output stream of the response <emphasis>before</emphasis>
                calling <methodname>onRequestEnd()</methodname>. You therefore have to be
                careful when writing to the response object. You can usually write to it
                when handling component events in listeners, as is done in the cookie
                example later.
            </para>

            <para>
                While it is theoretically possible to redirect the output stream of the
                response object to write custom data to the response, you should never
                need to do that, as it would break the UIDL communication protocol.
            </para>
        
            <para>
                The servlet request and response objects are defined in the Java Servlet
                API. Please refer to its documentation for more detailed information.
            </para>

            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletrequest" class="endofrange"/>
            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletresponse" class="endofrange"/>
        </section>

        <section>
            <title>Managing Cookies</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.cookies" class="startofrange">
                <primary>cookies</primary>
            </indexterm>

            <para>
                Setting and reading cookies is one of the typical uses of
                <classname>HttpServletRequestListener</classname>. The application gets
                the <classname>HttpServletRequest</classname> object containing the
                cookies in the <methodname>onRequestStart()</methodname> method.
            </para>

            <section>
                <title>Setting a Cookie</title>

                <para>
                    You normally set a cookie in an event listener. As the request object
                    is a transient object that exists only for the duration of the
                    request, it is not accessible from the
                    <classname>Application</classname> object. The only way to access it
                    is to store it in <methodname>onRequestStart()</methodname>, as done
                    in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    HttpServletResponse response;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        // Store the reference to the response object for
        // using it in event listeners
        this.response = response;
        ...
   }
   ...]]></programlisting>

                <para>
                    We can then use the reference to set or delete cookies in event
                    listeners. Notice that the <emphasis>cookie path</emphasis> property
                    is automatically set to the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent calls
                    (such as <filename>/book-examples/cookies/UIDL</filename>). As the
                    cookies are matched against this path, you may need to set the path
                    explicitly with <methodname>setPath()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[newuser = new TextField ("Give a user name");
login = new Button("Login");
login.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        Object value = newuser.getValue(); 
        if (value != null &&
            ! "".equals((String)value)) {
            username = (String) value;

            Cookie cookie = new Cookie("username",
                                       username);
            // Use a fixed path
            cookie.setPath("/book-examples");
            cookie.setMaxAge(3600); // One hour
            response.addCookie(cookie);
            System.out.println("Set cookie.");

            newuser.setEnabled(false);
            login.setEnabled(false);
            restart.setEnabled(true);
            logout.setEnabled(true);
        }
    }
});
loginrow.addComponent(newuser);
loginrow.addComponent(login);]]></programlisting>

                <para>
                    Removing cookie can be set in similar way by setting the
                    <emphasis>maxAge</emphasis> property to zero.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Delete the cookie
Cookie cookie = new Cookie("username", username);
cookie.setPath("/book-examples");
cookie.setMaxAge(0); // Delete
response.addCookie(cookie);]]></programlisting>
            </section>

            <section>
                <title>Reading a Cookie</title>

                <para>
                    Reading a cookie can be done in the
                    <methodname>onRequestStart()</methodname> event. As this method is
                    called also on the first client request before the application is
                    initialized, it is possible to read user identification cookies and
                    such on the first request.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    String username;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        if (username == null) {
            Cookie[] cookies = request.getCookies();
            for (int i=0; i<cookies.length; i++) {
                if ("username".equals(cookies[i].getName()))
                    // Log the user in automatically
                    username = cookies[i].getValue();
            }
        }
    }
    ...]]></programlisting>

                <para>
                    Notice that the request path is the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent AJAX
                    calls (such as <filename>/book-examples/cookies/UIDL</filename>). So,
                    if you have set the cookie in an AJAX request without setting the
                    cookie path explicitly to such that does not contain the
                    <filename>UIDL</filename> subpath, the cookie will be filtered out on
                    the initial <methodname>onRequestStart()</methodname> call.
                </para>
            </section>

            <indexterm startref="term.advanced.httpservletrequestlistener.cookies" class="endofrange"/>
        </section>

        <indexterm startref="term.advanced.httpservletrequestlistener" class="endofrange"/>
    </section>

    <section xml:id="advanced.dragndrop">
        <title>Drag and Drop</title>

        <indexterm xml:id="term.advanced.dragndrop" class="startofrange">
            <primary>Drag and Drop</primary>
        </indexterm>

        <para>
            Dragging an object from one location to another by grabbing it with mouse,
            holding the mouse button pressed, and then releasing the button to "drop" it
            to the other location is a common way to move, copy, or associate objects. For
            example, most operating systems allow dragging and dropping files between
            folders or dragging a document on a program to open it. In Vaadin, it is
            possible to drag and drop components and parts of certain components.
        </para>

        <para>
            Dragged objects, or <emphasis>transferables</emphasis>, are essentially data
            objects. You can drag and drop rows in <classname>Table</classname> and nodes
            in <classname>Tree</classname> components, either within or between the
            components. You can also drag entire components by wrapping them inside
            <classname>DragAndDropWrapper</classname>.
        </para>

        <para>
            Dragging starts from a <emphasis>drag source</emphasis>, which defines the
            transferable. Transferables implement the <classname>Transferable</classname>
            interfaces. For trees and tables, which are bound to
            <classname>Container</classname> data sources, a node or row transferable is a
            reference to an <classname>Item</classname> in the Vaadin Data Model. Dragged
            components are referenced with a
            <classname>WrapperTransferable</classname>. Starting dragging does not require
            any client-server communication, you only need to enable dragging. All drag
            and drop logic occurs in two operations: determining
            (<emphasis>accepting</emphasis>) where dropping is allowed and actually
            dropping. Drops can be done on a <emphasis>drop target</emphasis>, which
            implements the <classname>DropTarget</classname> interface. Three components
            implement the interface: <classname>Tree</classname>,
            <classname>Table</classname>, and
            <classname>DragAndDropWrapper</classname>. These accept and drop operations
            need to be provided in a <emphasis>drop handler</emphasis>. Essentially all
            you need to do to enable drag and drop is to enable dragging in the drag
            source and implement the <methodname>getAcceptCriterion()</methodname> and
            <methodname>drop()</methodname> methods in the
            <classname>DropHandler</classname> interface.
        </para>

        <para>
            The client-server architecture of Vaadin causes special requirements for the
            drag and drop functionality. The logic for determining where a dragged object
            can be dropped, that is, <emphasis>accepting</emphasis> a drop, should
            normally be done on the client-side, in the browser. Server communications are
            too slow to have much of such logic on the server-side. The drag and drop
            feature therefore offers a number of ways to avoid the server communications
            to ensure a good user experience.
        </para>

        <section xml:id="advanced.dragndrop.drophandler">
            <title>Handling Drops</title>

            <para>
                Most of the user-defined drag and drop logic occurs in a <emphasis>drop
                handler</emphasis>, which is provided by implementing the
                <methodname>drop()</methodname> method in the
                <classname>DropHandler</classname> interface. A closely related definition
                is the drop accept criterion, which is defined in the
                <methodname>getAcceptCriterion()</methodname> method in the same
                interface. It is described in <xref
                linkend="advanced.dragndrop.acceptcriteria"/> later.
            </para>

            <para>
                The <methodname>drop()</methodname> method gets a
                <classname>DragAndDropEvent</classname> as its parameters. The event
                object provides references to two important object:
                <classname>Transferable</classname> and
                <classname>TargetDetails</classname>.
            </para>

            <para>
                A <classname>Transferable</classname> contains a reference to the object
                (component or data item) that is being dragged. A tree or table item is
                represented as a <classname>TreeTransferable</classname> or
                <classname>TableTransferable</classname> object, which carries the item
                identifier of the dragged tree or table item. These special transferables,
                which are bound to some data in a container, are
                <classname>DataBoundTransferable</classname>. Dragged components are
                represented as <classname>WrapperTransferable</classname> objects, as the
                components are wrapped in a <classname>DragAndDropWrapper</classname>.
            </para>

            <para>
                The <classname>TargetDetails</classname> object provides details
                regarding the exact location where the transferable object is being
                dropped. If the target is a tree or a table, the
                <classname>TreeTargetDetails</classname> and
                <classname>TableTargetDetails</classname> objects provide the tree or
                table item on which the drop is being made. For entire components, the
                information is provided in a <classname>WrapperDropDetails</classname>
                object. In addition to the target item or component, the details objects
                provide a <emphasis>drop location</emphasis>. For selection components,
                the location can be obtained with the
                <methodname>getDropLocation()</methodname> and for wrapped components with
                <methodname>verticalDropLocation()</methodname> and
                <methodname>horizontalDropLocation()</methodname>. The locations are
                specified as either <classname>VerticalDropLocation</classname> or
                <classname>HorizontalDropLocation</classname> objects. The drop location
                objects specify whether the transferable is being dropped above, below, or
                directly on (at the middle of) a component or item.
            </para>

            <para>
                Dropping on a <classname>Tree</classname>, <classname>Table</classname>,
                and a wrapped component is explained further in the following sections.
            </para>
        </section>

        <section xml:id="advanced.dragndrop.treedrop">
            <title>Dropping Items On a <classname>Tree</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Tree</classname>. Making tree a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Tree</classname>
                currently supports only one drag mode,
                <literal>TreeDragMode.NODE</literal>, which allows dragging single tree
                nodes. While dragging, the dragged node is referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. The tree node is identified
                by the item ID of the container item.
            </para>

            <para>
                When a transferable is dropped on a tree, the drop location is stored in a
                <classname>TreeTargetDetails</classname> object, which identifies the
                target location by item ID of the tree node on which the drop is made. You
                can get the item ID with <methodname>getItemIdOver()</methodname> method
                in <classname>AbstractSelectTargetDetails</classname>, which the
                <classname>TreeTargetDetails</classname> inherits. A drop can occur
                directly on or above or below a node; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method.
            </para>

            <para>
                In the example below, we have a <classname>Tree</classname> and we allow
                reordering the tree items by drag and drop.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final Tree tree = new Tree("Inventory");
tree.setContainerDataSource(TreeExample.createTreeContent());
layout.addComponent(tree);
        
// Expand all items
for (Iterator<?> it = tree.rootItemIds().iterator(); it.hasNext();)
    tree.expandItemsRecursively(it.next());
        
// Set the tree in drag source mode
tree.setDragMode(TreeDragMode.NODE);
        
// Allow the tree to receive drag drops and handle them
tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }

    public void drop(DragAndDropEvent event) {
        // Wrapper for the object that is dragged
        Transferable t = event.getTransferable();
        
        // Make sure the drag source is the same tree
        if (t.getSourceComponent() != tree)
            return;
        
        TreeTargetDetails target = (TreeTargetDetails)
            event.getTargetDetails();

        // Get ids of the dragged item and the target item
        Object sourceItemId = t.getData("itemId");
        Object targetItemId = target.getItemIdOver();

        // On which side of the target the item was dropped 
        VerticalDropLocation location = target.getDropLocation();
        
        HierarchicalContainer container = (HierarchicalContainer)
        tree.getContainerDataSource();

        // Drop right on an item -> make it a child
        if (location == VerticalDropLocation.MIDDLE)
            tree.setParent(sourceItemId, targetItemId);

        // Drop at the top of a subtree -> make it previous
        else if (location == VerticalDropLocation.TOP) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
            container.moveAfterSibling(targetItemId, sourceItemId);
        }
        
        // Drop below another item -> make it next 
        else if (location == VerticalDropLocation.BOTTOM) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
        }
    }
});]]></programlisting>

            <section>
                <title>Accept Criteria for Trees</title>

                <para>
                    <classname>Tree</classname> defines some specialized accept
                    criteria for trees.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TargetInSubtree</classname> (client-side)</term>
                        <listitem>
                            Accepts if the target item is in the specified sub-tree. The
                            sub-tree is specified by the item ID of the root of the
                            sub-tree in the constructor. The second constructor includes a
                            depth parameter, which specifies how deep from the given root
                            node are drops accepted. Value <literal>-1</literal> means
                            infinite, that is, the entire sub-tree, and is therefore the
                            same as the simpler constructor.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemAllowsChildren</classname> (client-side)</term>
                        <listitem>
                            Accepts a drop if the tree has
                            <methodname>setChildrenAllowed()</methodname> enabled for the
                            target item. The criterion does not require parameters, so the
                            class is a singleton and can be acquired with
                            <methodname>Tree.TargetItemAllowsChildren.get()</methodname>. For
                            example, the following composite criterion accepts drops only
                            on nodes that allow children, but between all nodes:

                            <programlisting><?pocket-size 65% ?><![CDATA[return new Or (Tree.TargetItemAllowsChildren.get(), new Not(VerticalLocationIs.MIDDLE));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TreeDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops on only some items, which as specified by a set
                            of item IDs. You must extend the abstract class and implement
                            the <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target nodes is loaded only once
                            from the server for each drag operation. See <xref
                            linkend="advanced.dragndrop.acceptcriteria"/> for an example.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, the accept criteria defined in
                    <classname>AbstractSelect</classname> are available for a
                    <classname>Tree</classname>, as listed in <xref
                    linkend="advanced.dragndrop.acceptcriteria"/>.
                </para>
            </section>
            
        </section>

        <section xml:id="advanced.dragndrop.tabledrop">
            <title>Dropping Items On a <classname>Table</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Table</classname>. Making table a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Table</classname>
                supports dragging both single rows, with
                <literal>TableDragMode.ROW</literal>, and multiple rows, with
                <literal>TableDragMode.MULTIROW</literal>. While dragging, the dragged
                node or nodes are referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. Tree nodes are identified by
                the item IDs of the container items.
            </para>

            <para>
                When a transferable is dropped on a table, the drop location is stored in
                a <classname>AbstractSelectTargetDetails</classname> object, which
                identifies the target row by its item ID. You can get the item ID with
                <methodname>getItemIdOver()</methodname> method. A drop can occur directly
                on or above or below a row; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method from the details object.
            </para>

            <section>
                <title>Accept Criteria for Tables</title>

                <para>
                    <classname>Table</classname> defines one specialized accept
                    criterion for tables.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TableDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops only on (or above or below) items that are
                            specified by a set of item IDs. You must extend the abstract
                            class and implement the
                            <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target items is loaded only once
                            from the server for each drag operation.
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="advanced.dragndrop.acceptcriteria">
            <title>Accepting Drops</title>

            <indexterm xml:id="term.advanced.dragndrop.acceptcriteria" class="startofrange">
                <primary>Drag and Drop</primary>
                <secondary>Accept Criteria</secondary>
            </indexterm>

            <para>
                You can not drop the objects you are dragging around just anywhere. Before
                a drop is possible, the specific drop location on which the mouse hovers
                must be <emphasis>accepted</emphasis>. Hovering a dragged object over an
                accepted location displays an <emphasis>accept indicator</emphasis>, which
                allows the user to position the drop properly. As such checks have to be
                done all the time when the mouse pointer moves around the drop targets, it
                is not feasible to send the accept requests to the server-side, so drops
                on a target are normally accepted by a client-side <emphasis>accept
                criterion</emphasis>.
            </para>

            <para>
                A drop handler must define the criterion on the objects which it accepts
                to be dropped on the target. The criterion needs to be provided in the
                <classname>getAcceptCriterion()</classname> method of the
                <classname>DropHandler</classname> interface. A criterion is represented
                in an <classname>AcceptCriterion</classname> object, which can be a
                composite of multiple criteria that are evaluated using logical
                operations. There are two basic types of criteria:
                <emphasis>client-side</emphasis> and <emphasis>server-side
                criteria</emphasis>. The various built-in criteria allow accepting drops
                based on the identity of the source and target components, and on the
                <emphasis>data flavor</emphasis> of the dragged objects.
            </para>

            <para>
                To allow dropping any transferable objects, you can return a universal
                accept criterion, which you can get with
                <methodname>AcceptAll.get()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    ...]]></programlisting>

            <section>
                <title>Client-Side Criteria</title>

                <para>
                    The <emphasis>client-side criteria</emphasis>, which inherit the
                    <classname>ClientSideCriterion</classname>, are verified on the
                    client-side, so server requests are not needed for verifying whether each
                    component on which the mouse pointer hovers would accept a certain object.
                </para>

                <para>
                    The following client-side criteria are define in
                    <package>com.vaadin.event.dd.acceptcriterion</package>:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptAll</classname></term>
                        <listitem>
                            Accepts all transferables and targets.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>And</classname></term>
                        <listitem>
                            Logical AND operation on two client-side criterion; accepts
                            the transferable if all the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>ContainsDataFlavour</classname></term>
                        <listitem>
                            The transferable must contain the defined
                            data flavour.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Not</classname></term>
                        <listitem>
                            Logical NOT operation on two client-side criterion; accepts
                            the transferable if and only if the sub-criterion does not
                            accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Or</classname></term>
                        <listitem>
                            Logical OR operation on two client-side criterion; accepts
                            the transferable if any of the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIs</classname></term>
                        <listitem>
                            Accepts all transferables from any of the given source
                            components
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIsTarget</classname></term>
                        <listitem>
                            Accepts the transferable only if the source component is the
                            same as the target. This criterion is useful for ensuring that
                            items are dragged only within a tree or a table, and not from
                            outside it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetDetailIs</classname></term>
                        <listitem>
                            Accepts any transferable if the target detail, such as the
                            item of a tree node or table row, is of the given data flavor
                            and has the given value.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, target components such as <classname>Tree</classname> and
                    <classname>Table</classname> define some component-specific
                    client-side accept criteria. See <xref
                    linkend="advanced.dragndrop.treedrop"/> for more details.
                </para>

                <para>
                    <classname>AbstractSelect</classname> defines the following criteria
                    for all selection components, including <classname>Tree</classname>
                    and <classname>Table</classname>.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptItem</classname></term>
                        <listitem>
                            Accepts only specific items from a specific selection
                            component. The selection component, which must inherit
                            <classname>AbstractSelect</classname>, is given as the first
                            parameter for the constructor. It is followed by a list of
                            allowed item identifiers in the drag source.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>AcceptItem.ALL</classname></term>
                        <listitem>
                            Accepts all transferables as long as they are items.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemIs</classname></term>
                        <listitem>
                            Accepts all drops on the specified target items. The
                            constructor requires the target component
                            (<classname>AbstractSelect</classname>) followed by a list of
                            allowed item identifiers.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>VerticalLocationIs.MIDDLE</classname>,
                        <classname>TOP</classname>, and
                        <classname>BOTTOM</classname></term>
                        <listitem>
                            The three static criteria accepts drops on, above, or below an
                            item. For example, you could accept drops only in between
                            items with the following:

                            <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    return new Not(VerticalLocationIs.MIDDLE);
}]]></programlisting>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section>
                <title>Server-Side Criteria</title>

                <para>
                    The <emphasis>server-side criteria</emphasis> are verified on the
                    server-side with the <methodname>accept()</methodname> method of the
                    <classname>ServerSideCriterion</classname> class. This allows fully
                    programmable logic for accepting drops, but the negative side is that
                    it causes a very large amount of server requests. A request is made
                    for every target position on which the pointer hovers. This problem is
                    eased in many cases by the component-specific lazy loading criteria
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname>. They do the server visit
                    once for each drag and drop operation and return all accepted rows or 
                    nodes for current <classname>Transferable</classname> at once.
                </para>

                <para>
                    The <methodname>accept()</methodname> method gets the drag event as a
                    parameter so it can perform its logic much like in
                    <methodname>drop()</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any other
    // location except on nodes that may not have children
    ServerSideCriterion criterion = new ServerSideCriterion() {
        public boolean accept(DragAndDropEvent dragEvent) {
            TreeTargetDetails target = (TreeTargetDetails)
                dragEvent.getTargetDetails();

            // The tree item on which the load hovers
            Object targetItemId = target.getItemIdOver();

            // On which side of the target the item is hovered
            VerticalDropLocation location = target.getDropLocation();
            if (location == VerticalDropLocation.MIDDLE)
                if (! tree.areChildrenAllowed(targetItemId))
                    return false; // Not accepted

            return true; // Accept everything else
        }
    };
    return criterion;
}]]></programlisting>
                
                <para>
                    The server-side criteria base class
                    <classname>ServerSideCriterion</classname> provides a generic
                    <methodname>accept()</methodname> method. The more specific
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname> are conveniency extensions
                    that allow definiting allowed drop targets as a set of items. They
                    also provide some optimization by lazy loading, which reduces server
                    communications significantly.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any
    // other tree node except on node that may not have children
    TreeDropCriterion criterion = new TreeDropCriterion() {
        @Override
        protected Set<Object> getAllowedItemIds(
                DragAndDropEvent dragEvent, Tree tree) {
            HashSet<Object> allowed = new HashSet<Object>();
            for (Iterator<Object> i =
                   tree.getItemIds().iterator(); i.hasNext();) {
                Object itemId = i.next();
                if (tree.hasChildren(itemId))
                    allowed.add(itemId);
            }
            return allowed;
        }
    };
    return criterion;
}]]></programlisting>

            </section>

            <section>
                <title>Accept Indicators</title>

                <para>
                    When a dragged object hovers on a drop target, an <emphasis>accept
                    indicator</emphasis> is displayed to show whether or not the location
                    is accepted. For <parameter>MIDDLE</parameter> location, the indicator
                    is a box around the target (tree node, table row, or component). For
                    vertical drop locations, the accepted locations are shown as
                    horizontal lines, and for horizontal drop locations as vertical lines.
                </para>

                <para>
                    For <classname>DragAndDropWrapper</classname> drop targets, you can
                    disable the accept indicators or <emphasis>drag hints</emphasis> with
                    the <parameter>no-vertical-drag-hints</parameter>,
                    <parameter>no-horizontal-drag-hints</parameter>, and
                    <parameter>no-box-drag-hints</parameter> styles. You need to add the
                    styles to the <emphasis>layout that contains</emphasis> the wrapper,
                    not to the wrapper itself.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a wrapper
DragAndDropWrapper wrapper = new DragAndDropWrapper(c);
layout.addComponent(wrapper);

// Disable the hints
layout.addStyleName("no-vertical-drag-hints");
layout.addStyleName("no-horizontal-drag-hints");
layout.addStyleName("no-box-drag-hints");]]></programlisting>

                <!-- TODO: Document also styles for the Tree and Table. -->
            </section>

            <indexterm startref="term.advanced.dragndrop.acceptcriteria" class="endofrange"/>
        </section>

        <section>
            <title>Dragging Components</title>

            <para>
                Dragging a component requires wrapping the source component within a
                <classname>DragAndDropWrapper</classname>. You can then allow dragging by
                putting the wrapper (and the component) in drag mode with
                <methodname>setDragStartMode()</methodname>. The method supports two drag
                modes: <parameter>DragStartMode.WRAPPER</parameter> and
                <parameter>DragStartMode.COMPONENT</parameter>, which defines whether the
                entire wrapper is shown as the drag image while dragging or just the
                wrapped component.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a component to drag
final Button button = new Button("An Absolute Button");

// Put the component in a D&D wrapper and allow dragging it
final DragAndDropWrapper buttonWrap = new DragAndDropWrapper(button);
buttonWrap.setDragStartMode(DragStartMode.COMPONENT);

// Set the wrapper to wrap tightly around the component
buttonWrap.setSizeUndefined();
        
// Add the wrapper, not the component, to the layout
layout.addComponent(buttonWrap, "left: 50px; top: 50px;");]]></programlisting>

            <para>
                The default height of <classname>DragAndDropWrapper</classname> is
                undefined, but the default width is 100%. If you want to ensure that the
                wrapper fits tightly around the wrapped component, you should call
                <methodname>setSizeUndefined()</methodname> for the wrapper. Doing so, you
                should make sure that the wrapped component does not have a relative size,
                which would cause a paradox.
            </para>

            <para>
                Dragged components are referenced in the
                <classname>WrapperTransferable</classname>. You can get the reference to
                the dragged component with
                <methodname>getDraggedComponent()</methodname>. The method will return
                <literal>null</literal> if the transferable is not a component. Also HTML
                5 drags (see later) are held in wrapper transferables.
            </para>

        </section>

        <section xml:id="advanced.dragndrop.drop-on-component">
            <title>Dropping on a Component</title>

            <para>
                Drops on a component are enabled by wrapping the component in a
                <classname>DragAndDropWrapper</classname>. The wrapper is an ordinary
                component; the constructor takes the wrapped component as a parameter. You
                just need to define the <classname>DropHandler</classname> for the wrapper
                with <methodname>setDropHandler()</methodname>.
            </para>

            <para>
                In the following example, we allow moving components in an absolute
                layout. Details on the drop handler are given later.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A layout that allows moving its contained components
// by dragging and dropping them
final AbsoluteLayout absLayout = new AbsoluteLayout();
absLayout.setWidth("100%");
absLayout.setHeight("400px");

... put some (wrapped) components in the layout ...

// Wrap the layout to allow handling drops
DragAndDropWrapper layoutWrapper =
        new DragAndDropWrapper(absLayout);

// Handle moving components within the AbsoluteLayout
layoutWrapper.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    
    public void drop(DragAndDropEvent event) {
        ...        
    }
});]]></programlisting>

            <section>
                <title>Target Details for Wrapped Components</title>

                <para>
                    The drop handler receives the drop target details in a
                    <classname>WrapperTargetDetails</classname> object, which implements
                    the <classname>TargetDetails</classname> interface.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public void drop(DragAndDropEvent event) {
    WrapperTransferable t =
        (WrapperTransferable) event.getTransferable();
    WrapperTargetDetails details =
        (WrapperTargetDetails) event.getTargetDetails();]]></programlisting>

                <para>
                    The wrapper target details include a
                    <classname>MouseEventDetails</classname> object, which you can get
                    with <methodname>getMouseEvent()</methodname>. You can use it to get
                    the mouse coordinates for the position where the mouse button was
                    released and the drag ended. Similarly, you can find out the drag
                    start position from the transferable object (if it is a
                    <classname>WrapperTransferable</classname>) with
                    <methodname>getMouseDownEvent()</methodname>.
                </para>
                
                <programlisting><?pocket-size 65% ?><![CDATA[// Calculate the drag coordinate difference
int xChange = details.getMouseEvent().getClientX()
              - t.getMouseDownEvent().getClientX();
int yChange = details.getMouseEvent().getClientY()
              - t.getMouseDownEvent().getClientY();

// Move the component in the absolute layout
ComponentPosition pos =
    absLayout.getPosition(t.getSourceComponent());
pos.setLeftValue(pos.getLeftValue() + xChange);
pos.setTopValue(pos.getTopValue() + yChange);]]></programlisting>

                <para>
                    You can get the absolute x and y coordinates of the target wrapper
                    with <methodname>getAbsoluteLeft()</methodname> and
                    <methodname>getAbsoluteTop()</methodname>, which allows you to
                    translate the absolute mouse coordinates to coordinates relative to
                    the wrapper. Notice that the coordinates are really the position of
                    the wrapper, not the wrapped component; the wrapper reserves some
                    space for the accept indicators.
                </para>

                <para>
                    The <methodname>verticalDropLocation()</methodname> and
                    <methodname>horizontalDropLocation()</methodname> return the more
                    detailed drop location in the target.
                </para>
            </section>
        </section>

        <section>
            <title>Dragging Files from Outside the Browser</title>
            
            <para>
                The <classname>DragAndDropWrapper</classname> allows dragging files from
                outside the browser and dropping them on a component wrapped in the
                wrapper. Dropped files are automatically uploaded to the application and
                can be acquired from the wrapper with
                <methodname>getFiles()</methodname>. The files are represented as
                <classname>Html5File</classname> objects as defined in the inner
                class. You can define an upload <classname>Receiver</classname> to receive
                the content of a file to an <classname>OutputStream</classname>.
            </para>

            <para>
                Dragging and dropping files to browser is supported in HTML 5 and
                requires a compatible browser, such as Mozilla Firefox 3.6 or newer.
            </para>
        </section>

        <indexterm startref="term.advanced.dragndrop" class="endofrange"/>
    </section>

    <section xml:id="advanced.logging">
        <title>Logging</title>

        <para>
            You can do logging in Vaadin application using the standard
            <package>java.util.logging</package> facilities. Configuring logging is as
            easy as putting a file named <filename>logging.properties</filename> in the
            default package of your Vaadin application. This file is read by the
            <classname>Logger</classname> class when a new instance of it is initialize.
        </para>

        <simplesect xml:id="advanced.logging.tomcat">
            <title>Logging in Apache Tomcat</title>

            <para>
                For logging Vaadin applications deployed in Apache Tomcat, you do not need
                to do anything special to log to the same place as Tomcat itself. If you
                need to write the Vaadin application related messages elsewhere, just add
                a custom <filename>logging.properties</filename> file to the default
                package of your Vaadin application.
            </para>

            <para>
                If you would like to pipe the log messages through another logging
                solution, see <xref linkend="advanced.logging.slf4j"/> below.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.liferay">
            <title>Logging in Liferay</title>

            <para>
                Liferay mutes logging through <package>java.util.logging</package> by
                default. In order to enable logging, you need to add a
                <filename>logging.properties</filename> file of your own to the default
                package of your Vaadin application. This file should define at least one
                destination where to save the log messages.
            </para>

            <para>
                You can also log through SLF4J, which is used in and bundled with
                Liferay. Follow the instructions in <xref
                linkend="advanced.logging.slf4j"/>.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.slf4j">
            <title>Piping to Log4j using SLF4J</title>

            <para>
                Piping output from <package>java.util.logging</package> to Log4j is easy
                with SLF4J (<link
                xlink:href="http://slf4j.org/">http://slf4j.org/</link>). The basic way to
                go about this is to add the SLF4J JAR file as well as the
                <filename>jul-to-slf4j.jar</filename> file, which implements the bridge
                from <package>java.util.logging</package>, to SLF4J. You will also need to
                add a third logging implementation JAR file, that is,
                <filename>slf4j-log4j12-x.x.x.jar</filename>, to log the actual messages
                using Log4j. For more info on this, please visit the SLF4J site.
            </para>

            <para>
                In order to get the <package>java.util.logging</package> to SLF4J
                bridge installed, you need to add the following snippet of code to your
                <classname>Application</classname> class at the very top:
            </para>

            <programlisting><![CDATA[  static {
    SLF4JBridgeHandler.install();
  }]]></programlisting>

            <para>
                This will make sure that the bridge handler is installed and working
                before Vaadin starts to process any logging calls.
            </para>

            <warning>
                <title>Please note!</title>

                <para>
                    This can seriously impact on the cost of disabled logging statements
                    (60-fold increase) and a measurable impact on enabled log statements
                    (20% overall increase). However, Vaadin doesn't log very much, so the
                    effect on performance will be negligible.
                </para>
            </warning>
        </simplesect>

        <simplesect xml:id="advanced.logging.core">
            <title>Logging in Vaadin core and add-ons</title>

            <para>
                The pattern for logging in the core of Vaadin and in server-side add-ons
                is that you register a static final logger for each class that does
                logging, and then just use this logger. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyClass {
  private static final Logger logger =
          Logger.getLogger(MyClass.class.getName());
  
  public void myMethod() {
    try {
      // do something that might fail
    } catch (Exception e) {
      logger.log(Level.SEVERE, "FAILED CATASTROPHICALLY!", e);
    } 
  }
}]]></programlisting>
        </simplesect>
    </section>

    <section xml:id="advanced.global">
        <title>Accessing Session-Global Data</title>

        <para>
            Applications typically need to access some objects from practically all user
            interface code, such as a user object, a business data model, or a database
            connection. This data is typically initialized and managed in the application
            class. Some such data is built-in into the <classname>Application</classname>
            class, such as the locale.
        </para>

        <para>
            You can access the application object from any user interface component using
            the <methodname>getApplication()</methodname> method. For example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyApplication extends Application {
    UserData userData;

    public void init() {
        userData = new UserData();
    }

    public UserData getUserData() {
        return userData;
    }
}

...
data = ((MyApplication)component.getApplication()).getUserData();]]></programlisting>

        <simplesect xml:id="advanced.global.passing.problem">
            <title>The Problem</title>

            <para>
                The basic problem in accessing session-global data is that the
                <methodname>getApplication()</methodname> method works only after the
                component has been attached to the application. Before that, it returns
                <parameter>null</parameter>. This is the case in constructors of
                components, such as a <classname>CustomComponent</classname>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // This fails with NullPointerException
        Label label = new Label("Country: " +
            getApplication().getLocale().getCountry());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                Using a static variable or a singleton implemented with such to give a
                global access to user session data is not possible, because static
                variables are global in the entire web application, not just the user
                session. This can be handy for communicating data between the concurrent
                sessions, but creates a problem within a session.
            </para>

            <para>
                For example, the following would not work:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyApplication extends Application {
    static UserData userData;

    public void init() {
        userData = new UserData();
    }

    public static UserData getUserData() {
        return userData;
    }
}]]></programlisting>

            <para>
                The data would be shared by all users and be reinitialized every time a
                new user opens the application.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.global.passing.solutions-overview">
            <title>Overview of Solutions</title>

            <para>
                To get the application object or any other global data, you have the
                following solutions:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Pass a reference to the global data as a parameter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Initialize components in <methodname>attach()</methodname> method.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Store a reference to global data using the <emphasis>ThreadLocal Pattern</emphasis>.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Each solution is described in the following sections.
            </para>
        </simplesect>

        <section xml:id="advanced.global.passing">
            <title>Passing References Around</title>

            <para>
                You can pass references to objects as parameters. This is the normal way
                in object-oriented programming.
            </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyApplication extends Application {
    UserData userData;

    public void init() {
        Window mainWindow = new Window("My Window");
        setMainWindow(mainWindow);

        userData = new UserData();
        
        mainWindow.addComponent(new MyComponent(this));
    }

    public UserData getUserData() {
        return userData;
    }
}

class MyComponent extends CustomComponent {
    public MyComponent(MyApplication app) {
        Label label = new Label("Name: " +
            app.getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                If you need the reference in other methods, you either have to pass it
                again as a parameter or store it in a member variable.
            </para>

            <para>
                The problem with this solution is that practically all constructors in the
                application need to get a reference to the application object, and passing
                it further around in the classes is another hard task.
            </para>
        </section>
        
        <section xml:id="advanced.global.attach">
            <title>Overriding <methodname>attach()</methodname></title>

            <para>
                The <methodname>attach()</methodname> method is called when the component
                is attached to the application component through containment
                hierarchy. The <methodname>getApplication()</methodname> method always
                works.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // Must set a dummy root in constructor
        setCompositionRoot(new Label(""));
    }

    @Override
    public void attach() {    
        Label label = new Label("Name: " +
            ((MyApplication)component.getApplication())
                .getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                While this solution works, it is slightly messy. You may need to do some
                initialization in the constructor, but any construction requiring the
                global data must be done in the <methodname>attach()</methodname> method.
                Especially, <classname>CustomComponent</classname> requires that the
                <methodname>setCompositionRoot()</methodname> method is called in the
                constructor. If you can't create the actual composition root component in
                the constructor, you need to use a temporary dummy root, as is done in the
                example above.
            </para>
            
            <para>
                Using <methodname>getApplication()</methodname> also needs casting if you
                want to use methods defined in your application class.
            </para>
        </section>
        
        <section xml:id="advanced.global.threadlocal">
            <title>ThreadLocal Pattern</title>

            <indexterm xml:id="term.advanced.global.threadlocal" class="startofrange"><primary>ThreadLocal pattern</primary></indexterm>

            <para>
                The ThreadLocal pattern gives a solution to the global access problem by
                solving two sub-problems.
            </para>

            <para>
                As the first problem, the servlet container processes requests for many
                users (sessions) sequentially, so if a static variable is set in a request
                belonging one user, it could be read or re-set by the next incoming
                request belonging to another user. This can be solved by setting the
                global reference at the beginning of each HTTP request to point to data of
                the current user, as illustrated in Figure <xref
                linkend="figure.advanced.global.threadlocal.sequentiality"
                xrefstyle="select:labelnumber"/>.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.sequentiality">
                <title>Switching a static (or ThreadLocal) reference during sequential
                processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-sequentiality-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-sequentiality-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can implement such switching either with the
                <classname>TransactionListener</classname> or
                <classname>HttpServletRequestListener</classname> interface by setting the
                reference in <methodname>transactionStart()</methodname> or
                <methodname>onRequestStart()</methodname>, respectively. We use the former
                interface in the example code in this section, as the latter interface has
                to be implemented in the application class.
            </para>

            <para>
                The second problem is that servlet containers typically do thread pooling
                with multiple worker threads that process requests. Therefore, setting a
                static reference would change it in all threads running concurrently,
                possibly just when another thread is processing a request for another
                user. The solution is to store the reference in a thread-local variable
                instead of a static. You can do so by using the
                <classname>ThreadLocal</classname> class in Java for the switch reference.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.concurrency">
                <title>Switching <classname>ThreadLocal</classname> references during
                concurrent processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-concurrency-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-concurrency-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Notice that if you use a <classname>TransactionListener</classname>, the
                listeners are attached to the web application context (in practice a user
                session), not the application instance. The problem is that an application
                context can have multiple different Vaadin applications that share the
                same user session. If two of these applications add a transaction listener
                to the context to listen for requests, both are called and without any
                checks they would both set the reference to themselves. Therefore, the
                application data object needs to know which application it belongs to and
                check that when the transaction begins and ends. Using the
                <classname>HttpServletRequestListener</classname> frees you from these
                checks.
            </para>

            <para>
                While you may not absolutely need to clear the reference in
                <methodname>transactionEnd()</methodname>, you are probably on the safer
                side if you do. Setting such unneeded references to
                <literal>null</literal> can help avoid memory leaks and it could also be a
                good security precaution not to leave a reference to session data so that
                it could be seen by another user session in the next request.
            </para>

            <para>
                We end up with the following code. As we put the application data to a
                class separate from the application class, we have to make it a
                <classname>TransactionListener</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** Holds data for one user session. */
public class AppData
       implements TransactionListener, Serializable {
    private ResourceBundle bundle;
    private Locale locale;   // Current locale
    private String userData; // Trivial data model for the user
    
    private Application app; // For distinguishing between apps

    private static ThreadLocal<AppData> instance =
        new ThreadLocal<AppData>();
    
    public AppData(Application app) {
        this.app = app;

        // It's usable from now on in the current request
        instance.set(this);
    }

    @Override
    public void transactionStart(Application application,
                                 Object transactionData) {
        // Set this data instance of this application
        // as the one active in the current thread. 
        if (this.app == application)
            instance.set(this);
    }

    @Override
    public void transactionEnd(Application application,
                               Object transactionData) {
        // Clear the reference to avoid potential problems
        if (this.app == application)
            instance.set(null);
    }

    public static void initLocale(Locale locale,
                                  String bundleName) {
        instance.get().locale = locale;
        instance.get().bundle =
            ResourceBundle.getBundle(bundleName, locale);
    }
    
    public static Locale getLocale() {
        return instance.get().locale;
    }

    public static String getMessage(String msgId) {
        return instance.get().bundle.getString(msgId);
    }

    public static String getUserData() {
        return instance.get().userData;
    }

    public static void setUserData(String userData) {
        instance.get().userData = userData;
    }
}]]></programlisting>

            <para>
                We can then use it in the application as follows. Observe that we do not
                have a reference to the application object in the constructor of the
                <classname>MyComponent</classname> class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** 
 * We can now nicely access the session-global data
 * in the constuctor of this class.
 */
class MyComponent extends CustomComponent {
    public MyComponent() {
        VerticalLayout layout = new VerticalLayout();
        
        // Get stuff from the application data object            
        layout.addComponent(new Label("Hello, " +
            AppData.getUserData()));

        layout.addComponent(new Label("Your locale is " +
            AppData.getLocale().getDisplayLanguage()));
        
        layout.addComponent(new Button(
            AppData.getMessage(MyAppCaptions.CancelKey)));
        
        setCompositionRoot(layout);
    }
}

/** The application class. */
public class ThreadLocalApplication extends Application {
    public void init() { 
        Window main = new Window("Hello window"); 
        setMainWindow(main);
        
        // Create the application data instance
        AppData sessionData = new AppData(this);
        
        // Register it as a listener in the application context
        getContext().addTransactionListener(sessionData);
        
        // Initialize the session-global data
        AppData.initLocale(getLocale(),
                           MyAppCaptions.class.getName());
        
        // Also set the user data model
        AppData.setUserData("Billy");
        
        // Now, we do not pass this application object
        // in the constructor, so it couldn't access the
        // app data otherwise.
        main.addComponent(new MyComponent());
    }
}]]></programlisting>

            <indexterm startref="term.advanced.global.threadlocal" class="endofrange"/>
        </section>
    </section>

    <!-- TODO
    <section xml:id="advanced.browserinfo">
        <title>Browser Information</title>

        <para>
            
        </para>

    </section> -->
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

