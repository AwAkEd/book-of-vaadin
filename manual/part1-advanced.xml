<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various advanced topics.
    </para>

	<section xml:id="application.windows">
		<title>Application-Level Windows</title>

		<para>
			Vaadin Release 5 introduces support for multiple application-level
			windows that can be used just like the main window. All such windows use the
			same application session. Each window is identified with a URL that is used to
			access it. This makes it possible to bookmark application-level windows. Such
			windows can even be created dynamically based on URLs.
		</para>

		<para>
			Application-level windows allow several uses important for the usability of
			browser-based applications.
		</para>

		<itemizedlist>
			<listitem>
				<emphasis>Native child windows</emphasis>. An application can open child
				windows that are not floating windows inside a parent window.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding windows</emphasis>. Windows can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="application.embedding"/>.
			</listitem>
		</itemizedlist>

		<para>
			Because of the special nature of AJAX applications, these uses require some
			caveats. We will go through them later in <xref
			linkend="application.windows.caveats"/>.
		</para>
		
		<section>
			<title>Creating New Application-Level Windows</title>

			<para>
				Creating a new application-level window is much like creating a child
				window (see <xref linkend="application.child-windows"/>), except that the
				window is added with <methodname>addWindow()</methodname> to the application
				object instead of the main window.
			</para>

			<programlisting><![CDATA[public class WindowTestApplication extends Application {
    public void init() {
        final Window main = new Window ("Window Test Application");
        setMainWindow(main);
         
        /* Create a new window. */
        final Window mywindow = new Window("Second Window");
        
        /* Manually set the name of the window. */
        mywindow.setName("mywindow");
        
        /* Add some content to the window. */
        mywindow.addComponent(new Label("This is a second window."));

        /* Add the window to the application. */
        addWindow(mywindow);
    }
}]]></programlisting>

			<para>
				This creates the window object that a user can view by opening a URL in
				a browser. Creating an application-level window object does not open a new
				browser window automatically to view the object, but if you wish to open
				one, you have to do it explicitly as shown below. An application-level
				window has a unique URL, which is based on the application URL and the
				name of the window given with the <methodname>setName()</methodname>
				method. For example, if the application URL is
				<uri>http://localhost:8080/myapp/</uri> and the window name is
				<literal>mywindow</literal>, the URL for the window will be
				<uri>http://localhost:8080/myapp/mywindow/</uri>. If the name of a window
				is not explicitly set with <methodname>setName()</methodname>, an
				automatically generated name will be used. The name can be retrieved with
				the <methodname>getName()</methodname> method and the entire URL with
				<methodname>getURL()</methodname>.
			</para>

			<para>
				There are three typical ways to open a new window: using the
				<methodname>open()</methodname> method of <classname>Window</classname>
				class, a <classname>Link</classname>, or referencing it from HTML or
				JavaScript code written inside a <classname>Label</classname> component.
			</para>

			<para>
				The <classname>Window</classname> <methodname>open()</methodname> method
				takes as parameters a resource to open and the target name. You can use
				<classname>ExternalResource</classname> to open a specific URL, which you
				get from the window to be opened with the
				<methodname>getURL()</methodname> method.
			</para>

			<programlisting><![CDATA[/* Create a button to open a new window. */
main.addComponent(new Button("Click to open new window",
                  new Button.ClickListener() { 
    public void buttonClick(ClickEvent event) {
        // Open the window.
        main.open(new ExternalResource(mywindow.getURL()), "_new");
    }      
}));]]></programlisting>

			<para>
				The target name is one of the default HTML target names (<parameter>_new</parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, etc.) or a custom target name.  How the window is
				exactly opened depends on the browser. Browsers that support tabbed
				browsing can open the window in another tab, depending on the browser
				settings.
			</para>

			<para>
				Another typical way to open windows is to use a <classname>Link</classname>
				component with the window URL as an
				<classname>ExternalResource</classname>.
			</para>

			<programlisting><![CDATA[/* Add a link to the second window. */
Link link = new Link("Click to open second window",
                     new ExternalResource(mywindow.getURL()));
link.setTargetName("second");
link.setTargetHeight(300);
link.setTargetWidth(300);
link.setTargetBorder(Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);]]></programlisting>

			<para>
				Using a <classname>Link</classname> allows you to specify parameters for
				the window that opens by clicking on the link. Above, we set the
				dimensions of the window and specify what window controls the window
				should contain. The <parameter>Link.TARGET_BORDER_DEFAULT</parameter>
				specifies to use the default, which includes most of the usual window
				controls, such as the menu, the toolbar, and the status bar.
			</para>

			<para>
				Another way to allow the user to open a window is to insert the URL in
				HTML code inside a <classname>Label</classname>. This allows even more
				flexibility in specifying how the window should be opened.
			</para>

			<programlisting><![CDATA[/* Add the link manually inside a Label. */
main.addComponent(new Label("Second window: <a href='"
                            +mywindow.getURL()+"' target='second'>click to open</a>",
                  Label.CONTENT_XHTML));
main.addComponent(new Label("The second window can be accessed through URL: "
                            +mywindow.getURL()));]]></programlisting>

			<para>
				When an application-level window is closed in the browser the
				<methodname>close()</methodname> method is normally called just like
				for a child window and the <classname>Window</classname> object is
				purged from the application. However, there are situations where
				<methodname>close()</methodname> might not be called. See
				<xref linkend="application.windows.closing"/> for more information. 
			</para>

		</section>

		<section xml:id="application.windows.dynamic">
			<title>Creating Windows Dynamically</title>
			
			<para>
				You can create a window object dynamically by its URL path by overriding
				the <methodname>getWindow()</methodname> method of the
				<classname>Application</classname> class. The method gets a window name as
				its parameter and must return the corresponding
				<classname>Window</classname> object. The window name is determined from
				the first URL path element after the application URL (window name may not
				contain slashes). See the notes below for setting the actual name of the
				dynamically created windows below.
			</para>

			<para>
				The following example allows opening windows with a window name that
				begins with "<literal>planet-</literal>" prefix. Since the method is
				called for <emphasis>every</emphasis> browser request for the application,
				we filter only the requests where a window with the given name does not
				yet exist.
			</para>

			<programlisting><![CDATA[public class WindowTestApplication extends Application {
    ...

    @Override
    public Window getWindow(String name) {
        // If a dynamically created window is requested, but it does
        // not exist yet, create it.
        if (name.startsWith("planet-") &&
              super.getWindow(name) == null) {
            String planetName = name.substring("planet-".length());

            // Create the window object.
            Window newWindow = new Window("Window about " + planetName);
            
            // DANGEROUS: Set the name explicitly. Otherwise, an
            // automatically generated name is used, which is usually safer.
            newWindow.setName(name);

            // Put some content in it.
            newWindow.addComponent(new Label("This window contains details about " +
                                             planetName + "."));
            
            // Add it to the application as a regular application-level window.
            addWindow(newWindow);
            
            return newWindow;
        }

        // Otherwise the Application object manages existing windows by their name.
        return super.getWindow(name);
    }]]></programlisting>

			<para>
				The window name is and must be a unique indentifier for each
				<classname>Window</classname> object instance. If you use
				<methodname>setName()</methodname> to set the window name explicitly, as
				we did above, any browser window that has the same URL (within the same
				browser) would open the <emphasis>same</emphasis> window object. This is
				dangerous and <emphasis>generally not recommended</emphasis>, because the
				browser windows would share the same window object. Opening two windows
				with the same static name would immediately lead to a synchronization
				error, as is shown in <xref
				linkend="figure.application.window.dynamic.error"/> below. (While also the
				window captions are same, they are irrelevant for this problem.)
			</para>

			<figure xml:id="figure.application.window.dynamic.error">
				<title>Synchronization Error Between Windows with the Same Name</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				There are some cases where setting the name explicitly is useful. The
				launch application below is one example, as it always opens the other
				windows in a window target that is specific to the window name, thereby
				never creating two windows with the same URL. Similarly, if you had
				embedded the application in a browser frame and the link would open the
				window in a frame, you would not have problems. Having a single window
				instance for a URL is also useful if the browser crashes and the user
				opens the window again, as it will have kept its previous (server-side)
				state.
			</para>

			<para>
				Leaving the window name to be automatically generated allows opening
				multiple windows with the same URL, while each of the windows will have a
				separate state. The URL in the location bar stays unchanged and the
				generated window name is used only for the Ajax communications to identify
				the window object. A generated name is a string representation of a unique
				random number, such as "<literal>1928676448</literal>". You should be
				aware of the generated window names when overriding the
				<methodname>getWindow()</methodname> method (and not unintentionally
				create a new window instance dynamically for each such request). The
				condition in the above example would also filter out the requests for an
				already existing window with a generated name.
			</para>

			<para>
				<xref linkend="figure.application.window.dynamic.new"/> shows a
				dynamically created application-level window with the URL shown in the
				address bar. The URL for the application is here
				<uri>http://localhost:8080/tk5/windowexample/</uri>, including the
				application context, and the dynamically created window's name is
				<uri>planet-mars</uri>.
			</para>

			<figure xml:id="figure.application.window.dynamic.new">
				<title>A Dynamically Created Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The application knows the windows it already has and can return them after
				the creation. The application also handles closing and destruction of
				application-level window objects, as discussed in <xref
				linkend="application.windows.closing"/>.
			</para>

			<para>
				Such dynamic windows could be opened as in the following example:
			</para>
			
			<programlisting><![CDATA[    public void init() {
        final Window main = new Window("Window Test Application");
        setMainWindow(main);

        // Have some IDs for the dynamically creatable windows.
        final String[] items = new String[] { "mercury", "venus", "earth",
                "mars", "jupiter", "saturn", "uranus", "neptune" };
        
        // Create a list of links to each of the available window.
        for (int i = 0; i < items.length; i++) {
            // Create a URL for the window.
            String windowUrl = getURL() + "planet-" + items[i];
            
            // Create a link to the window URL.
            // Using the item ID for the target also opens it in a new
            // browser window (or tab) unique to the window name.
            main.addComponent(new Link("Open window about " + items[i],
                                       new ExternalResource(windowUrl),
                                       items[i], -1, -1, Window.BORDER_DEFAULT));
        }
    }]]></programlisting>
        			
			<figure xml:id="figure.application.window.dynamic.main">
				<title>Opening Windows</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="application.windows.closing">
			<title>Closing Windows</title>

			<para>
				When the user closes an application-level window, the Client-Side Engine
				running in the browser will report the event to the server before the page
				is actually removed. You can catch the event with a
				<classname>Window.CloseListener</classname>, as is done in the example
				below.
			</para>

			<programlisting><![CDATA[
            newWindow.addListener(new Window.CloseListener() {
                @Override
                public void windowClose(CloseEvent e) {
                    // Do something.
                    System.out.println(e.getWindow().getName() + " was closed");
                    
                    // Add a text to the main window about closing. (This does
                    // not update the main window.)
                    getMainWindow().addComponent(
                        new Label("Window '" + e.getWindow().getName() +
                                  "' was closed."));
                }
            });]]></programlisting>

			<para>
				Notice that the change to the server-side state of the main window (or
				another application-level window) does not refresh the window in the
				browser, so the change will be unseen until user interaction or polling
				refreshes the window. This problem and its dangers are discussed in <xref
				linkend="application.windows.caveats"/> below.
			</para>

			<para>
				The close event does not occur if the browser crashes or the connection
				is otherwise severed violently. In such a situation, the window object will
				be left hanging, which could become a resource problem if you allow the
				users to open many such application-level windows. The positive side is
				that the user can reconnect to the window using the window URL.
			</para>
		</section>

		<section xml:id="application.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
					For cases where you need communication between windows, we recommend
					using floating child windows. In Vaadin Release 5, an
					application window can not update the data in other windows. The
					contents of a window can only be updated when the particular window makes
					a request to the server. The request can be caused by user input or
					through polling.
				</para>

				<para>
					Changing the server-side state of a window while processing a user event
					from another window can potentially cause serious problems. Changing
					the client-side state of a window does not always immediately
					communicate the changes to the server. The server-side state can therefore
					be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.window.polling">
					<title>Communication Between Two Application-Level Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					The following example creates a second window that changes the
					contents of the main window, as illustrated in the figure above. In
					this simple case, changing the main window contents is safe.
				</para>

				<programlisting><![CDATA[// Create a table in the main window to hold items added in the second window
final Table table = new Table();
table.setPageLength(5);
table.getSize().setWidth(100, Size.UNITS_PERCENTAGE);
table.addContainerProperty("Name", String.class, "");
main.addComponent(table);

// Create the second window
final Window adderWindow = new Window("Add Items");
adderWindow.setName("win-adder");
main.getApplication().addWindow(adderWindow);

// Create selection component to add items to the table
final NativeSelect select = new NativeSelect("Select item to add");
select.setImmediate(true);
adderWindow.addComponent(select);

// Add some items to the selection
String items[] = new String[]{"-- Select --", "Mercury", "Venus", 
        "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int i=0; i<items.length; i++)
    select.addItem(items[i]);
select.setNullSelectionItemId(items[0]);

// When an item is selected in the second window, add
// table in the main window
select.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // If the selected value is something else but null selection item.
        if (select.getValue() != null) {
            // Add the selected item to the table in the main window
            table.addItem(new Object[]{select.getValue()}, new Integer(table.size()));
        }
    }
});

// Link to open the selection window
Link link = new Link("Click to open second window",
                     new ExternalResource(adderWindow.getURL()),
                     "_new", 50, 200, Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);

// Enable polling to update the main window
ProgressIndicator poller = new ProgressIndicator();
poller.addStyleName("invisible");
main.addComponent(poller);]]></programlisting>

				<para>
					The example uses an invisible <classname>ProgressIndicator</classname>
					to implement polling. This is sort of a trick and a more proper API
					for polling is under design. Making the progress indicator invisible
					requires the following CSS style definition:
				</para>

				<programlisting><![CDATA[.i-progressindicator-invisible {
	display: none;
}]]></programlisting>


			</section>
		</section>
	</section>

	<section xml:id="application.embedding">
		<title>Embedding Applications in Web Pages</title>

		<para>
			Many web applications and especially web sites are not all AJAX, but AJAX is
			used only for specific functionalities. In practice, many web applications are
			a mixture of dynamic web pages and AJAX applications embedded to such
			pages.
		</para>

		<para>
			Embedding Vaadin applications is easy. There are two basic ways to
			embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the web application and load the Vaadin Client-Side Engine with a
			simple JavaScript code. The second method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element.  Both of these methods have
			advantages and disadvantages. The <literal>&lt;div&gt;</literal> method can
			only embed one application in a page, while the
			<literal>&lt;iframe&gt;</literal> method can embed as many as needed. One
			disadvantage of the <literal>&lt;iframe&gt;</literal> method is that the size
			of the <literal>&lt;iframe&gt;</literal> element is not flexible according to
			the content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods.
		</para>

		<section>
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<!-- OUTDATED? Check that this is current. -->

			<para><emphasis>The loading code for the Client-Side Engine has changed in
			Vaadin version 5.1.2 and the explanation below is no longer compatible with
			5.1.2 and later versions. Please view the source code of the initial page of
			your application in your browser or see the
			<filename>WebContent/multiapp.html</filename> for an
			example.</emphasis></para>

			<para>
				You can embed an Vaadin application inside a web page with a
				method that is equivalent to loading the initial page content from the
				application servlet in a non-embedded application. Normally, the
				<classname>ApplicationServlet</classname> servlet generates an initial
				page that contains the correct parameters for the specific
				application. You can easily configure it to load multiple Vaadin
				applications on the same page, assuming that they use the same widget set.
			</para>

			<para>
				 You can view the initial page for your application easily simply by
				 opening the application in a web browser and viewing the HTML source
				 code. You could just copy and paste the embedding code from the default
				 initial page. It has, however, some extra functionality that is not
				 normally needed: it generates some of the script content with
				 <methodname>document.write()</methodname> calls, which is useful only
				 when you are running the application as a portlet in a portal. The method
				 outlined below is much simpler.
			</para>

			<para>
				The <filename>WebContent/multiapp.html</filename> file included in the
				Vaadin installation package provides an example of embedding (multiple)
				Vaadin applications in a page. After launching the demo application, you
				can view the example at URL
				<uri>http://localhost:8888/multiapp.html</uri>. Notice that the example
				assumes the use of root context for the applications
				(<parameter>/</parameter>).
			</para>

			<!-- figure xml:id="figure.embedding.source">
				<title>Source Code of an Initial Page</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
				</mediaobject>
			</figure -->

			<para>
				Embedding requires four elements inside the HTML document:
			</para>

			<orderedlist>
				<listitem>
					<para>
						In the <literal>&lt;head&gt;</literal> element, you need to define
						the application URI and parameters and load the Vaadin
						Client-Side Engine. The <varname>itmill</varname> variable is an
						associative map that can contain various runtime data used by the
						Client-Side Engine of Vaadin. The
						<varname>vaadinConfigurations</varname> item is itself an
						associate map that contains parameters for each of the
						applications embedded in the page. The map must contain the
						following items:
					</para>

					<table>
						<title>vaadinConfigurations parameters</title>
						<tgroup cols="2" align="left">
							<tbody>
								<row valign="top">
									<entry><classname>appUri</classname></entry>
									<entry>The application URI consists of the context and
									the application path. If the context is
									<literal>/mycontext</literal> and the application path
									is <literal>myapp</literal>, the
									<parameter>appUri</parameter> would be
									<literal>/mycontext/myapp</literal>. The
									<filename>multiapp.html</filename> example assumes the
									use of root context, which is used in the demo
									application.</entry>
								</row>
								<row valign="top">
									<entry><classname>pathInfo</classname></entry>
									<entry>The <parameter>PATHINFO</parameter> parameter
									for the Servlet.</entry>
								</row>
								<row valign="top">
									<entry><classname>themeUri</classname></entry>
									<entry>URI of the application theme. The URI must
									include application context and the path to the theme
									directory. Themes are, by default, stored under the
									<filename>/ITMILL/themes/</filename> path.</entry>
								</row>
								<row valign="top">
									<entry><classname>versionInfo</classname></entry>
									<entry>This item is itself an associative map that
									contains two parameters:
									<parameter>vaadinVersion</parameter> contains the
									version number of the Vaadin version used by
									the application. The
									<parameter>applicationVersion</parameter> parameter
									contains the version of the particular
									application.</entry>
								</row>
							</tbody>
						</tgroup>
					</table>

					<para>
						The following example defines two applications to run in the same
						window: the Calculator and Hello World examples. In the example,
						the application context is <literal>/tk5</literal>.
					</para>

					<programlisting>&lt;script type="text/javascript"&gt;
    var itmill = {
        vaadinConfigurations: {
            '<emphasis role="bold">calc</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/Calc</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/ITMILL/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            },
            '<emphasis role="bold">hello</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/HelloWorld</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/ITMILL/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            }
        }};
&lt;/script&gt;</programlisting>
				</listitem>

				<listitem>
					<para>
						Loading the Vaadin Client-Side Engine is done with the
						following kind of line in the <literal>&lt;head&gt;</literal>
						element:
					</para>

					<programlisting>&lt;script language='javascript'
    src='/<emphasis>vaadin-examples</emphasis>/ITMILL/widgetsets/com.itmill.toolk
it.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWi
dgetSet.nocache.js'&gt;&lt;/script&gt;</programlisting>

					<para>
						The engine URI consists of the context of the web application,
						<literal>vaadin-examples</literal> above, followed by the path
						to the JavaScript (<filename>.js</filename>) file of the widget
						set, relative to the <filename>WebContent</filename>
						directory. The file contains the Client-Side Engine compiled for
						the particular widget set. The line above assumes the use of the
						default widget set of Vaadin. If you have made custom
						widgets that are defined in a custom widget set, you need to use
						the path to the compiled widget set file. Widget sets must be
						compiled under the
						<filename>WebContent/ITMILL/widgetsets</filename> directory.
					</para>

				</listitem>
				<listitem>
					<para>
						In the <literal>&lt;html&gt;</literal> element, you need to do a
						routine inclusion of GWT history <literal>iframe</literal>
						element as follows:
					</para>

					<programlisting>&lt;iframe id="__gwt_historyFrame" style="width:0;height:0;border:0"&gt;&lt;/iframe&gt;</programlisting>

				</listitem>
				<listitem>
					<para>
						The location of the Vaadin application is defined with a
						<literal>div</literal> placeholder element having
						<literal>id="itmill-ajax-window"</literal> as follows:
					</para>

					<programlisting>&lt;div id="itmill-ajax-window"/&gt;</programlisting>
				</listitem>
			</orderedlist>

			<para>
				Below is a complete example of embedding an application. It works
				out-of-the-box with the <application>Calculator</application> demo
				application.
			</para>

			<programlisting><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding Example</title>

    <!-- Set parameters for the Vaadin Client-Side Engine. -->
    <script type="text/javascript">
	    var itmill = {appUri:'Calc', pathInfo: '/'};
    </script>
    
    <!-- Load the Vaadin Client-Side Engine. -->
    <script language='javascript' src='/vaadin-examples/ITMILL/widgetse
ts/com.vaadin.terminal.gwt.DefaultWidgetSet/com.itmill.toolkit.terminal
.gwt.DefaultWidgetSet.nocache.js'></script>

    <!-- We can stylize the web application. -->
    <style>
        #itmill-ajax-window {background: #c0c0ff;}
        .i-button {background: pink;}
    </style>
  </head>

  <body>
    <!-- This <iframe> element is required by GWT. -->
    <iframe id="__gwt_historyFrame" style="width:0;height:0;border:0"></iframe>
    
    <h1>This is a HTML page</h1>
	<p>Below is the Vaadin application inside a table:</p>
	<table align="center" border="3" style="background: yellow;">
	  <tr><th>The Calculator</th></tr>
	  <tr>
	    <td>
          <!-- Placeholder <div> for the Vaadin application -->
          <div id="itmill-ajax-window"/>
        </td>
      </tr>
    </table>	
  </body>
</html>]]></programlisting>

			<para>
				The page will look as follows:
			</para>

			<figure xml:id="figure.embedding.div">
				<title>Embedded Application</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can style the web application with themes as described in <xref
				linkend="themes"/>. The Client-Side Engine loads the style sheets
				required by the application. In addition, you can do styling in the
				embedding page, as was done in the example above.
			</para>

			<para>
				The <application>Reservation Demo</application> and <application>Windowed
				Demos</application> provide similar examples of embedding an application
				in a web page. The embedding web pages are
				<filename>WebContent/reservr.html</filename> and
				<filename>WebContent/windoweddemos.html</filename>, respectively.
			</para>

			<para>
				The disadvantage of this embedding method is that there can only be one
				web application embedded in a page. One is usually enough, but if it is
				not, you need to use the <literal>&lt;iframe&gt;</literal> method below.
			</para>

		</section>

		<section>
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding an Vaadin application inside an
				<literal>&lt;iframe&gt;</literal> element is even easier than the method
				described above, as it does not require definition of any Vaadin specific
				definitions. The use of <literal>&lt;iframe&gt;</literal> makes it
				possible to embed multiple web applications or two different views to the
				same application on the same page.
			</para>

			<para>
				You can embed an application with an element such as the following:
			</para>

			<programlisting><![CDATA[<iframe src="/vaadin-examples/Calc"></iframe>]]></programlisting>

			<para>
				The problem with <literal>&lt;iframe&gt;</literal> elements is that their
				size of is not flexible depending on the content of the frame, but the
				content must be flexible to accommodate in the frame. You can set the size
				of an <literal>&lt;iframe&gt;</literal> element with
				<literal>height</literal> and <literal>width</literal> attributes.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker" height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="advanced.debug-production-modes">
		<title>Debug and Production Mode</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug
			mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode,
			which is on by default, enables a number of built-in debug features for the
			developers. The features include:
		</para>

		<itemizedlist>
			<listitem>Debug Window for accessing debug functionalities</listitem>
			<listitem>Display debug information in the Debug Window and server console.</listitem>
			<listitem><guibutton>Analyze layouting</guibutton> button that analyzes the layout for possible problems.</listitem>
		</itemizedlist>

		<para>
			Starting from Vaadin version 5.3.0, all applications are by default
			run in the debug mode. The production mode can be enabled (and debug mode
			thereby disabled) by adding a <parameter>productionMode=true</parameter>
			parameter to the servlet context in the <filename>web.xml</filename> deployment
			descriptor:
		</para>

		<programlisting><![CDATA[<context-param>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
  <description>Vaadin production mode</description>
</context-param>]]></programlisting>
		
		<para>
			Enabling the production mode disables the debug features, thereby preventing
			users from easily inspecting the inner workings of the application from the
			browser.
		</para>
		
		<section xml:id="advanced.debug-production-modes.debug.mode">
			<title>Debug Mode</title>
			
			<para>
				Running an application in the debug mode enables the client-side Debug
				Window in the browser. You can open the Debug Window by adding
				"<uri>?debug</uri>" to the application URL, e.g.,
				<uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in
				<xref linkend='figure.debug.window'/>, consists of buttons controlling the
				debugging features and a scrollable log of debug messages.
			</para>

			<figure id="figure.debug.window">
				<title>Debug Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<variablelist>
				<varlistentry>
					<term><guibutton>Clear console</guibutton></term>
					<listitem>
						Clears the log in the Debug Window.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Restart app</guibutton></term>
					<listitem>
						Restarts the application.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Force layout</guibutton></term>
					<listitem>
						Causes all currently visible layouts to recalculate their
						appearance. Layout components in Vaadin 5.3.0 and later
						calculate the space required by all child components, so the
						layout appearance must be recalculated whenever the size of a
						child component is changed. In normal applications, this is done
						automatically, but when you do themeing or alter the CSS with
						Firebug, you may need to force all layouts to recalculate
						themselves, taking into account the recently made changes.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Analyze layouts</guibutton></term>
					<listitem>
						This is described in the following section.
					</listitem>
				</varlistentry>
			</variablelist>

			<para>
				If you use the Firebug plugin in Mozilla Firefox, the log messages will
				also be printed to the Firebug console. In such a case, you may want to
				enable client-side debugging without showing the Debug Window with
				"<uri>?debug=quiet</uri>" in the URL. In the quiet debug mode, log
				messages will only be printed to the Firebug console.
			</para>
		</section>

 		<section>
			<title>Analyzing Layouts</title>
			<para>
				The <guilabel>Analyze layouts</guilabel> button analyzes the currently
				visible layouts and makes a report of possible layout related
				problems. All detected layout problems are displayed in the log and also
				printed to the console.
			</para>

			<para>
				The most common layout problem is caused by placing a component that has a
				relative size inside a container (layout) that has undefined size, e.g.,
				adding a 100% wide <classname>Panel</classname> inside a
				<classname>HorizontalLayout</classname> with no width specification. In
				such a case, the error will look as shown below:
			</para>

			<programlisting><![CDATA[Vaadin DEBUG
- Window/1a8bd74 "My window" (width: MAIN WINDOW)
  - HorizontalLayout/1cf243b (width: UNDEFINED)
    - Panel/12e43f1 "My panel" (width: RELATIVE, 100.0 %)
Layout problem detected: Component with relative width inside a HorizontalLayout with no width defined
Relative sizes were replaced by undefined sizes, components may not render as expected.]]>
			</programlisting>
			
			<para>
				This particular error tells that the <classname>Panel</classname> "My
				panel" is 100% wide while the width of the containing
				<classname>HorizontalLayout</classname> is undefined. The components will
				be rendered as if the the width of the contained
				<classname>Panel</classname> was undefined, which might not be what the
				developer wanted. There are two possible fixes for this case: if the
				<classname>Panel</classname> should fill the main window horizontally, set
				a width for the <classname>HorizontalLayout</classname> (e.g. 100% wide),
				or set the width of the <classname>Panel</classname> to "undefined" to
				render the it as it is currently rendered but avoiding the warning
				message.
			</para>

			<para>
				The same error is shown in the Debug Window in a slightly different form
				and with an additional feature (see <xref
				linkend='figure.debug-window.analyze-layouts'/>). Checking the
				<guilabel>Emphasize component in UI</guilabel> box will turn red the
				background of the component that caused a warning, making it easy for
				the developer to figure out which component each warning relates to. The
				messages will also be displayed hierarchically, as a warning from a
				containing component often causes more warnings from its child
				components. A good rule of thumb is to work on the upper-level problems
				first and only after that worry about the warnings from the children.
			</para>
			
			<figure id="figure.debug-window.analyze-layouts">
				<title>Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
				</mediaobject>
			</figure>
						
		</section>

		<section>
			<title>Custom Layouts</title>

			<para>
				<classname>CustomLayout</classname> components can not be analyzed in the
				same way as other layouts. For custom layouts, the <guibutton>Analyze
				layouts</guibutton> button analyzes all contained relative-sized
				components and checks if any relative dimension is calculated to zero so
				that the component will be invisible. The error log will display a warning
				for each of these invisible components. It would not be meaningful to
				emphasize the component itself as it is not visible, so when you select
				such an error, the parent layout of the component is emphasized if
				possible.
			</para>

		</section>

		<section>
			<title>Debug Functions for Component Developers</title>

			<para>
				You can take advantage of the debug mode when developing client-side
				components. The static function
				<methodname>ApplicationConnection.getConsole()</methodname> will return a
				reference to a <classname>Console</classname> object which contains
				logging methods such as <methodname>log(String msg)</methodname> and
				<methodname>error(String msg)</methodname>.  These functions will print
				messages to the Debug Window and Firebug console in the same way as other
				debugging functionalities of Vaadin do. No messages will be
				printed if the Debug Window is not open or if the application is running
				in production mode.
			</para>
		</section>
	</section>

	<section xml:id="advanced.application.pages">
		<title>Special Characteristics of AJAX Applications</title>
		
		<para>
			This section is intended for people familiar with the development of
			either traditional web applications or desktop applications, who are
			entering AJAX enabled web application development. AJAX application
			development has a few special characteristics with respect to other
			types of applications. Possibly the most important one is how the
			display is managed in the web browser.
		</para>

		<para>
			The web was originally not built for applications, but for hypertext
			pages that you can view with a browser. The purpose of web pages is
			to provide <emphasis>content</emphasis> for the user. Application
			software has a somewhat different purpose; usually to allow you to
			work on some data or content, much of which is not ever intended to
			be accessible through a web browser as web pages. As the web is
			inherently page-based, conventional web applications had to work with
			page requests and output HTML as response. JavaScript and AJAX have
			made it possible to let go of the pages.
		</para>

		<para>
			Pages are largely an unknown concept to conventional desktop
			applications. At most, desktop applications can open multiple
			windows, but usually they work with a single main window, with an
			occasional dialog window here and there. Same goes usually for web
			applications developed with Vaadin: an application typically
			runs on a single page, changing the layout as needed and popping up
			dialog boxes.
		</para>

		<para>
			Not having to load pages and use hyperlinks to communicate all user
			interaction is a relief for application development. However, they
			are an important feature that ordinary desktop applications
			lack. They allow referencing different functionalities of an
			application or resources managed by the application. They are also
			important for integration with external applications.
		</para>

		<para>
			Certain resources can be identified through a
			<firstterm>URI</firstterm> or <firstterm>Universal Resource
			Identifier</firstterm>.  A URI can easily be passed around or stored
			as a bookmark. We will see in <xref
			linkend="section.application.resources.uri"/> how you can retrieve
			the URI of a page request. Similarly, a page request can have query
			parameters, which can be handled as detailed in <xref
			linkend="section.application.resources.parameters"/>.
		</para>

		<para>
			Using URIs or request parameters to access functionalities or content
			is not as straight-forward as in conventional page-based web
			applications. Vaadin, just as any other AJAX framework, uses
			browser cookies not just for tracking users but also for tracking the
			application state. Cookies are unique in a browser, so any two
			windows share the same cookies and therefore also the state. The
			advantage is that you can close your browser and open it again and
			the application will be in the state where you left off (except for
			components such as text fields which did not have the immediate
			attribute enabled). The disadvantage is that there is no good way to
			distinguish between the windows, so there can usually be only a
			single application window. Even if there were several, you would have
			trouble with synchronization of application data between
			windows. Many conventional page-based web applications simply ignore
			out-of-sync situations, but such situations are risky for application
			platforms that are intended to be stable. Therefore it is safer to work with a
			single browser window. If you wish to have multiple windows in your
			application, you can create them inside the main window as
			<classname>Window</classname> objects. A URI can be used to fetch
			resources that have no particular state or to provide an entry point
			to the application.
		</para>

	</section>

	<section xml:id="advanced.resources">
		<title>Resources</title>

		<para>
			In addition to high-level resource classes described in <xref
			linkend="application.resources"/>, Vaadin provides low-level facilities
			for retrieving the URI and other parameters of HTTP requests. In the
			following, we will look into low-level interfaces for handling URIs and
			parameters to provide resources and functionalities.
		</para>

		<para>
			Notice that using URI or parameter handlers to create "pages" is not
			meaningful in Vaadin or in AJAX applications generally. See <xref
			linkend="advanced.application.pages"/> for reasons.
		</para>

		<section xml:id="section.application.resources.uri">
			<title>URI  Handlers</title>

			<para>
				The URI parameter for the application is useful mainly for two purposes:
				for providing some special functionality according to the URI or for
				providing dynamic content. Dynamic content can also be provided with
				<classname>StreamResource</classname>.
			</para>

			<para>
				You can retrieve the URI for the HTTP request made for your
				application by implementing the
				<classname>com.vaadin.terminal.URIHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addURIHandler()</methodname> method. You then get the
				URI by implementing the <methodname>handleURI()</methodname>
				method. The method gets two parameters: a context and a URI
				relative to the context. The context is the base URI for your
				application.
			</para>

			<programlisting><![CDATA[    public void init() {
        final Window main = new Window("Hello window");
        setMainWindow(main);

        URIHandler uriHandler = new URIHandler() {
            public DownloadStream handleURI(URL context, String relativeUri) {
                // Do something here
                System.out.println("handleURI=" + relativeUri);
                return null; // Should be null unless providing dynamic data.
            }
        };
        main.addURIHandler(uriHandler);

    }]]></programlisting>

			<para>
				If you have multiple URI handlers attached to a window, they are executed
				after one another. The URI handlers should return
				<parameter>null</parameter>, unless you wish to provide dynamic content
				with the call. Other URI handlers attached to the window will not be
				executed after some handler returns non-null data. The combined parameter
				and URI handler example below shows how to create dynamic content with a
				URI handler.
			</para>

			<para>
				Notice that if you do provide dynamic content with a URI handler, the
				dynamic content is returned in the HTTP response. If the handler makes any
				changes to the UI state of the application, these changes are not rendered
				in the browser, as they are usually returned in the HTTP response made by
				the Application object and now the custom URI handler overrides the
				default behaviour. If your client-side code makes a server call that does
				update the UI state, the client-side must initiate an update from the
				server. For example, if you have an integration situation where you make a
				JavaScript call to the server, handle the request with a URI handler,
				and the server state changes as a side-effect, you can use the
				<methodname>itmill.forceSync()</methodname> method to force the update.
			</para>

		</section>

		<section xml:id="section.application.resources.parameters">
			<title>Parameter Handlers</title>
		
			<para>
				You can retrieve the parameters passed to your application by
				implementing the
				<classname>com.vaadin.terminal.ParameterHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addParameterHandler()</methodname> method. You then
				get the parameters in the
				<methodname>handleParameters()</methodname> method. The
				parameters are passes as a map from string key to a vector of
				string values.
			</para>

			<programlisting><![CDATA[class MyParameterHandler implements ParameterHandler {
    public void handleParameters(Map parameters) {
        // Print out the parameters to standard output
        for (Iterator it = parameters.keySet().iterator(); it.hasNext();) {
            String key   = (String) it.next();
            String value = ((String[]) parameters.get(key))[0];
            System.out.println("Key: "+key+", value: "+value);
        }
    }
}]]></programlisting>

			<para>
				The parameter handler is not called if there are no parameters. Parameter
				handler is called before the URI handler, so if you handle both, you might
				typically want to just store the URI parameters in the parameter handler
				and do actual processing in URI handler. This allows you, for example, to
				create dynamic resources based on the URI parameters.
			</para>

			<programlisting><![CDATA[import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.util.Map;
import javax.imageio.ImageIO;
import com.vaadin.terminal.*;

/**
 * Demonstrates handling URI parameters and the URI itself to create a dynamic
 * resource.
 */
public class MyDynamicResource implements URIHandler, ParameterHandler {
    String textToDisplay = "- no text given -";

    /**
     * Handle the URL parameters and store them for the URI handler to use.
     */
    public void handleParameters(Map parameters) {
        // Get and store the passed HTTP parameter.
        if (parameters.containsKey("text"))
            textToDisplay = ((String[])parameters.get("text"))[0]; 
    }

    /**
     * Provides the dynamic resource if the URI matches the resource URI. The
     * matching URI is "/myresource" under the application URI context.
     * 
     * Returns null if the URI does not match. Otherwise returns a download
     * stream that contains the response from the server.
     */
    public DownloadStream handleURI(URL context, String relativeUri) {
        // Catch the given URI that identifies the resource, otherwise let other
        // URI handlers or the Application to handle the response.
        if (!relativeUri.startsWith("myresource"))
            return null;
        
        // Create an image and draw some background on it.
        BufferedImage image = new BufferedImage (200, 200, BufferedImage.TYPE_INT_RGB);
        Graphics drawable = image.getGraphics();
        drawable.setColor(Color.lightGray);
        drawable.fillRect(0,0,200,200);
        drawable.setColor(Color.yellow);
        drawable.fillOval(25,25,150,150);
        drawable.setColor(Color.blue);
        drawable.drawRect(0,0,199,199);
        
        // Use the parameter to create dynamic content.
        drawable.setColor(Color.black);
        drawable.drawString("Text: "+textToDisplay, 75, 100);

        try {
            // Write the image to a buffer.
            ByteArrayOutputStream imagebuffer = new ByteArrayOutputStream();
            ImageIO.write(image, "png", imagebuffer);

            // Return a stream from the buffer.
            ByteArrayInputStream istream = new ByteArrayInputStream(imagebuffer.toByteArray());
            return new DownloadStream (istream,null,null);
        } catch (IOException e) {
            return null;
        }
    }
}]]></programlisting>

			<para>
				When you use the dynamic resource class in your application, you obviously
				need to provide the same instance of the class as both types of handler:
			</para>

			<programlisting><![CDATA[MyDynamicResource myresource = new MyDynamicResource();
mainWindow.addParameterHandler(myresource);
mainWindow.addURIHandler(myresource);]]></programlisting>

			<figure>
				<title>Dynamic Resource with URI Parameters</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

    <!--
	<section xml:id="advanced.servlet">
		<title>Java Servlet Parameters</title>

       UNFINISHED
	</section>
    -->

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

		<!-- UNFINISHED -->

		<para>
			Shortcut keys can be defined as <emphasis>actions</emphasis> using the
			<classname>ShortcutAction</classname> class. ShortcutAction extends generic 
			<classname>Action</classname> class that is used for example in 
			<classname>Tree</classname> and <classname>Table</classname> for context menus.
			Currently the only classes that accept <classname>ShortcutActions</classname> 
			are <classname>Window</classname> and <classname>Panel</classname>.
			This may change in the future. <classname>Table</classname> is a good
			candidate to support ShortcutActions. 
		</para>
		
		<para>		
			To handle key presses, you need	to define an action handler by implementing 
			the <classname>Handler</classname> interface. The interface has two methods 
			that you need to implement: <methodname>getActions()</methodname> and
			<methodname>handleAction()</methodname>.
		</para>

		<para>
			The <methodname>getActions()</methodname> interface method must return an
			array of <classname>Action</classname> objects for the component specified
			with the second parameter for the method, the <parameter>sender</parameter> of
			an action. For a keyboard shortcut, you use a
			<classname>ShortcutAction</classname>. The implementation of the method could
			be following:
		</para>

		<programlisting><![CDATA[	// Have the unmodified Enter key cause an event
	Action action_ok = new ShortcutAction("Default key",
			ShortcutAction.KeyCode.ENTER, null);

	// Have the C key modified with Alt cause an event
	Action action_cancel = new ShortcutAction("Alt+C",
			ShortcutAction.KeyCode.C,
			new int[] { ShortcutAction.ModifierKey.ALT });
	
	Action[] actions = new Action[] {action_cancel, action_ok};
	
	public Action[] getActions(Object target, Object sender) {
		if(sender == myPanel) {
			return actions;
		}
		return null;
	}
]]></programlisting>

		<para>
			The returned Action array may be static or created dynamically for different
			senders according to your needs. 
		</para>

		<para>
			The constructor method of <classname>ShortcutAction</classname> takes a 
			symbolic caption for the action; this is largely irrelevant
			for shortcut actions in their current implementation, but might be used 
			later if implementors use them in both menus and as shortcut actions.
			The second parameter is the keycode, as defined in 
			<classname>ShortcutAction.KeyCode</classname> interface. Currently, the 
			following keycodes are allowed:
		</para>

		<variablelist>
			<varlistentry>
				<term>Keys A to Z</term>
				<listitem>Normal letter keys</listitem>
			</varlistentry>
			<varlistentry>
				<term>F1 to F12</term>
				<listitem>
					<para>Function keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>BACKSPACE, DELETE, ENTER, ESCAPE, INSERT, TAB</term>
				<listitem>
					<para>Control keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>NUM0 to NUM9</term>
				<listitem>
					<para>Number pad keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>ARROW_DOWN, ARROW_UP, ARROW_LEFT, ARROW_RIGHT</term>
				<listitem>
					<para>Arrow keys</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>HOME, END, PAGE_UP, PAGE_DOWN</term>
				<listitem>
					<para>Other movement keys</para>
				</listitem>
			</varlistentry>
		</variablelist>

		<para>
			The third parameter is an array of modifier keys, as defined in the
			<classname>ShortcutAction.ModifierKey</classname> interface. The
			following modifier keys are allowed: <parameter>ALT</parameter>,
			<parameter>CTRL</parameter>, and <parameter>SHIFT</parameter>. The modifier
			keys can be combined; for example, the following defines shortcut key
			combination
			<keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>S</keycap></keycombo>:


		<programlisting><![CDATA[ShortcutAction("Ctrl+Shift+S",
               ShortcutAction.KeyCode.S, new int[] {
                      ShortcutAction.ModifierKey.CTRL,
                      ShortcutAction.ModifierKey.SHIFT});]]></programlisting>

		</para>

		<para>
			The following example demonstrates the definition of a default button for a
			user interface, as well as a normal shortcut key,
			<keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
			<guibutton>Cancel</guibutton> button.
		</para>

		<programlisting><![CDATA[import com.vaadin.event.Action;
import com.vaadin.event.ShortcutAction;
import com.vaadin.event.Action.Handler;
import com.vaadin.ui.Button;
import com.vaadin.ui.CustomComponent;
import com.vaadin.ui.FormLayout;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Label;
import com.vaadin.ui.Panel;
import com.vaadin.ui.TextField;

public class DefaultButtonExample extends CustomComponent implements Handler {
	// Define and create user interface components
	Panel panel = new Panel("Login");
	FormLayout formlayout = new FormLayout();
	TextField username = new TextField("Username");
	TextField password = new TextField("Password");
	HorizontalLayout buttons = new HorizontalLayout();

	// Create buttons and define their listener methods.
	Button ok = new Button("OK", this, "okHandler");
	Button cancel = new Button("Cancel", this, "cancelHandler");

	// Have the unmodified Enter key cause an event
	Action action_ok = new ShortcutAction("Default key",
			ShortcutAction.KeyCode.ENTER, null);

	// Have the C key modified with Alt cause an event
	Action action_cancel = new ShortcutAction("Alt+C",
			ShortcutAction.KeyCode.C,
			new int[] { ShortcutAction.ModifierKey.ALT });

	public DefaultButtonExample() {
		// Set up the user interface
		setCompositionRoot(panel);
		panel.addComponent(formlayout);
		formlayout.addComponent(username);
		formlayout.addComponent(password);
		formlayout.addComponent(buttons);
		buttons.addComponent(ok);
		buttons.addComponent(cancel);

		// Set focus to username
		username.focus();

		// Set this object as the action handler
		System.out.println("adding ah");
		panel.addActionHandler(this);

		System.out.println("start done.");
	}

	/**
	 * Retrieve actions for a specific component. This method will be called for
	 * each object that has a handler; in this example just for login panel. The
	 * returned action list might as well be static list.
	 */
	public Action[] getActions(Object target, Object sender) {
		System.out.println("getActions()");
		return new Action[] { action_ok, action_cancel };
	}

	/**
	 * Handle actions received from keyboard. This simply directs the actions to
	 * the same listener methods that are called with ButtonClick events.
	 */
	public void handleAction(Action action, Object sender, Object target) {
		if (action == action_ok) {
			okHandler();
		}
		if (action == action_cancel) {
			cancelHandler();
		}
	}

	public void okHandler() {
		// Do something: report the click
		formlayout.addComponent(new Label("OK clicked. " + "User="
				+ username.getValue() + ", password=" + password.getValue()));
		//  
	}

	public void cancelHandler() {
		// Do something: report the click
		formlayout.addComponent(new Label("Cancel clicked. User="
				+ username.getValue() + ", password=" + password.getValue()));
	}
}]]></programlisting>

		<para>
			Notice that the keyboard actions can currently be attached only to 
			<classname>Panel</classname>s and <classname>Window</classname>s. This can
			cause problems if you have components that require a certain key. For example,
			multi-line <classname>TextField</classname> requires the
			<keycap>Enter</keycap> key. There is currently no way to filter the shortcut
			actions out while the focus is inside some specific component, so you need to
			avoid such conflicts.
		</para>
	</section>

	<section xml:id="advanced.printing">
		<title>Printing</title>

		<para>
			Vaadin does not currently have any special support for
			printing. Printing on the server-side is anyhow largely independent from the
			web UI of an application. You just have to take care that the printing does
			not block server requests, possibly by running printing in another thread.
		</para>

		<para>
			For client-side printing, most browsers support printing the web page. The
			<methodname>print()</methodname> method in JavaScript opens the print window
			of the browser. You can easily make a HTML button or link that prints the
			current page by placing the custom HTML code inside a
			<classname>Label</classname>.
		</para>

		<programlisting><![CDATA[main.addComponent(new Label("<input type='button' onClick='print()' value='Click to Print'/>", Label.CONTENT_XHTML));]]></programlisting>

		<para>
			This button would print the current page. Often you want to be able to print a
			report or receipt and it should not have any UI components. In such a case you
			could offer it as a PDF resource, or you could open a new window as is done
			below and automatically launch printing.
		</para>

		<programlisting><![CDATA[// A button to open the printer-friendly page.
Button printButton = new Button("Click to Print");
main.addComponent(printButton);
printButton.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        // Create a window that contains stuff you want to print.
        Window printWindow = new Window("Window to Print");
        
        // Have some content to print.
        printWindow.addComponent(new Label("Here's some dynamic content."));
        
        // To execute the print() JavaScript, we need to run it
        // from a custom layout.
        CustomLayout scriptLayout = new CustomLayout("printpage");
        printWindow.addComponent (scriptLayout);
        
        // Add the printing window as an application-level window.
        main.getApplication().addWindow(printWindow);

        // Open the printing window as a new browser window
        main.open(new ExternalResource(printWindow.getURL()), "_new");
    } 
});]]></programlisting>

		<para>
			How the browser opens the window, as an actual window or just a tab, depends
			on the browser. Notice that above we create a new window object each time the
			print button is clicked, which leads to unused window objects. If this is a
			real problem, you might want to reuse the same window object or clean up the
			old ones - it's ok because the user doesn't interact with them later anyhow.
		</para>

		<para>
			You will also need a custom layout that contains the
			<methodname>print()</methodname> JavaScript function that launches the
			printing. Notice that the custom layout <emphasis>must</emphasis> contain also
			another element (below a <literal>&lt;div&gt;</literal>) in addition to the
			<literal>&lt;script&gt;</literal> element.
		</para>

		<programlisting><![CDATA[<div>This is some static content.</div>

<script type='text/javascript'>
    print();
</script>
]]></programlisting>

		<para>
			Printing as PDF would not require creating a <classname>Window</classname>
			object, but you would need to provide the content as a static or a dynamic
			resource for the <methodname>open()</methodname> method. Printing a PDF file
			would obviously require a PDF viewer cabability (such as Adobe Reader) in the
			browser.
		</para>

	</section>

</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

