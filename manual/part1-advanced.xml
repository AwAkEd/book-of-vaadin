<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various features and topics often needed in
        applications. While other topics could be considered as "advanced", the first
        section gives a brief introduction to AJAX development for beginners.
    </para>

	<section xml:id="advanced.application.pages">
		<title>Special Characteristics of AJAX Applications</title>
		
		<para>
            New to AJAX? This section is intended for people familiar with the development
            of either traditional web applications or desktop applications, who are
            entering AJAX-enabled web application development. AJAX application
            development has a few special characteristics with respect to other types of
            applications. Possibly the most important one is how the display is managed in
            the web browser.
		</para>

		<para>
			The web was originally not built for applications, but for hypertext
			pages that you can view with a browser. The purpose of web pages is
			to provide <emphasis>content</emphasis> for the user. Application
			software has a somewhat different purpose; usually to allow you to
			work on some data or content, much of which is not ever intended to
			be accessible through a web browser as web pages. As the web is
			inherently page-based, conventional web applications had to work with
			page requests and output HTML as response. JavaScript and AJAX have
			made it possible to let go of the pages.
		</para>

		<para>
			Pages are largely an unknown concept to conventional desktop
			applications. At most, desktop applications can open multiple
			windows, but usually they work with a single main window, with an
			occasional dialog window here and there. Same goes usually for web
			applications developed with Vaadin: an application typically
			runs on a single page, changing the layout as needed and popping up
			dialog boxes.
		</para>

		<para>
			Not having to load pages and use hyperlinks to communicate all user
			interaction is a relief for application development. However, they
			are an important feature that ordinary desktop applications
			lack. They allow referencing different functionalities of an
			application or resources managed by the application. They are also
			important for integration with external applications.
		</para>

		<para>
			Certain resources can be identified through a
			<firstterm>URI</firstterm> or <firstterm>Universal Resource
			Identifier</firstterm>.  A URI can easily be passed around or stored
			as a bookmark. We will see in <xref
			linkend="section.application.resources.uri"/> how you can retrieve
			the URI of a page request. Similarly, a page request can have query
			parameters, which can be handled as detailed in <xref
			linkend="section.application.resources.parameters"/>.
		</para>

		<para>
			Using URIs or request parameters to access functionalities or content
			is not as straight-forward as in conventional page-based web
			applications. Vaadin, just as any other AJAX framework, uses
			browser cookies not just for tracking users but also for tracking the
			application state. Cookies are unique in a browser, so any two
			windows share the same cookies and therefore also the state. The
			advantage is that you can close your browser and open it again and
			the application will be in the state where you left off (except for
			components such as text fields which did not have the immediate
			attribute enabled). The disadvantage is that there is no good way to
			distinguish between the windows, so there can usually be only a
			single application window. Even if there were several, you would have
			trouble with synchronization of application data between
			windows. Many conventional page-based web applications simply ignore
			out-of-sync situations, but such situations are risky for application
			platforms that are intended to be stable. Therefore it is safer to work with a
			single browser window. If you wish to have multiple windows in your
			application, you can create them inside the main window as
			<classname>Window</classname> objects. A URI can be used to fetch
			resources that have no particular state or to provide an entry point
			to the application.
		</para>

	</section>

	<section xml:id="application.windows">
		<title>Application-Level Windows</title>

		<para>
			Vaadin Release 5 introduces support for multiple application-level
			windows that can be used just like the main window. All such windows use the
			same application session. Each window is identified with a URL that is used to
			access it. This makes it possible to bookmark application-level windows. Such
			windows can even be created dynamically based on URLs.
		</para>

		<para>
			Application-level windows allow several uses important for the usability of
			browser-based applications.
		</para>

		<itemizedlist>
			<listitem>
				<emphasis>Native child windows</emphasis>. An application can open child
				windows that are not floating windows inside a parent window.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding windows</emphasis>. Windows can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="application.embedding"/>.
			</listitem>
		</itemizedlist>

		<para>
			Because of the special nature of AJAX applications, these uses require some
			caveats. We will go through them later in <xref
			linkend="application.windows.caveats"/>.
		</para>
		
		<section>
			<title>Creating New Application-Level Windows</title>

			<para>
				Creating a new application-level window is much like creating a child
				window (see <xref linkend="application.child-windows"/>), except that the
				window is added with <methodname>addWindow()</methodname> to the application
				object instead of the main window.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    public void init() {
        // First create the main window.
        final Window main = new Window ("My Test Application");
        setMainWindow(main);
         
        // Create another application-level window.
        final Window mywindow = new Window("Second Window");
        
        // Manually set the name of the window.
        mywindow.setName("mywindow");
        
        // Add some content to the window.
        mywindow.addComponent(new Label("Has content."));

        // Add the window to the application.
        addWindow(mywindow);
    }
}]]></programlisting>

			<para>
				This creates the window object that a user can view by opening a URL in
				a browser. Creating an application-level window object does not open a new
				browser window automatically to view the object, but if you wish to open
				one, you have to do it explicitly as shown below. An application-level
				window has a unique URL, which is based on the application URL and the
				name of the window given with the <methodname>setName()</methodname>
				method. For example, if the application URL is
				<uri>http://localhost:8080/myapp/</uri> and the window name is
				<literal>mywindow</literal>, the URL for the window will be
				<uri>http://localhost:8080/myapp/mywindow/</uri>. If the name of a window
				is not explicitly set with <methodname>setName()</methodname>, an
				automatically generated name will be used. The name can be retrieved with
				the <methodname>getName()</methodname> method and the entire URL with
				<methodname>getURL()</methodname>.
			</para>

			<para>
				There are three typical ways to open a new window: using the
				<methodname>open()</methodname> method of <classname>Window</classname>
				class, a <classname>Link</classname>, or referencing it from HTML or
				JavaScript code written inside a <classname>Label</classname> component.
			</para>

			<para>
				The <classname>Window</classname> <methodname>open()</methodname> method
				takes as parameters a resource to open and the target name. You can use
				<classname>ExternalResource</classname> to open a specific URL, which you
				get from the window to be opened with the
				<methodname>getURL()</methodname> method.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Create a button to open a new window. */
main.addComponent(new Button("Click to open new window",
                  new Button.ClickListener() { 
    public void buttonClick(ClickEvent event) {
        // Open the window.
        main.open(new ExternalResource(mywindow.getURL()),
                  "_new");
    }      
}));]]></programlisting>

			<para>
				The target name is one of the default HTML target names (<parameter>_new</parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, etc.) or a custom target name.  How the window is
				exactly opened depends on the browser. Browsers that support tabbed
				browsing can open the window in another tab, depending on the browser
				settings.
			</para>

			<para>
				Another typical way to open windows is to use a <classname>Link</classname>
				component with the window URL as an
				<classname>ExternalResource</classname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/* Add a link to the second window. */
Link link = new Link("Click to open second window",
                     new ExternalResource(mywindow.getURL()));
link.setTargetName("second");
link.setTargetHeight(300);
link.setTargetWidth(300);
link.setTargetBorder(Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);]]></programlisting>

			<para>
				Using a <classname>Link</classname> allows you to specify parameters for
				the window that opens by clicking on the link. Above, we set the
				dimensions of the window and specify what window controls the window
				should contain. The <parameter>Link.TARGET_BORDER_DEFAULT</parameter>
				specifies to use the default, which includes most of the usual window
				controls, such as the menu, the toolbar, and the status bar.
			</para>

			<para>
				Another way to allow the user to open a window is to insert the URL in
				HTML code inside a <classname>Label</classname>. This allows even more
				flexibility in specifying how the window should be opened.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Add the link manually inside a Label.
main.addComponent(
    new Label("Second window: <a href='" + mywindow.getURL()
              + "' target='second'>click to open</a>",
              Label.CONTENT_XHTML));
main.addComponent(
    new Label("The second window can be accessed through URL: "
              + mywindow.getURL()));]]></programlisting>

			<para>
				When an application-level window is closed in the browser the
				<methodname>close()</methodname> method is normally called just like
				for a child window and the <classname>Window</classname> object is
				purged from the application. However, there are situations where
				<methodname>close()</methodname> might not be called. See
				<xref linkend="application.windows.closing"/> for more information. 
			</para>

		</section>

		<section xml:id="application.windows.dynamic">
			<title>Creating Windows Dynamically</title>
			
			<para>
				You can create a window object dynamically by its URL path by overriding
				the <methodname>getWindow()</methodname> method of the
				<classname>Application</classname> class. The method gets a window name as
				its parameter and must return the corresponding
				<classname>Window</classname> object. The window name is determined from
				the first URL path element after the application URL (window name may not
				contain slashes). See the notes below for setting the actual name of the
				dynamically created windows below.
			</para>

			<para>
				The following example allows opening windows with a window name that
				begins with "<literal>planet-</literal>" prefix. Since the method is
				called for <emphasis>every</emphasis> browser request for the application,
				we filter only the requests where a window with the given name does not
				yet exist.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class WindowTestApplication extends Application {
    ...

    @Override
    public Window getWindow(String name) {
        // If a dynamically created window is requested, but
        // it does not exist yet, create it.
        if (name.startsWith("planet-") &&
              super.getWindow(name) == null) {
            String planetName =
                    name.substring("planet-".length());

            // Create the window object.
            Window newWindow =
                    new Window("Window about " + planetName);
            
            // DANGEROUS: Set the name explicitly. Otherwise,
            // an automatically generated name is used, which
            // is usually safer.
            newWindow.setName(name);

            // Put some content in it.
            newWindow.addComponent(
                new Label("This window contains details about " +
                          planetName + "."));
            
            // Add it to the application as a regular
            // application-level window.
            addWindow(newWindow);
            
            return newWindow;
        }

        // Otherwise the Application object manages existing
        // windows by their name.
        return super.getWindow(name);
    }]]></programlisting>

			<para>
				The window name is and must be a unique indentifier for each
				<classname>Window</classname> object instance. If you use
				<methodname>setName()</methodname> to set the window name explicitly, as
				we did above, any browser window that has the same URL (within the same
				browser) would open the <emphasis>same</emphasis> window object. This is
				dangerous and <emphasis>generally not recommended</emphasis>, because the
				browser windows would share the same window object. Opening two windows
				with the same static name would immediately lead to a synchronization
				error, as is shown in <xref
				linkend="figure.application.window.dynamic.error"/> below. (While also the
				window captions are same, they are irrelevant for this problem.)
			</para>

			<figure xml:id="figure.application.window.dynamic.error">
				<title>Synchronization Error Between Windows with the Same Name</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				There are some cases where setting the name explicitly is useful. The
				launch application below is one example, as it always opens the other
				windows in a window target that is specific to the window name, thereby
				never creating two windows with the same URL. Similarly, if you had
				embedded the application in a browser frame and the link would open the
				window in a frame, you would not have problems. Having a single window
				instance for a URL is also useful if the browser crashes and the user
				opens the window again, as it will have kept its previous (server-side)
				state.
			</para>

			<para>
				Leaving the window name to be automatically generated allows opening
				multiple windows with the same URL, while each of the windows will have a
				separate state. The URL in the location bar stays unchanged and the
				generated window name is used only for the Ajax communications to identify
				the window object. A generated name is a string representation of a unique
				random number, such as "<literal>1928676448</literal>". You should be
				aware of the generated window names when overriding the
				<methodname>getWindow()</methodname> method (and not unintentionally
				create a new window instance dynamically for each such request). The
				condition in the above example would also filter out the requests for an
				already existing window with a generated name.
			</para>

			<para>
				<xref linkend="figure.application.window.dynamic.new"/> shows a
				dynamically created application-level window with the URL shown in the
				address bar. The URL for the application is here
				<uri>http://localhost:8080/tk5/windowexample/</uri>, including the
				application context, and the dynamically created window's name is
				<uri>planet-mars</uri>.
			</para>

			<figure xml:id="figure.application.window.dynamic.new">
				<title>A Dynamically Created Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-1.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The application knows the windows it already has and can return them after
				the creation. The application also handles closing and destruction of
				application-level window objects, as discussed in <xref
				linkend="application.windows.closing"/>.
			</para>

			<para>
				Such dynamic windows could be opened as in the following example:
			</para>
			
			<programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Window Test");
    setMainWindow(main);

    // Have some IDs for the dynamically creatable windows.
    final String[] items = new String[] { "mercury", "venus",
            "earth", "mars", "jupiter", "saturn", "uranus",
            "neptune" };
    
    // Create a list of links to each of the available window.
    for (int i = 0; i < items.length; i++) {
        // Create a URL for the window.
        String windowUrl = getURL() + "planet-" + items[i];
        
        // Create a link to the window URL. Using the 
        // item ID for the target also opens it in a new
        // browser window (or tab) unique to the window name.
        main.addComponent(
            new Link("Open window about " + items[i],
                     new ExternalResource(windowUrl),
                     items[i], -1, -1, Window.BORDER_DEFAULT));
    }
}]]></programlisting>
        			
			<figure xml:id="figure.application.window.dynamic.main">
				<title>Opening Windows</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="90" smallscale="100%" align="center" fileref="img/application/window-application-dynamic-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="application.windows.closing">
			<title>Closing Windows</title>

			<para>
				When the user closes an application-level window, the Client-Side Engine
				running in the browser will report the event to the server before the page
				is actually removed. You can catch the event with a
				<classname>Window.CloseListener</classname>, as is done in the example
				below.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[newWindow.addListener(new Window.CloseListener() {
    @Override
    public void windowClose(CloseEvent e) {
        // Do something.
        System.out.println(e.getWindow().getName() +
                           " was closed");

        // Add a text to the main window about closing.
        // (This does not update the main window.)
        getMainWindow().addComponent(
            new Label("Window '" + e.getWindow().getName() +
                      "' was closed."));
    }
});]]></programlisting>

			<para>
				Notice that the change to the server-side state of the main window (or
				another application-level window) does not refresh the window in the
				browser, so the change will be unseen until user interaction or polling
				refreshes the window. This problem and its dangers are discussed in <xref
				linkend="application.windows.caveats"/> below.
			</para>

			<para>
				The close event does not occur if the browser crashes or the connection
				is otherwise severed violently. In such a situation, the window object will
				be left hanging, which could become a resource problem if you allow the
				users to open many such application-level windows. The positive side is
				that the user can reconnect to the window using the window URL.
			</para>
		</section>

		<section xml:id="application.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
					For cases where you need communication between windows, we recommend
					using floating child windows. In Vaadin Release 5, an
					application window can not update the data in other windows. The
					contents of a window can only be updated when the particular window makes
					a request to the server. The request can be caused by user input or
					through polling.
				</para>

				<para>
					Changing the server-side state of a window while processing a user event
					from another window can potentially cause serious problems. Changing
					the client-side state of a window does not always immediately
					communicate the changes to the server. The server-side state can therefore
					be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.window.polling">
					<title>Communication Between Two Application-Level Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/application/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					The following example creates a second window that changes the
					contents of the main window, as illustrated in the figure above. In
					this simple case, changing the main window contents is safe.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table in the main window to hold items added
// in the second window
final Table table = new Table();
table.setPageLength(5);
table.getSize().setWidth(100, Size.UNITS_PERCENTAGE);
table.addContainerProperty("Name", String.class, "");
main.addComponent(table);

// Create the second window
final Window adderWindow = new Window("Add Items");
adderWindow.setName("win-adder");
main.getApplication().addWindow(adderWindow);

// Create selection component to add items to the table
final NativeSelect select = new NativeSelect("Select item to add");
select.setImmediate(true);
adderWindow.addComponent(select);

// Add some items to the selection
String items[] = new String[]{"-- Select --", "Mercury", "Venus", 
        "Earth", "Mars", "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int i=0; i<items.length; i++)
    select.addItem(items[i]);
select.setNullSelectionItemId(items[0]);

// When an item is selected in the second window, add
// table in the main window
select.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // If the selected value is something else
        // but a null selection item.
        if (select.getValue() != null) {
            // Add the selected item to the table
            // in the main window
            table.addItem(new Object[]{select.getValue()},
                          new Integer(table.size()));
        }
    }
});

// Link to open the selection window
Link link = new Link("Click to open second window",
                     new ExternalResource(adderWindow.getURL()),
                     "_new", 50, 200,
                     Link.TARGET_BORDER_DEFAULT);
main.addComponent(link);

// Enable polling to update the main window
ProgressIndicator poller = new ProgressIndicator();
poller.addStyleName("invisible");
main.addComponent(poller);]]></programlisting>

				<para>
					The example uses an invisible <classname>ProgressIndicator</classname>
					to implement polling. This is sort of a trick and a more proper API
					for polling is under design. Making the progress indicator invisible
					requires the following CSS style definition:
				</para>

				<programlisting><![CDATA[.v-progressindicator-invisible {
    display: none;
}]]></programlisting>


			</section>
		</section>
	</section>

	<section xml:id="application.embedding">
		<title>Embedding Applications in Web Pages</title>

		<para>
			Many web applications and especially web sites are not all AJAX, but AJAX is
			used only for specific functionalities. In practice, many web applications are
			a mixture of dynamic web pages and AJAX applications embedded to such
			pages.
		</para>

		<para>
			Embedding Vaadin applications is easy. There are two basic ways to
			embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the web application and load the Vaadin Client-Side Engine with a
			simple JavaScript code. The second method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element.  Both of these methods have
			advantages and disadvantages. The <literal>&lt;div&gt;</literal> method can
			only embed one application in a page, while the
			<literal>&lt;iframe&gt;</literal> method can embed as many as needed. One
			disadvantage of the <literal>&lt;iframe&gt;</literal> method is that the size
			of the <literal>&lt;iframe&gt;</literal> element is not flexible according to
			the content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods.
		</para>

		<section>
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<!-- OUTDATED? Check that this is current. -->

			<para>
                <emphasis>The loading code for the Client-Side Engine changed in IT Mill
                toolkit version 5.1.2 and the explanation below is no longer compatible
                with Vaadin. Please view the source code of the initial page of your
                application in your browser.</emphasis>

                <!-- TODO: ... or see the <filename>WebContent/multiapp.html</filename>
                for an example -->
            </para>

			<para>
				You can embed a Vaadin application inside a web page with a
				method that is equivalent to loading the initial page content from the
				application servlet in a non-embedded application. Normally, the
				<classname>ApplicationServlet</classname> servlet generates an initial
				page that contains the correct parameters for the specific
				application. You can easily configure it to load multiple Vaadin
				applications on the same page, assuming that they use the same widget set.
			</para>

			<para>
				 You can view the initial page for your application easily simply by
				 opening the application in a web browser and viewing the HTML source
				 code. You could just copy and paste the embedding code from the default
				 initial page. It has, however, some extra functionality that is not
				 normally needed: it generates some of the script content with
				 <methodname>document.write()</methodname> calls, which is useful only
				 when you are running the application as a portlet in a portal. The method
				 outlined below is much simpler.
			</para>

			<para>
				The <filename>WebContent/multiapp.html</filename> file included in the
				Vaadin installation package provides an example of embedding (multiple)
				Vaadin applications in a page. After launching the demo application, you
				can view the example at URL
				<uri>http://localhost:8888/multiapp.html</uri>. Notice that the example
				assumes the use of root context for the applications
				(<parameter>/</parameter>).
			</para>

			<!-- figure xml:id="figure.embedding.source">
				<title>Source Code of an Initial Page</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" align="center" fileref="img/application/embedding1.png"/>
					</imageobject>
				</mediaobject>
			</figure -->

			<para>
				Embedding requires four elements inside the HTML document:
			</para>

			<orderedlist>
				<listitem>
					<para>
						In the <literal>&lt;head&gt;</literal> element, you need to define
						the application URI and parameters and load the Vaadin
						Client-Side Engine. The <varname>vaadin</varname> variable is an
						associative map that can contain various runtime data used by the
						Client-Side Engine of Vaadin. The
						<varname>vaadinConfigurations</varname> item is itself an
						associate map that contains parameters for each of the
						applications embedded in the page. The map must contain the
						following items:
					</para>

                    <variablelist>
                        <varlistentry>
                            <term><classname>appUri</classname></term>
                            <listitem>
                                The application URI consists of the context and the
                                application path. If the context is
                                <literal>/mycontext</literal> and the application path is
                                <literal>myapp</literal>, the
                                <parameter>appUri</parameter> would be
                                <literal>/mycontext/myapp</literal>. The
                                <filename>multiapp.html</filename> example assumes the use
                                of root context, which is used in the demo application.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>pathInfo</classname></term>
                            <listitem>
                                The <parameter>PATHINFO</parameter> parameter for the
                                Servlet.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>themeUri</classname></term>
                            <listitem>
                                URI of the application theme. The URI must include
                                application context and the path to the theme
                                directory. Themes are, by default, stored under the
                                <filename>/VAADIN/themes/</filename> path.
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>versionInfo</classname></term>
                            <listitem>
                                This item is itself an associative map that contains two
                                parameters: <parameter>vaadinVersion</parameter> contains
                                the version number of the Vaadin version used by the
                                application. The <parameter>applicationVersion</parameter>
                                parameter contains the version of the particular
                                application.
                            </listitem>
                        </varlistentry>
                    </variablelist>

					<para>
						The following example defines two applications to run in the same
						window: the Calculator and Hello World examples. In the example,
						the application context is <literal>/tk5</literal>.
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script type="text/javascript"&gt;
    var vaadin = {
        vaadinConfigurations: {
            '<emphasis role="bold">calc</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/Calc</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                         NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            },
            '<emphasis role="bold">hello</emphasis>': {
                appUri:'<emphasis role="bold">/tk5/HelloWorld</emphasis>',
                pathInfo: '<emphasis role="bold">/</emphasis>',
                themeUri: '<emphasis role="bold">/tk5/VAADIN/themes/example</emphasis>',
                versionInfo : {
                    vaadinVersion:"5.9.9-INTERNAL-
                          NONVERSIONED-DEBUG-BUILD",
                    applicationVersion:"NONVERSIONED"
                }
            }
        }};
&lt;/script&gt;</programlisting>
				</listitem>

				<listitem>
					<para>
						Loading the Vaadin Client-Side Engine is done with the
						following kind of line in the <literal>&lt;head&gt;</literal>
						element:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;script language='javascript' src='/<emphasis>vaadin-examples</emphasis>/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'&gt;&lt;/script&gt;</programlisting>

					<para>
						The engine URI consists of the context of the web application,
						<literal>vaadin-examples</literal> above, followed by the path
						to the JavaScript (<filename>.js</filename>) file of the widget
						set, relative to the <filename>WebContent</filename>
						directory. The file contains the Client-Side Engine compiled for
						the particular widget set. The line above assumes the use of the
						default widget set of Vaadin. If you have made custom
						widgets that are defined in a custom widget set, you need to use
						the path to the compiled widget set file. Widget sets must be
						compiled under the
						<filename>WebContent/VAADIN/widgetsets</filename> directory.
					</para>

				</listitem>
				<listitem>
					<para>
						In the <literal>&lt;html&gt;</literal> element, you need to do a
						routine inclusion of GWT history <literal>iframe</literal>
						element as follows:
					</para>

					<programlisting><?pocket-size 65% ?>&lt;iframe id="__gwt_historyFrame"
        style="width:0;height:0;border:0"&gt;&lt;/iframe&gt;</programlisting>

				</listitem>
				<listitem>
					<para>
						The location of the Vaadin application is defined with a
						<literal>div</literal> placeholder element having
						<literal>id="calc"</literal>, where the identifier is the
						same as in the <parameter>vaadinConfigurations</parameter>
						parameter, as follows:
					</para>

					<programlisting>&lt;div id="calc"/&gt;</programlisting>
				</listitem>
			</orderedlist>

			<para>
				Below is a complete example of embedding an application. It works
				out-of-the-box with the <application>Calculator</application> demo
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding Example</title>

    <!-- Set parameters for the Vaadin Client-Side Engine. -->
    <script type="text/javascript">
	    var vaadin = {appUri:'Calc', pathInfo: '/'};
    </script>
    
    <!-- Load the Vaadin Client-Side Engine. -->
    <script language='javascript' src='/vaadin-examples/VAADIN/widgetsets/com.vaadin.terminal.gwt.DefaultWidgetSet/com.vaadin.terminal.gwt.DefaultWidgetSet.nocache.js'></script>

    <!-- We can stylize the web application. -->
    <style>
        #vaadin-ajax-window {background: #c0c0ff;}
        .v-button {background: pink;}
    </style>
  </head>

  <body>
    <!-- This <iframe> element is required by GWT. -->
    <iframe id="__gwt_historyFrame"
            style="width:0;height:0;border:0"></iframe>
    
    <h1>This is a HTML page</h1>
    <p>Below is the Vaadin application inside a table:</p>
    <table align="center" border="3" style="background: yellow;">
      <tr><th>The Calculator</th></tr>
      <tr>
        <td>
          <!-- Placeholder <div> for the Vaadin application -->
          <div id="vaadin-ajax-window"/>
        </td>
      </tr>
    </table>	
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.div"/>.
			</para>

			<figure xml:id="figure.embedding.div" float="center" floatstyle="before">
				<title>Embedded Application</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can style the web application with themes as described in <xref
				linkend="themes"/>. The Client-Side Engine loads the style sheets
				required by the application. In addition, you can do styling in the
				embedding page, as was done in the example above.
			</para>

			<para>
				The <application>Reservation Demo</application> and <application>Windowed
				Demos</application> provide similar examples of embedding an application
				in a web page. The embedding web pages are
				<filename>WebContent/reservr.html</filename> and
				<filename>WebContent/windoweddemos.html</filename>, respectively.
			</para>

			<para>
				The disadvantage of this embedding method is that there can only be one
				web application embedded in a page. One is usually enough, but if it is
				not, you need to use the <literal>&lt;iframe&gt;</literal> method below.
			</para>

		</section>

		<section>
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding a Vaadin application inside an
				<literal>&lt;iframe&gt;</literal> element is even easier than the method
				described above, as it does not require definition of any Vaadin specific
				definitions. The use of <literal>&lt;iframe&gt;</literal> makes it
				possible to embed multiple web applications or two different views to the
				same application on the same page.
			</para>

			<para>
				You can embed an application with an element such as the following:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<iframe src="/vaadin-examples/Calc"></iframe>]]></programlisting>

			<para>
				The problem with <literal>&lt;iframe&gt;</literal> elements is that their
				size of is not flexible depending on the content of the frame, but the
				content must be flexible to accommodate in the frame. You can set the size
				of an <literal>&lt;iframe&gt;</literal> element with
				<literal>height</literal> and <literal>width</literal> attributes.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside
       a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker"
                  height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="advanced.debug-production-modes">
		<title>Debug and Production Mode</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug
			mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode,
			which is on by default, enables a number of built-in debug features for the
			developers. The features include:
		</para>

		<itemizedlist>
			<listitem>Debug Window for accessing debug functionalities</listitem>
			<listitem>Display debug information in the Debug Window and server console.</listitem>
			<listitem><guibutton>Analyze layouting</guibutton> button that analyzes the layout for possible problems.</listitem>
		</itemizedlist>

		<para>
			All applications are run in the debug mode by default (since IT Mill Toolkit
			version 5.3.0). The production mode can be enabled, and debug mode thereby
			disabled, by adding a <parameter>productionMode=true</parameter> parameter to
			the servlet context in the <filename>web.xml</filename> deployment descriptor:
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[<context-param>
  <description>Vaadin production mode</description>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
</context-param>]]></programlisting>
		
		<para>
			Enabling the production mode disables the debug features, thereby preventing
			users from easily inspecting the inner workings of the application from the
			browser.
		</para>
		
		<section xml:id="advanced.debug-production-modes.debug.mode">
			<title>Debug Mode</title>
			
			<para>
				Running an application in the debug mode enables the client-side Debug
				Window in the browser. You can open the Debug Window by adding
				"<uri>?debug</uri>" to the application URL, e.g.,
				<uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in
				<xref linkend='figure.debug.window'/>, consists of buttons controlling the
				debugging features and a scrollable log of debug messages.
			</para>

			<figure id="figure.debug.window">
				<title>Debug Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<variablelist>
				<varlistentry>
					<term><guibutton>Clear console</guibutton></term>
					<listitem>
						Clears the log in the Debug Window.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Restart app</guibutton></term>
					<listitem>
						Restarts the application.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Force layout</guibutton></term>
					<listitem>
						Causes all currently visible layouts to recalculate their
						appearance. Layout components calculate the space required by all
						child components, so the layout appearance must be recalculated
						whenever the size of a child component is changed. In normal
						applications, this is done automatically, but when you do themeing
						or alter the CSS with Firebug, you may need to force all layouts
						to recalculate themselves, taking into account the recently made
						changes.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Analyze layouts</guibutton></term>
					<listitem>
						This is described in the following section.
					</listitem>
				</varlistentry>
			</variablelist>

			<para>
				If you use the Firebug plugin in Mozilla Firefox, the log messages will
				also be printed to the Firebug console. In such a case, you may want to
				enable client-side debugging without showing the Debug Window with
				"<uri>?debug=quiet</uri>" in the URL. In the quiet debug mode, log
				messages will only be printed to the Firebug console.
			</para>
		</section>

 		<section>
			<title>Analyzing Layouts</title>
			<para>
				The <guilabel>Analyze layouts</guilabel> button analyzes the currently
				visible layouts and makes a report of possible layout related
				problems. All detected layout problems are displayed in the log and also
				printed to the console.
			</para>

			<para>
				The most common layout problem is caused by placing a component that has a
				relative size inside a container (layout) that has undefined size, e.g.,
				adding a 100% wide <classname>Panel</classname> inside a
				<classname>HorizontalLayout</classname> with no width specification. In
				such a case, the error will look as shown below:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Vaadin DEBUG
- Window/1a8bd74 "My window" (width: MAIN WINDOW)
  - HorizontalLayout/1cf243b (width: UNDEFINED)
    - Panel/12e43f1 "My panel" (width: RELATIVE, 100.0 %)
Layout problem detected: Component with relative width inside a HorizontalLayout with no width defined
Relative sizes were replaced by undefined sizes, components may not render as expected.]]>
			</programlisting>
			
			<para>
				This particular error tells that the <classname>Panel</classname> "My
				panel" is 100% wide while the width of the containing
				<classname>HorizontalLayout</classname> is undefined. The components will
				be rendered as if the the width of the contained
				<classname>Panel</classname> was undefined, which might not be what the
				developer wanted. There are two possible fixes for this case: if the
				<classname>Panel</classname> should fill the main window horizontally, set
				a width for the <classname>HorizontalLayout</classname> (e.g. 100% wide),
				or set the width of the <classname>Panel</classname> to "undefined" to
				render the it as it is currently rendered but avoiding the warning
				message.
			</para>

			<para>
				The same error is shown in the Debug Window in a slightly different form
				and with an additional feature (see <xref
				linkend='figure.debug-window.analyze-layouts'/>). Checking the
				<guilabel>Emphasize component in UI</guilabel> box will turn red the
				background of the component that caused a warning, making it easy for
				the developer to figure out which component each warning relates to. The
				messages will also be displayed hierarchically, as a warning from a
				containing component often causes more warnings from its child
				components. A good rule of thumb is to work on the upper-level problems
				first and only after that worry about the warnings from the children.
			</para>
			
			<figure id="figure.debug-window.analyze-layouts">
				<title>Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
				</mediaobject>
			</figure>
						
		</section>

		<section>
			<title>Custom Layouts</title>

			<para>
				<classname>CustomLayout</classname> components can not be analyzed in the
				same way as other layouts. For custom layouts, the <guibutton>Analyze
				layouts</guibutton> button analyzes all contained relative-sized
				components and checks if any relative dimension is calculated to zero so
				that the component will be invisible. The error log will display a warning
				for each of these invisible components. It would not be meaningful to
				emphasize the component itself as it is not visible, so when you select
				such an error, the parent layout of the component is emphasized if
				possible.
			</para>

		</section>

		<section>
			<title>Debug Functions for Component Developers</title>

			<para>
				You can take advantage of the debug mode when developing client-side
				components. The static function
				<methodname>ApplicationConnection.getConsole()</methodname> will return a
				reference to a <classname>Console</classname> object which contains
				logging methods such as <methodname>log(String msg)</methodname> and
				<methodname>error(String msg)</methodname>.  These functions will print
				messages to the Debug Window and Firebug console in the same way as other
				debugging functionalities of Vaadin do. No messages will be
				printed if the Debug Window is not open or if the application is running
				in production mode.
			</para>
		</section>
	</section>

	<section xml:id="advanced.resources">
		<title>Resources</title>

		<para>
			In addition to high-level resource classes described in <xref
			linkend="application.resources"/>, Vaadin provides low-level facilities
			for retrieving the URI and other parameters of HTTP requests. In the
			following, we will look into low-level interfaces for handling URIs and
			parameters to provide resources and functionalities.
		</para>

		<para>
			Notice that using URI or parameter handlers to create "pages" is not
			meaningful in Vaadin or in AJAX applications generally. See <xref
			linkend="advanced.application.pages"/> for reasons.
		</para>

		<section xml:id="section.application.resources.uri">
			<title>URI  Handlers</title>

			<para>
				The URI parameter for the application is useful mainly for two purposes:
				for providing some special functionality according to the URI or for
				providing dynamic content. Dynamic content can also be provided with
				<classname>StreamResource</classname>.
			</para>

			<para>
				You can retrieve the URI for the HTTP request made for your
				application by implementing the
				<classname>com.vaadin.terminal.URIHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addURIHandler()</methodname> method. You then get the
				URI by implementing the <methodname>handleURI()</methodname>
				method. The method gets two parameters: a context and a URI
				relative to the context. The context is the base URI for your
				application.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    final Window main = new Window("Hello window");
    setMainWindow(main);

    URIHandler uriHandler = new URIHandler() {
        public DownloadStream handleURI(URL context,
                                        String relativeUri) {
            // Do something here
            System.out.println("handleURI=" + relativeUri);

            // Should be null unless providing dynamic data.
            return null;
        }
    };
    main.addURIHandler(uriHandler);

}]]></programlisting>

			<para>
				If you have multiple URI handlers attached to a window, they are executed
				after one another. The URI handlers should return
				<parameter>null</parameter>, unless you wish to provide dynamic content
				with the call. Other URI handlers attached to the window will not be
				executed after some handler returns non-null data. The combined parameter
				and URI handler example below shows how to create dynamic content with a
				URI handler.
			</para>

			<para>
				Notice that if you do provide dynamic content with a URI handler, the
				dynamic content is returned in the HTTP response. If the handler makes any
				changes to the UI state of the application, these changes are not rendered
				in the browser, as they are usually returned in the HTTP response made by
				the Application object and now the custom URI handler overrides the
				default behaviour. If your client-side code makes a server call that does
				update the UI state, the client-side must initiate an update from the
				server. For example, if you have an integration situation where you make a
				JavaScript call to the server, handle the request with a URI handler,
				and the server state changes as a side-effect, you can use the
				<methodname>vaadin.forceSync()</methodname> method to force the update.
			</para>

		</section>

		<section xml:id="section.application.resources.parameters">
			<title>Parameter Handlers</title>
		
			<para>
				You can retrieve the parameters passed to your application by
				implementing the
				<classname>com.vaadin.terminal.ParameterHandler</classname>
				interface. The handler class needs to be registered in the main
				window object of your application with the
				<methodname>addParameterHandler()</methodname> method. You then
				get the parameters in the
				<methodname>handleParameters()</methodname> method. The
				parameters are passes as a map from string key to a vector of
				string values.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[class MyParameterHandler implements ParameterHandler {
    public void handleParameters(Map parameters) {
        // Print out the parameters to standard output
        for (Iterator it = parameters.keySet().iterator();
             it.hasNext();) {
            String key   = (String) it.next();
            String value = ((String[]) parameters.get(key))[0];
            System.out.println("Key: "+key+", value: "+value);
        }
    }
}]]></programlisting>

			<para>
				The parameter handler is not called if there are no parameters. Parameter
				handler is called before the URI handler, so if you handle both, you might
				typically want to just store the URI parameters in the parameter handler
				and do actual processing in URI handler. This allows you, for example, to
				create dynamic resources based on the URI parameters.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.net.URL;
import java.util.Map;
import javax.imageio.ImageIO;
import com.vaadin.terminal.*;

/**
 * Demonstrates handling URI parameters and the URI itself to
 * create a dynamic resource.
 */
public class MyDynamicResource implements URIHandler,
                                          ParameterHandler {
    String textToDisplay = "- no text given -";

    /**
     * Handle the URL parameters and store them for the URI
     * handler to use.
     */
    public void handleParameters(Map parameters) {
        // Get and store the passed HTTP parameter.
        if (parameters.containsKey("text"))
            textToDisplay =
                ((String[])parameters.get("text"))[0];
    }

    /**
     * Provides the dynamic resource if the URI matches the
     * resource URI. The matching URI is "/myresource" under
     * the application URI context.
     * 
     * Returns null if the URI does not match. Otherwise
     * returns a download stream that contains the response
     * from the server.
     */
    public DownloadStream handleURI(URL context,
                                    String relativeUri) {
        // Catch the given URI that identifies the resource,
        // otherwise let other URI handlers or the Application
        // to handle the response.
        if (!relativeUri.startsWith("myresource"))
            return null;
        
        // Create an image and draw some background on it.
        BufferedImage image = new BufferedImage (200, 200,
                                    BufferedImage.TYPE_INT_RGB);
        Graphics drawable = image.getGraphics();
        drawable.setColor(Color.lightGray);
        drawable.fillRect(0,0,200,200);
        drawable.setColor(Color.yellow);
        drawable.fillOval(25,25,150,150);
        drawable.setColor(Color.blue);
        drawable.drawRect(0,0,199,199);
        
        // Use the parameter to create dynamic content.
        drawable.setColor(Color.black);
        drawable.drawString("Text: "+textToDisplay, 75, 100);

        try {
            // Write the image to a buffer.
            ByteArrayOutputStream imagebuffer =
                    new ByteArrayOutputStream();
            ImageIO.write(image, "png", imagebuffer);

            // Return a stream from the buffer.
            ByteArrayInputStream istream =
                    new ByteArrayInputStream(
                            imagebuffer.toByteArray());
            return new DownloadStream (istream,null,null);
        } catch (IOException e) {
            return null;
        }
    }
}]]></programlisting>

			<para>
				When you use the dynamic resource class in your application, you obviously
				need to provide the same instance of the class as both types of handler:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[MyDynamicResource myresource = new MyDynamicResource();
mainWindow.addParameterHandler(myresource);
mainWindow.addURIHandler(myresource);]]></programlisting>

			<figure>
				<title>Dynamic Resource with URI Parameters</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" smallscale="100%" align="center" fileref="img/application/paramhandler-screen.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

    <!--
	<section xml:id="advanced.servlet">
		<title>Java Servlet Parameters</title>

       UNFINISHED
	</section>
    -->

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

        <para>
            Vaadin provides simple ways for defining shortcut keys for field components
            and a default button, and a lower-level generic shortcut key binding API based
            on actions.
        </para>

        <section xml:id="advanced.shortcuts.defaultbutton">
            <title>Click Shortcuts for Default Buttons</title>

            <para>
                You can add or set a <emphasis>click shortcut</emphasis> to a button to
                set it as "default" button; pressing the defined key, typically
                <keycap>Enter</keycap>, in any component in the window causes a click
                event for the button.
            </para>

            <para>
                You can define a click shortcut with the
                <methodname>setClickShortcut()</methodname> shorthand method:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an OK button and set it as the default button
Button ok = new Button("OK");
ok.setClickShortcut(KeyCode.ENTER);
ok.addStyleName("primary");]]></programlisting>

            <para>
                The <literal>primary</literal> style name highlights a button to show the
                default button status; usually with a bolder font than usual, depending on
                the theme. The result can be seen in <xref
                linkend="figure.advanced.shortcuts.defaultbutton"/>.
            </para>

			<figure xml:id="figure.advanced.shortcuts.defaultbutton">
				<title>Default Button with Click Shortcut</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="advanced.shortcuts.focus">
            <title>Field Focus Shortcuts</title>

            <para>
                You can define a shortcut key that sets the focus to a field component
                (any component that inherits <classname>AbstractField</classname>) by
                adding a <classname>FocusShortcut</classname> as a shortcut listener to
                the field.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A field with Alt+N bound to it
TextField name = new TextField("Name (Alt+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.ALT));
layout.addComponent(name);

// A field with Alt+A bound to it
TextField address = new TextField("Address (Alt+A)");
address.addShortcutListener(
        new AbstractField.FocusShortcut(address, KeyCode.A,
                                        ModifierKey.ALT));
layout.addComponent(address);]]></programlisting>

            <para>
                The constructor of the <classname>FocusShortcut</classname> takes the
                field component as its first parameter, followed by the key code, and an
                optional list of modifier keys, as listed in <xref
                    linkend="advanced.shortcuts.keycodes"/>.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.actions">
            <title>Generic Shortcut Actions</title>

            <para>
                Shortcut keys can be defined as <emphasis>actions</emphasis> using the
                <classname>ShortcutAction</classname> class. ShortcutAction extends the
                generic <classname>Action</classname> class that is used for example in
                <classname>Tree</classname> and <classname>Table</classname> for context
                menus.  Currently, the only classes that accept
                <classname>ShortcutAction</classname>s are <classname>Window</classname>
                and <classname>Panel</classname>.
            </para>
		
            <para>
                To handle key presses, you need to define an action handler by
                implementing the <classname>Handler</classname> interface. The interface
                has two methods that you need to implement:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>.
            </para>

            <para>
                The <methodname>getActions()</methodname> method must return an array of
                <classname>Action</classname> objects for the component, specified with the
                second parameter for the method, the <parameter>sender</parameter> of an
                action. For a keyboard shortcut, you use a
                <classname>ShortcutAction</classname>. The implementation of the method
                could be following:
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an event
Action action_ok = new ShortcutAction("Default key",
        ShortcutAction.KeyCode.ENTER, null);

// Have the C key modified with Alt cause an event
Action action_cancel = new ShortcutAction("Alt+C",
        ShortcutAction.KeyCode.C,
        new int[] { ShortcutAction.ModifierKey.ALT });

Action[] actions = new Action[] {action_cancel, action_ok};

public Action[] getActions(Object target, Object sender) {
    if (sender == myPanel)
        return actions;

    return null;
}]]></programlisting>

            <para>
                The returned <classname>Action</classname> array may be static or you can
                create it dynamically for different senders according to your needs.
            </para>

            <para>
                The constructor of <classname>ShortcutAction</classname> takes a symbolic
                caption for the action; this is largely irrelevant for shortcut actions in
                their current implementation, but might be used later if implementors use
                them both in menus and as shortcut actions.  The second parameter is the
                key code and the third a list of modifier keys, which are listed in <xref
                linkend="advanced.shortcuts.keycodes"/>.
            </para>

            <para>
                The following example demonstrates the definition of a default button for a
                user interface, as well as a normal shortcut key,
                <keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
                <guibutton>Cancel</guibutton> button.
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[public class DefaultButtonExample extends CustomComponent
                                  implements Handler {
    // Define and create user interface components
    Panel panel = new Panel("Login");
    FormLayout formlayout = new FormLayout();
    TextField username = new TextField("Username");
    TextField password = new TextField("Password");
    HorizontalLayout buttons = new HorizontalLayout();

    // Create buttons and define their listener methods.
    Button ok = new Button("OK", this, "okHandler");
    Button cancel = new Button("Cancel", this, "cancelHandler");

    // Have the unmodified Enter key cause an event
    Action action_ok = new ShortcutAction("Default key",
            ShortcutAction.KeyCode.ENTER, null);

    // Have the C key modified with Alt cause an event
    Action action_cancel = new ShortcutAction("Alt+C",
            ShortcutAction.KeyCode.C,
            new int[] { ShortcutAction.ModifierKey.ALT });

    public DefaultButtonExample() {
        // Set up the user interface
        setCompositionRoot(panel);
        panel.addComponent(formlayout);
        formlayout.addComponent(username);
        formlayout.addComponent(password);
        formlayout.addComponent(buttons);
        buttons.addComponent(ok);
        buttons.addComponent(cancel);

        // Set focus to username
        username.focus();

        // Set this object as the action handler
        System.out.println("adding ah");
        panel.addActionHandler(this);

        System.out.println("start done.");
    }

    /**
     * Retrieve actions for a specific component. This method
     * will be called for each object that has a handler; in
     * this example just for login panel. The returned action
     * list might as well be static list.
     */
    public Action[] getActions(Object target, Object sender) {
        System.out.println("getActions()");
        return new Action[] { action_ok, action_cancel };
    }

    /**
     * Handle actions received from keyboard. This simply directs
     * the actions to the same listener methods that are called
     * with ButtonClick events.
     */
    public void handleAction(Action action, Object sender,
                             Object target) {
        if (action == action_ok) {
            okHandler();
        }
        if (action == action_cancel) {
            cancelHandler();
        }
    }

    public void okHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("OK clicked. "
                + "User=" + username.getValue() + ", password="
                + password.getValue()));
    }

    public void cancelHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("Cancel clicked. User="
                + username.getValue() + ", password="
                + password.getValue()));
    }
}]]></programlisting>

            <para>
                Notice that the keyboard actions can currently be attached only to
                <classname>Panel</classname>s and <classname>Window</classname>s. This can
                cause problems if you have components that require a certain key. For
                example, multi-line <classname>TextField</classname> requires the
                <keycap>Enter</keycap> key. There is currently no way to filter the
                shortcut actions out while the focus is inside some specific component, so
                you need to avoid such conflicts.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.keycodes">
            <title>Supported Key Codes and Modifier Keys</title>
            
            <para>
                The shortcut key definitions require a key code to identify the pressed
                key and modifier keys, such as Shift, Alt, or Ctrl, to specify a key
                combination.
            </para>

            <para>
                The key codes are defined in the
                <classname>ShortcutAction.KeyCode</classname> interface and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term>Keys <parameter>A</parameter> to <parameter>Z</parameter></term>
                    <listitem>Normal letter keys</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>F1</parameter> to <parameter>F12</parameter></term>
                    <listitem>
                        <para>Function keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter></term>
                    <listitem>
                        <para>Control keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>NUM0</parameter> to <parameter>NUM9</parameter></term>
                    <listitem>
                        <para>Number pad keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter></term>
                    <listitem>
                        <para>Arrow keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter></term>
                    <listitem>
                        <para>Other movement keys</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Modifier keys are defined in
                <classname>ShortcutAction.ModifierKey</classname> and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>ModifierKey.ALT</parameter></term>
                    <listitem>Alt key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.CTRL</parameter></term>
                    <listitem>Ctrl key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.SHIFT</parameter></term>
                    <listitem>Shift key</listitem>
                </varlistentry>
            </variablelist>

            <para>
                All constructors and methods accepting modifier keys take them as a
                variable argument list following the key code, separated with commas. For
                example, the following defines a
                <keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>N</keycap></keycombo>
                key combination for a shortcut.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField name = new TextField("Name (Ctrl+Shift+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.CTRL,
                                        ModifierKey.SHIFT));]]></programlisting>

            <section>
                <title>Supported Key Combinations</title>

                <para>
                    The actual possible key combinations vary greatly between browsers, as
                    most browsers have a number of built-in shortcut keys, which can not
                    be used in web applications. For example, Mozilla Firefox allows
                    binding almost any key combination, while Opera does not even allow
                    binding Alt shortcuts. Other browsers are generally in between these
                    two. Also, the operating system can reserve some key combinations and
                    some computer manufacturers define their own system key combinations.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="advanced.printing">
		<title>Printing</title>

        <indexterm xml:id="term:advanced.printing" class="startofrange">
            <primary>printing</primary>
        </indexterm>

		<para>
			Vaadin does not currently have any special support for
			printing. Printing on the server-side is, in any case, largely independent from the
			web UI of an application. You just have to take care that the printing does
			not block server requests, possibly by running printing in another thread.
		</para>

		<para>
            <indexterm xml:id="term:advanced.printing/print" class="startofrange">
                <primary><methodname>print()</methodname></primary>
            </indexterm>
            <indexterm xml:id="term:advanced.printing/JavaScript.print" class="startofrange">
                <primary>JavaScript</primary>
                <secondary><methodname>print()</methodname></secondary>
            </indexterm>
            
			For client-side printing, most browsers support printing the web page. Vaadin
			does not explicitly support launching the printing in browser, but you can
			easily use the JavaScript <methodname>print()</methodname> method that opens
			the print window of the browser.
		</para>

        <indexterm><primary>JavaScript</primary><secondary><methodname>executeJavaScript()</methodname></secondary></indexterm>
        <indexterm><primary><methodname>executeJavaScript()</methodname></primary></indexterm>

		<programlisting><?pocket-size 65% ?><![CDATA[final Button print = new Button("Print This Page");
print.addListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        print.getWindow().executeJavaScript("print();");
    }
});]]></programlisting>

		<para>
			This button would print the current page, including the button itself. Often,
			you want to be able to print a report or receipt and it should not have any
			visible UI components. In such a case, you could offer it as a PDF resource,
			or you could open a new window, as is done below, and automatically launch
			printing.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[// A button to open the printer-friendly page.
Button print = new Button("Click to Print");

print.addListener(new Button.ClickListener() {
	public void buttonClick(ClickEvent event) {
        // Create a window that contains what you want to print
        Window window = new Window("Window to Print");

        // Have some content to print
        window.addComponent(new Label(
                "<h1>Here's some dynamic content</h1>\n" +
                "<p>This is to be printed to the printer.</p>",
                Label.CONTENT_XHTML));

        // Add the printing window as a new application-level
        // window
        getApplication().addWindow(window);

        // Open it as a popup window with no decorations
        getWindow().open(new ExternalResource(window.getURL()),
                "_blank", 500, 200,  // Width and height 
                Window.BORDER_NONE); // No decorations

        // Print automatically when the window opens.
        // This call will block until the print dialog exits!
        window.executeJavaScript("print();");

        // Close the window automatically after printing
        window.executeJavaScript("self.close();");
    }
});]]></programlisting>

		<para>
			How the browser opens the window, as an actual (popup) window or just a tab, depends
			on the browser. Notice that calling the <methodname>print()</methodname> method in the
            window will block the entire application until the print dialog exits.

            <indexterm><primary><classname>Window</classname></primary><secondary>closing</secondary></indexterm>

            After printing, we automatically close the window with another JavaScript
            call, as there is no <methodname>close()</methodname> method in
            <classname>Window</classname>.
		</para>

        <indexterm startref="term:advanced.printing/print" class="endofrange"/>
        <indexterm startref="term:advanced.printing/JavaScript.print" class="endofrange"/>

		<para>
            <indexterm><primary>PDF</primary></indexterm>

			Printing as PDF would not require creating a <classname>Window</classname>
			object, but you would need to provide the content as a static or a dynamic
			resource for the <methodname>open()</methodname> method. Printing a PDF file
			would obviously require a PDF viewer cabability (such as Adobe Reader) in the
			browser.
		</para>

        <indexterm startref="term:advanced.printing" class="endofrange"/>
	</section>

	<section xml:id="advanced.portal">
		<title>Portal Integration</title>

        <indexterm xml:id="term.advanced.portal" class="startofrange"><primary>portal integration</primary></indexterm>

		<para>
			Vaadin supports running applications as portlets, as defined in the JSR-168
			(Java Portlet API) and JSR-286 (Java Portlet API 2.0) standards. While
			providing generic support for all portals implementing the standards, Vaadin
			especially supports the Liferay portal and the needed portal-specific
			configuration is given below for Liferay.
		</para>

		<para>
			You can deploy the Vaadin demo package WAR (available from the download site)
			directly to a portal such as Liferay. It contains all the necessary portlet
			configuration files. For optimal performance with Liferay, you can install the
			Vaadin library and other needed resources in Liferay as described later in
			this section.
		</para>

		<para>
			You can find more documentation and examples from the Vaadin Developer's
			Site at <uri>http://dev.vaadin.com/</uri>.
		</para>

		<section>
			<title>Deploying to a Portal</title>

			<para>
				Deploying a Vaadin application as a portlet is essentially just as easy as
				deploying a regular application to an application server. You do not need
				to make any changes to the application itself, but only the following:
			</para>

			<itemizedlist spacing="compact">
				<listitem><para>Application packaged as a WAR</para>
					<itemizedlist spacing="compact" mark="disc">
						<listitem><para><filename>WEB-INF/portlet.xml</filename> descriptor</para></listitem>
						<listitem><para><filename>WEB-INF/web.xml</filename> descriptor for Portlet 1.0 portlets</para></listitem>
						<listitem><para><filename>WEB-INF/liferay-portlet.xml</filename> descriptor for Liferay</para></listitem>
						<listitem><para><filename>WEB-INF/liferay-display.xml</filename> descriptor for Liferay</para></listitem>
						<listitem><para><filename>WEB-INF/liferay-plugin-package.properties</filename> for Liferay</para></listitem>
					</itemizedlist>
				</listitem>

				<listitem>Widget set installed to portal (optional)</listitem>
				<listitem>Themes installed to portal (optional)</listitem>
				<listitem>Vaadin library installed to portal (optional)</listitem>
                <listitem>Portal configuration settings (optional)</listitem>
			</itemizedlist>

			<para>
				Installing the widget set and themes to the portal is required for running
				two or more Vaadin portlets simultaneously in a single portal page. As
				this situation occurs quite easily, we recommend installing them in any
				case.
			</para>

			<para>
				In addition to the Vaadin library, you will need to copy the
				<filename>portlet.jar</filename> to your project. It is included in the
				Vaadin installation package. Notice that you must <emphasis>not</emphasis>
				put the <filename>portlet.jar</filename> in the same
				<filename>WebContent/WEB-INF/lib</filename> directory as the Vaadin JAR or
				otherwise include it in the WAR to be deployed, because it would
				create a conflict with the internal portlet library of the portal.
			</para>

			<para>
				How you actually deploy a WAR package depends on the portal. In Liferay,
				you simply drop it to the <filename>deploy</filename> subdirectory under
				the Liferay installation directory. The deployment depends on the
				application server under which Liferay runs; for example, if you use
				Liferay bundled with Tomcat, you will find the extracted package in the
				<filename>webapps</filename> directory under the Tomcat installation
				directory included in Liferay.
			</para>
		</section>

		<section xml:id="advanced.portal.eclipse">
			<title>Creating a Portal Application Project in Eclipse</title>

			<para>
				While you can create the needed deployment descriptors manually for any
				existing Vaadin application, as described in subsequent sections, the
				Vaadin Plugin for Eclipse provides a wizard for easy creation of portal
				application projects.
			</para>

			<para>
				Creation of a portal application project is almost identical to the
				creation of a regular application project. For a full treatment of the New
				Project Wizard and the possible options, please see <xref
				linkend="getting-started.first-project.creation"/>.
			</para>

			<orderedlist>
				<listitem>
					Start creating a new project by selecting from the menu
					<menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guimenuitem>Project...</guimenuitem></menuchoice>.
				</listitem>

				<?dbfo-need height="8cm" ?>
				<listitem>
					In the <guilabel>New Project</guilabel> window that opens, select
					<menuchoice><guimenu>Web</guimenu><guimenuitem>Vaadin
					Project</guimenuitem></menuchoice> and click
					<guibutton>Next</guibutton>.
				</listitem>

				<?dbfo-need height="8cm" ?>
				<listitem>
					<para>
                        In the <guilabel>Vaadin Project</guilabel> step, you need to set
                        the basic web project settings. You need to give at least the
                        project name, the runtime, and select <guilabel>Generic
                        Portlet</guilabel> for the deployment configuration; the default
                        values should be good for the other settings.
					</para>

					<screenshot>
						<mediaobject>
							<imageobject role="html">
								<imagedata align="center" fileref="img/eclipse/project-new-portlet-1.png"/>
							</imageobject>
							<imageobject role="fo">
								<imagedata scale="70" smallscale="100%" align="center" fileref="img/eclipse/project-new-portlet-1.png"/>
							</imageobject>
						</mediaobject>
					</screenshot>

					<para>You can click <guibutton>Finish</guibutton> here to use the
					defaults for the rest of the settings, or click
					<guibutton>Next</guibutton>.</para>

				</listitem>

				<?dbfo-need height="8cm" ?>
				<listitem>
                    <para>
                        The settings in the <guilabel>Web Module</guilabel> step define
                        the basic servlet-related settings and the structure of the web
                        application project. All the settings are pre-filled, and you
                        should normally accept them as they are and click
                        <guibutton>Next</guibutton>.
					</para>
				</listitem>

				<?dbfo-need height="8cm" ?>
				<listitem>
					<para>
						The <guilabel>Vaadin project</guilabel> step page has various
						Vaadin-specific application settings. These are largely the same
						as for regular applications. You should not need to change
						anything as you can change the application titles and other
						details afterwards. The <guilabel>Create portlet
						template</guilabel> option should be automatically selected. You
						can give another portlet title of you want. You can change most of
						the settings afterward.
					</para>
				
					<screenshot>
						<mediaobject>
							<imageobject role="html">
								<imagedata align="center" fileref="img/eclipse/project-new-portlet-3.png"/>
							</imageobject>
							<imageobject role="fo">
								<imagedata scale="50" smallscale="100%" align="center" fileref="img/eclipse/project-new-portlet-3.png"/>
							</imageobject>
						</mediaobject>
					</screenshot>

                    <variablelist>
						<varlistentry>
							<term><guilabel>Create project template</guilabel></term>
							<listitem>
								<para>
                                    Creates an application class and all the needed
                                    portlet deployment descriptors.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Application name</guilabel></term>
							<listitem>
								<para>
                                    The application name is used in the title of the main
                                    window (which is usually invisible in portlets) and as
                                    an identifier, either as is or with a suffix, in
                                    various deployment descriptors.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Base package name</guilabel></term>
							<listitem>
								<para>
                                    Java package for the application class.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Application class name</guilabel></term>
							<listitem>
								<para>
                                    Name of the application class. The default is derived
                                    from the project name.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Portlet version</guilabel></term>
							<listitem>
								<para>
                                    Same as in the project settings.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Portlet title</guilabel></term>
							<listitem>
								<para>
                                    The portlet title, defined in
                                    <filename>portlet.xml</filename>, can be used as the
                                    display name of the portlet (at least in Liferay). The
                                    default value is the project name. The title is also
                                    used as a short description in
                                    <filename>liferay-plugin-package.properties</filename>.
                                </para>
                            </listitem>
                        </varlistentry>
						<varlistentry>
							<term><guilabel>Vaadin version</guilabel></term>
							<listitem>
								<para>
                                    Same as in the project settings.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>

                    <para>
                        Finally, click <guibutton>Finish</guibutton> to create the project.
                    </para>
				</listitem>

				<listitem>
					<para>
						Eclipse may ask you to switch to J2EE perspective. A Dynamic Web
						Project uses an external web server and the J2EE perspective
						provides tools to control the server and manage application
						deployment. Click <guibutton>Yes</guibutton>.
					</para>
				</listitem>
			</orderedlist>
		</section>

		<section>
			<title>Portlet Deployment Descriptors</title>

			<para>
				To deploy a portlet WAR in a portal, you need to provide the basic
				<filename>portlet.xml</filename> descriptor specified in the Java Portlet
				standard. In addition, you may need to include possible portal vendor
				specific deployment descriptors. The ones required by Liferay are
				described below.
			</para>

			<simplesect>
				<title>Portlet 2.0 Deployment Descriptor</title>

				<para>
					The portlet WAR must include a portlet descriptor located at
					<filename>WebContent/WEB-INF/portlet.xml</filename>. A portlet
					definition includes the portlet name, mapping to a servlet in
					<filename>web.xml</filename>, modes supported by the portlet, and
					other configuration. Below is an example of a simple portlet
					definition in <filename>portlet.xml</filename> descriptor.
				</para>

				<programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;portlet-app
  xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  version="2.0"
  xsi:schemaLocation=
    "http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd
     http://java.sun.com/xml/ns/portlet/portlet-app_2_0.xsd"&gt;

  &lt;portlet&gt;
    &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;
    &lt;display-name&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;

    &lt;!-- Map portlet to a servlet. --&gt;
    &lt;portlet-class&gt;
      com.vaadin.terminal.gwt.server.ApplicationPortlet2
    &lt;/portlet-class&gt;
    &lt;init-param&gt;
      &lt;name&gt;application&lt;/name&gt;

      &lt;!-- The application class with package name. --&gt;
      &lt;value&gt;<emphasis role="bold">com.example.myportlet.MyportletApplication</emphasis>&lt;/value&gt;
    &lt;/init-param&gt;

    &lt;!-- Supported portlet modes and content types. --&gt;
    &lt;supports&gt;
      &lt;mime-type&gt;text/html&lt;/mime-type&gt;
      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;
    &lt;/supports&gt;

    &lt;!-- Not always required but Liferay requires these. --&gt;
    &lt;portlet-info&gt;
      &lt;title&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/title&gt;
      &lt;short-title&gt;<emphasis role="bold">Portlet Example</emphasis>&lt;/short-title&gt;
    &lt;/portlet-info&gt;
  &lt;/portlet&gt;
&lt;/portlet-app&gt;</programlisting>

				<para>
					Listing supported portlet modes in <filename>portlet.xml</filename>
					enables the corresponding portlet controls in the portal user
					interface that allow changing the mode, as described later.
				</para>
            </simplesect>

            <simplesect>
                <title>Portlet 1.0 Deployment Descriptor</title>

                <para>
                    The portlet deployment descriptor for Portlet 1.0 API is largely the
                    same as for Portlet 2.0. The main differences are:
                </para>

                <orderedlist>
                    <listitem><para>XML namespace and schema names</para></listitem>

                    <listitem><para>Portlet-class:
                    <classname>ApplicationPortlet</classname> vs
                    <classname>ApplicationPortlet2</classname></para></listitem>

                    <listitem><para>The <literal>application</literal> parameter is a name
                    of the servlet (defined in <filename>web.xml</filename> in Portlet
                    1.0, but name of the application class in Portlet 2.0. There is no
                    longer a separate <filename>web.xml</filename> file in Servlet
                    2.0.</para></listitem>

                    <listitem><para>The <literal>portlet-name</literal> must not be same
                    as the servlet name in Portlet 1.0; in Portlet 2.0 this does not matter.</para></listitem>

                    <listitem><para></para></listitem>
                </orderedlist>

                <para>
                    Below is an example of a complete deployment descriptor for Portlet 1.0:
                </para>

				<programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;portlet-app
  version="1.0"
  xmlns="http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation=
       "http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd
        http://java.sun.com/xml/ns/portlet/portlet-app_1_0.xsd"&gt;

  &lt;portlet&gt;
    &lt;!-- Must not be the same as servlet name. --&gt;
    &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;
    &lt;display-name&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/display-name&gt;

    &lt;!-- Map portlet to a servlet. --&gt;
    &lt;portlet-class&gt;
      com.vaadin.terminal.gwt.server.ApplicationPortlet
    &lt;/portlet-class&gt;
    &lt;init-param&gt;
      &lt;name&gt;application&lt;/name&gt;

      &lt;!-- Must match the servlet URL mapping in web.xml. --&gt;
      &lt;value&gt;<emphasis role="bold">portletexample</emphasis>&lt;/value&gt;
    &lt;/init-param&gt;

    &lt;!-- Supported portlet modes and content types. --&gt;
    &lt;supports&gt;
      &lt;mime-type&gt;text/html&lt;/mime-type&gt;
      &lt;portlet-mode&gt;view&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;edit&lt;/portlet-mode&gt;
      &lt;portlet-mode&gt;help&lt;/portlet-mode&gt;
    &lt;/supports&gt;

    &lt;!-- Not always required but Liferay requires these. --&gt;
    &lt;portlet-info&gt;
      &lt;title&gt;<emphasis role="bold">Vaadin Portlet Example</emphasis>&lt;/title&gt;
      &lt;short-title&gt;<emphasis role="bold">Portlet Example</emphasis>&lt;/short-title&gt;
    &lt;/portlet-info&gt;
  &lt;/portlet&gt;
&lt;/portlet-app&gt;</programlisting>

				<para>
					The value of the application parameter must match the context in the
					<literal>&lt;url-pattern&gt;</literal> element in the
					<literal>&lt;servlet-mapping&gt;</literal> in the
					<filename>web.xml</filename> deployment descriptor, without the path
					qualifiers in the pattern. The above example would match the following
					servlet mapping in <filename>web.xml</filename>:
				</para>

				<programlisting><?pocket-size 65% ?>  &lt;servlet-mapping&gt;
      &lt;servlet-name&gt;Portlet Example&lt;/servlet-name&gt;
      &lt;url-pattern&gt;/<emphasis role="bold">portletexample</emphasis>/*&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;</programlisting>

				<para>
					In fact, it would also match the <literal>/*</literal> mapping.
				</para>
            </simplesect>

            <simplesect>
                <title>Using a Single Widget Set</title>

                <para>
                    If you have just one Vaadin application that you ever need to run
                    in your portal, you can just deploy the WAR as described above and
                    that's it. However, if you have multiple applications, especially
                    ones that use different custom widget sets, you run into problems,
                    because a portal window can load only a single Vaadin widget set
                    at a time. You can solve this problem by combining all the
                    different widget sets in your different applications into a single
                    widget set using inheritance or composition.
                </para>

                <para>
                    For example, the portal demos defined in the
                    <filename>portlet.xml</filename> in the demo WAR have the following
                    setting for all portlets so that they will all use the same widget
                    set:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[<portlet>
  ...
  <!-- Use the portal default widget set for all portal demos. -->
  <init-param>
    <name>widgetset</name>
    <value>com.vaadin.portal.gwt.PortalDefaultWidgetSet</value>
  </init-param>
  ...]]></programlisting>

                <para>
                    The <classname>PortalDefaultWidgetSet</classname> extends
                    <classname>SamplerWidgetSet</classname>, which extends the
                    <classname>DefaultWidgetSet</classname>. The
                    <classname>DefaultWidgetSet</classname> is therefore essentially a
                    subset of <classname>PortalDefaultWidgetSet</classname>, which
                    contains also the widgets required by the Sampler demo. Other
                    applications that would otherwise require only the regular
                    <classname>DefaultWidgetSet</classname>, and do not define their own
                    widgets, can just as well use the larger set, making them compatible
                    with the demos. The <classname>PortalDefaultWidgetSet</classname> will
                    also be the default Vaadin widgetset bundled in Liferay 5.3 and later.
                </para>

                <para>
                    If your portlets are contained in multiple WARs, which can happen
                    quite typically, you need to install the widget set and theme
                    portal-wide so that all the portlets can use them. See <xref
                    linkend="advanced.liferay.widgetsets"/> on configuring the widget sets
                    in the portal itself.
                </para>
            </simplesect>

			<simplesect xml:id="advanced.liferay.descriptor.liferay-portlet">
				<title>Liferay Portlet Descriptor</title>

                <indexterm xml:id="term.advanced.liferay.descriptor.liferay-portlet.liferay" class="startofrange">
                    <primary>Liferay</primary>
                    <secondary>portlet descriptor</secondary>
                </indexterm>

				<para>
					Liferay requires a special <filename>liferay-portlet.xml</filename>
					descriptor file that defines Liferay-specific parameters. Especially,
					Vaadin portlets must be defined as
					"<emphasis>instanceable</emphasis>", but not
					"<emphasis>ajaxable</emphasis>".
				</para>

				<para>
					Below is an example descriptor for the earlier portlet example:
				</para>

				<programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE liferay-portlet-app PUBLIC
  "-//Liferay//DTD Portlet Application 4.3.0//EN"
  "http://www.liferay.com/dtd/liferay-portlet-app_4_3_0.dtd"&gt;

&lt;liferay-portlet-app&gt;
    &lt;portlet&gt;
        &lt;!-- Matches definition in portlet.xml.          --&gt;
        &lt;!-- Note: Must not be the same as servlet name. --&gt;
        &lt;portlet-name&gt;<emphasis role="bold">Portlet Example portlet</emphasis>&lt;/portlet-name&gt;

        &lt;instanceable&gt;true&lt;/instanceable&gt;
        &lt;ajaxable&gt;false&lt;/ajaxable&gt;
    &lt;/portlet&gt;
&lt;/liferay-portlet-app&gt;</programlisting>

				<para>
					See Liferay documentation for further details on the
					<filename>liferay-portlet.xml</filename> deployment descriptor.
				</para>

                <indexterm startref="term.advanced.liferay.descriptor.liferay-portlet.liferay" class="endofrange"/>
			</simplesect>

			<simplesect xml:id="advanced.liferay.descriptor.display">
				<title>Liferay Display Descriptor</title>
                <indexterm xml:id="term.advanced.liferay.descriptor.liferay-display" class="startofrange">
                    <primary><filename>liferay-display.xml</filename></primary>
                </indexterm>
                <indexterm xml:id="term.advanced.liferay.descriptor.liferay-display.liferay" class="startofrange">
                    <primary>Liferay</primary>
                    <secondary>display descriptor</secondary>
                </indexterm>
				
				<para>
					The <filename>WEB-INF/liferay-display.xml</filename> file defines the portlet
					category under which portlets are located in the <guilabel>Add
					Application</guilabel> window in Liferay. Without this definition,
					portlets will be organized under the "Undefined" category.
				</para>

				<para>
					The following display configuration, which is included in the demo
					WAR, puts the Vaadin portlets under the "Vaadin" category, as shown in
					<xref linkend="figure.advanced.liferay.descriptor.display"/>.
				</para>

				<programlisting><?pocket-size 75% ?><![CDATA[<?xml version="1.0"?>
<!DOCTYPE display PUBLIC
  "-//Liferay//DTD Display 4.0.0//EN"
  "http://www.liferay.com/dtd/liferay-display_4_0_0.dtd">

<display>
    <category name="Vaadin">
        <portlet id="Portlet Example portlet" />
    </category>
</display>]]></programlisting>

				<figure xml:id="figure.advanced.liferay.descriptor.display">
					<title>Portlet Categories in Add Application Window</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/advanced/liferay-display-lo.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/liferay-display-hi.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					See Liferay documentation for further details on how to configure the
					categories in the <filename>liferay-display.xml</filename> deployment
					descriptor.
				</para>

                <indexterm startref="term.advanced.liferay.descriptor.liferay-display" class="endofrange"/>
                <indexterm startref="term.advanced.liferay.descriptor.liferay-display.liferay" class="endofrange"/>
			</simplesect>

            <simplesect>
                <title>Liferay Plugin Package Properties</title>

                <indexterm xml:id="term.advanced.liferay.descriptor.liferay-plugin" class="startofrange">
                    <primary><filename>liferay-plugin-package.xml</filename></primary>
                </indexterm>
                <indexterm xml:id="term.advanced.liferay.descriptor.liferay-plugin.liferay" class="startofrange">
                    <primary>Liferay</primary>
                    <secondary>plugin properties</secondary>
                </indexterm>

                <para>
                    The <filename>liferay-plugin-package.properties</filename> file
                    defines a number of settings for the portlet, most importantly the
                    Vaadin JAR to be used.
                </para>

				<programlisting><?pocket-size 75% ?>name=<emphasis role="bold">Portlet Example portlet</emphasis>
short-description=<emphasis role="bold">myportlet</emphasis>
module-group-id=<emphasis role="bold">Vaadin</emphasis>
module-incremental-version=1
#change-log=
#page-uri=
#author=
license=Proprietary
portal-dependency-jars=\
    <emphasis role="bold">vaadin.jar</emphasis></programlisting>

                <variablelist>
                    <varlistentry>
                        <term><parameter>name</parameter></term>
                        <listitem>
                            <para>
                                The plugin name must match the portlet name.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>short-description</parameter></term>
                        <listitem>
                            <para>
                                A short description of the plugin. This is by default the
                                project name.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>module-group-id</parameter></term>
                        <listitem>
                            <para>
                                The application group, same as the category id defined in
                                <filename>liferay-display.xml</filename>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>license</parameter></term>
                        <listitem>
                            <para>
                                The plugin license type; "proprietary" by default.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>portal-dependency-jars</parameter></term>
                        <listitem>
                            <para>
                                The JAR libraries on which this portlet depends. This should
                                have value <filename>vaadin.jar</filename>, unless you need to
                                use a specific version. The JAR must be installed in the
                                portal, for example, in Liferay bundled with Tomcat to
                                <filename>tomcat-x.x.x/webapps/ROOT/WEB-INF/lib/vaadin.jar</filename>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                
                <indexterm startref="term.advanced.liferay.descriptor.liferay-plugin" class="endofrange"/>
                <indexterm startref="term.advanced.liferay.descriptor.liferay-plugin.liferay" class="endofrange"/>
            </simplesect>
		</section>

		<section xml:id="advanced.liferay.helloworld">
			<title>Portlet Hello World</title>

			<para>
				The Hello World program that runs as a portlet is no different from a
				regular Vaadin application, as long as it doesn't need to handle portlet
				actions, mode changes, and so on.
			</para>

			<programlisting><?pocket-size 75% ?><![CDATA[import com.vaadin.Application;
import com.vaadin.ui.*;

public class PortletExample extends Application {
    @Override 
    public void init() {
        Window mainWindow = new Window("Portlet Example");

        Label label = new Label("Hello Vaadin user");
        mainWindow.addComponent(label);
        setMainWindow(mainWindow);
    }
}]]></programlisting>

			<para>
				In addition to the application class, you need the descriptor files,
				libraries, and other files as described earlier. <xref linkend="figure.advanced.liferay.helloworld.project"/> shows
				the complete project structure under Eclipse.
			</para>

			<figure xml:id="figure.advanced.liferay.helloworld.project" float="center" floatstyle="before">
				<title>Portlet Project Structure in Eclipse</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/liferay-project.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/advanced/liferay-project.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Installed as a portlet in Liferay from the <guilabel>Add
				Application</guilabel> menu, the application will show as illustrated in
				<xref linkend="figure.advanced.liferay.helloworld"/>.
			</para>

			<figure xml:id="figure.advanced.liferay.helloworld">
				<title>Hello World Portlet</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/liferay-helloworld.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/liferay-helloworld.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

		<section xml:id="advanced.liferay.widgetsets">
			<title>Installing Vaadin in Liferay</title>
			
			<para>
				Loading widget sets, themes, and the Vaadin JAR from a portlet is possible
				as long as you have a single portlet, but causes a problem if you have
				multiple portlets. To solve this, Vaadin portlets need to use a globally
				installed widget set, themes, and Vaadin JAR. They, and all the required
				configuration, are bundled with Liferay 5.3 and later, but if you are
				using an earlier version of Liferay or use a custom widget set, custom
				themes, or a specific version of Vaadin, you will need to do the
				configuration manually.
			</para>

			<para>
				In these instructions, we assume that you use Liferay bundled with Apache
				Tomcat, although you can use many other application servers with Liferay
				just as well. The Tomcat installation is included in the Liferay
				installation package, under the <filename>tomcat-x.x.x</filename>
				directory.
			</para>

            <para>
                The Vaadin JAR should be put in
                <filename>tomcat-x.x.x/webapps/ROOT/WEB-INF/lib/vaadin.jar</filename>. The
                Vaadin version number should normally be left out from the JAR.
            </para>

			<para>
				The widget set needs to be located at
				<filename>/html/VAADIN/widgetsets/</filename> and themes at
				<filename>/html/VAADIN/themes/</filename> path under the portal
				context. You simply need to copy the contents from under your
				<filename>WebContent/VAADIN</filename> directory to the
				<filename>tomcat-x.x.x/webapps/ROOT/html/VAADIN</filename> directory under
				the Liferay installation directory. If you use a built-in widget set or
				theme included in Vaadin, such as the
				<classname>PortalDefaultWidgetSet</classname>, you should copy it from the
				Vaadin installation directory, from under
				<filename>WebContent/VAADIN/widgetsets</filename>. The default themes are
				located under <filename>WebContent/VAADIN/themes</filename> in the
				installation directory.
			</para>

			<para>
				You need to define the widget set, the theme, and the JAR in the
				<filename>portal-ext.properties</filename> configuration file for Liferay,
				as described earlier. The file should normally be placed in the Liferay
				installation directory. See Liferay documentation for details on the
				configuration file.
			</para>

			<para>
				Below is an example of a <filename>portal-ext.properties</filename> file:
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[# Path under which the VAADIN directory is located.
# (/html is the default so it is not needed.)
# vaadin.resources.path=/html

# Portal-wide widget set
vaadin.widgetset=com.vaadin.portal.gwt.PortalDefaultWidgetSet

# Theme to use
vaadin.theme=reindeer]]></programlisting>

			<para>
				The allowed parameters are:
			</para>

			<variablelist>
				<varlistentry>
					<term><parameter>vaadin.resources.path</parameter></term>
					<listitem>
						<para>Specifies the resource root path under the portal
						context. This is <filename>/html</filename> by default. Its actual
						location depends on the portal and the application server; in
						Liferay with Tomcat it would be located at
						<filename>webapps/ROOT/html</filename> under the Tomcat
						installation directory.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><parameter>vaadin.widgetset</parameter></term>
					<listitem>
						<para>The widget set class to use. Give the full path to the class
						name in the dot notation. If the parameter is not given, the
						default widget set is used.</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><parameter>vaadin.theme</parameter></term>
					<listitem>
						<para>Name of the theme to use. If the parameter is not given, the
						default theme is used, which is <literal>reindeer</literal> in
						Vaadin 6.</para>
					</listitem>
				</varlistentry>
			</variablelist>
	
			<para>
				You will need to restart Liferay after creating or modifying the
				<filename>portal-ext.properties</filename> file.
			</para>
		</section>

		<section>
			<title>Handling Portlet Requests</title>

			<para>
				Portals such as Liferay are not AJAX applications but reload the page
				every time a user interaction requires data from the server. They consider
				a Vaadin application to be a regular web application that works by HTTP
				requests. All the AJAX communications required by the Vaadin application
				are done by the Vaadin Client-Side Engine (the widget set) past the
				portal, so that the portal is unaware of the communications.
			</para>

			<para>
				The only way a portal can interact with an application is to load it with
				a HTTP request; reloading does not reset the application. The Portlet 2.0
				API supports four types of requests: <emphasis>render</emphasis>,
				<emphasis>action</emphasis>, <emphasis>resource</emphasis>, and
				<emphasis>event</emphasis> requests. The old Portlet 1.0 API supports only
				the render and action requests. Requests can be caused by user interaction
				with the portal controls or by clicking action URLs displayed by the
				portlet. You can handle portlet requests by implementing the
				<classname>PortletListener</classname> interface and the handler methods
				for each of the request types. You can use the request object passed to
				the handler to access certain portal data, such as user information, the
				portlet mode, etc.
			</para>

            <para>
                The <classname>PortletListener</classname> interface is defined in the
                <classname>PortletApplicationContext2</classname> for Portlet 2.0 API and
                <classname>com.vaadin.terminal.gwt.server.PortletApplicationContext</classname>
                class for the old Portlet 1.0 API. You can get the portlet application
                context with <methodname>getContext()</methodname> method of the
                application class.
            </para>

            <para>
                You need to have the <filename>portlet.jar</filename> in your class path
                during development. However, you must <emphasis>not</emphasis> deploy the
                <filename>portlet.jar</filename> with the portlet, because it would create
                a conflict with the internal portlet library of the portal. You should put
                it in a directory that is not deployed with the portlet, for example, if
                you are using Eclipse, under the <filename>lib</filename> directory under
                the project root, not under <filename>WebContent/WEB-INF/lib</filename>,
                for example.
            </para>

			<para>
				You can also define portal actions that you can handle in the
				<methodname>handleActionRequest()</methodname> method of the interface.
			</para>

			<para>
				You add your portlet request listener to the application context of your
				application, which is a <classname>PortletApplicationContext</classname>
				when (and only when) the application is being run as a portlet.
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[// Check that we are running as a portlet.
if (getContext() instanceof PortletApplicationContext2) {
    PortletApplicationContext2 ctx =
            (PortletApplicationContext2) getContext();

    // Add a custom listener to handle action and
    // render requests.
    ctx.addPortletListener(this, new MyPortletListener());
} else {
    getMainWindow().showNotification(
            "Not initialized via Portal!",
            Notification.TYPE_ERROR_MESSAGE);
}]]></programlisting>

			<para>
				The handler methods receive references to request and response objects,
				which are defined in the Java Servlet API. Please refer to the Servlet API
				documentation for further details.
			</para>

			<para>
				The PortletDemo application included in the demo WAR package includes
				examples of processing mode and portlet window state changes in a portlet
				request listener.
			</para>
		</section>

        <section xml:id="advanced.portal.portlet-mode">
            <title>Handling Portlet Mode Changes</title>

            <para>
                Portals support three portlet modes defined in the Portlet API:
                <emphasis>view</emphasis>, <emphasis>edit</emphasis>, and
                <emphasis>help</emphasis> modes. The <emphasis>view</emphasis> mode is the
                default and the portal can have buttons to switch the portlet to the other
                modes. In addition to the three predefined modes, the Portlet API
                standards allow custom portlet modes, although portals may support custom
                modes to a varying degree.
            </para>

            <para>
                You need to define which portlet modes are enabled in the
                <filename>portlet.xml</filename> deployment descriptor as follows.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[<!-- Supported portlet modes and content types. -->
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>edit</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>

            <para>
                Changes in the portlet mode are received as resource requests, which you
                can handle with a <methodname>handleResourceRequest()</methodname>,
                defined in the <classname>PortletListener</classname> interface. The
                current portlet mode can be acquired with
                <methodname>getPortletMode()</methodname> from the request object.
            </para>

            <para>
                The following complete example (for Portlet 2.0) shows how to handle the
                three built-modes in a portlet application.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
import com.vaadin.terminal.gwt.server.PortletApplicationContext2;
import com.vaadin.terminal.gwt.server.PortletApplicationContext2.PortletListener;

public class PortletModeExample extends Application
                                implements PortletListener {
    Window         mainWindow;
    ObjectProperty data; // Data to view and edit
    VerticalLayout viewContent   = new VerticalLayout();
    VerticalLayout editContent   = new VerticalLayout();
    VerticalLayout helpContent   = new VerticalLayout();
    
    @Override
    public void init() {
        mainWindow = new Window("Myportlet Application");
        setMainWindow(mainWindow);

        // Data model
        data = new ObjectProperty("<h1>Heading</h1>"+
                       "<p>Some example content</p>");

        // Prepare views for the three modes (view, edit, help)
        // Prepare View mode content
        Label viewText = new Label(data, Label.CONTENT_XHTML);
        viewContent.addComponent(viewText);

        // Prepare Edit mode content
        RichTextArea editText = new RichTextArea();
        editText.setCaption("Edit the value:");
        editText.setPropertyDataSource(data);
        editContent.addComponent(editText);

        // Prepare Help mode content
        Label helpText = new Label("<h1>Help</h1>" +
                                   "<p>This helps you!</p>",
                                   Label.CONTENT_XHTML);
        helpContent.addComponent(helpText);

        // Start in the view mode
        mainWindow.setContent(viewContent);

        // Check that we are running as a portlet.
        if (getContext() instanceof PortletApplicationContext2) {
            PortletApplicationContext2 ctx =
                (PortletApplicationContext2) getContext();

            // Add a custom listener to handle action and
            // render requests.
            ctx.addPortletListener(this, this);
        } else {
            mainWindow.showNotification("Not running in portal",
                               Notification.TYPE_ERROR_MESSAGE);
        }
    }

    // Dummy implementations for the irrelevant request types
    public void handleActionRequest(ActionRequest request,
                                    ActionResponse response,
                                    Window window) {
    }
    public void handleRenderRequest(RenderRequest request,
                                    RenderResponse response,
                                    Window window) {
    }
    public void handleEventRequest(EventRequest request,
                                   EventResponse response,
                                   Window window) {
    }

    public void handleResourceRequest(ResourceRequest request,
                                      ResourceResponse response,
                                      Window window) {
        // Switch the view according to the portlet mode
        if (request.getPortletMode() == PortletMode.EDIT)
            window.setContent(editContent);
        else if (request.getPortletMode() == PortletMode.VIEW)
            window.setContent(viewContent);
        else if (request.getPortletMode() == PortletMode.HELP)
            window.setContent(helpContent);
    }
}]]></programlisting>

            <para>
                <xref linkend="figure.advanced.portal.portlet-mode"/> shows the resulting
                portlet in the three modes: view, edit, and help. In Liferay, the edit
                mode is shown in the popup menu as a <guilabel>Preferences</guilabel> item.
            </para>

            <figure xml:id="figure.advanced.portal.portlet-mode">
                <title>Portlet Modes in Action</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/portal-mode-view.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-view.png"/>
                    </imageobject>
                </mediaobject>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/portal-mode-edit.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-edit.png"/>
                    </imageobject>
                </mediaobject>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/portal-mode-help.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/portal-mode-help.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="advanced.portal.portlet-html-mode">
            <title>Non-Vaadin Portlet Modes</title>

            <para>
                In some cases, it can be useful to implement certain modes of a portlet
                as pure HTML or JSP pages instead of running the full Vaadin application
                user interface in them. Common reasons for this are static
                pages (e.g. a simple help mode), integrating legacy content to a portlet
                (e.g. a JSP configuration interface) and providing an ultra-lightweight
                initial view for a portlet (for users behind slow connections).
            </para>
            
            <para>
                Fully static modes that do not require the Vaadin server side
                application to be running can be implemented by subclassing the portlet
                class <classname>ApplicationPortlet2</classname> (Portlet 2.0).
                The subclass can either create the HTML content directly or dispatch
                the request to e.g. a HTML or JSP page via the portal. When using
                this approach, any Vaadin portlet and portlet request listeners are not
                called.
            </para>
            
            <para>
                Customizing the content for the standard modes
                (<emphasis>view</emphasis>, <emphasis>edit</emphasis>, and
                <emphasis>help</emphasis>) can be performed by overriding the methods
                <methodname>doView</methodname>, <methodname>doEdit</methodname>
                and <methodname>doHelp</methodname>, respectively. Custom modes
                can be handled by implementing similar methods with the
                <classname>@javax.portlet.RenderMode(name = "mymode")</classname>
                annotation.
            </para>

            <para>
                You need to define which portlet modes are enabled in the
                <filename>portlet.xml</filename> deployment descriptor as described in
                <xref linkend="advanced.portal.portlet-mode"/>. Also, the portlet class
                in <filename>portlet.xml</filename> should point to the customized
                subclass of <classname>ApplicationPortlet2</classname>.
            </para>

            <para>
                The following example (for Portlet 2.0) shows how to create a static
                help page for the portlet.
            </para>
            
            <para>
            	<filename>portlet.xml</filename>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[<!-- Supported portlet modes and content types. -->
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>
            
            <para>
            	<filename>HtmlHelpPortlet.java:</filename>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
import com.vaadin.terminal.gwt.server.ApplicationPortlet2;

public class HtmlHelpPortlet extends ApplicationPortlet2 {

    // override the help mode, let the Vaadin application handle the view mode
    @Override
    protected void doHelp(RenderRequest request, RenderResponse response)
            throws PortletException, IOException {
        // bypass the Vaadin application entirely
        response.setContentType("text/html");
        response.getWriter().println("This is the help text as plain HTML.");

        // alternatively could use the dispatcher for e.g. JSP help pages:
        // PortletRequestDispatcher dispatcher = getPortletContext()
        // .getRequestDispatcher("/html/myhelp.jsp");
        // dispatcher.include(request, response);
    }
}]]></programlisting>

            <para>
                To produce pure HTML portlet content from a running Vaadin application
                instead of statically outside an application, the
                <classname>ApplicationPortlet2</classname> method
                <methodname>writeAjaxPage</methodname> should be overridden.
                This approach allows using the application state in HTML content
                generation, and all relevant Vaadin portlet request and portlet
                listeners are called around the portlet content generation. However,
                the client side engine (widgetset) is not loaded by the browser,
                which can shorten the initial page display time.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[<portlet-class>com.vaadin.demo.portlet.HtmlModePortlet</portlet-class>
<supports>
    <mime-type>text/html</mime-type>
    <portlet-mode>view</portlet-mode>
    <portlet-mode>help</portlet-mode>
</supports>]]></programlisting>

            <programlisting><?pocket-size 65% ?><![CDATA[public class CountApplication extends Application {
    private int count = 0;
    
    public void init() {
        Window window = new Window("Portlet mode example");
        window.addComponent(new Label("This is the Vaadin application."));
        window.addComponent(new Label("Try opening the help mode."));
        setMainWindow(window);
    }
        
    public int incrementCount() {
        return ++count;
    }
}]]></programlisting>

            <programlisting><?pocket-size 65% ?><![CDATA[// Use Portlet 2.0 API
public class HtmlModePortlet extends AbstractApplicationPortlet {

    @Override
    protected void writeAjaxPage(RenderRequest request,
            RenderResponse response, Window window,
            Application application) throws PortletException, IOException {
        if (PortletMode.HELP.equals(request.getPortletMode())) {
            CountApplication app = (CountApplication) application;
            response.setContentType("text/html");
            response.getWriter().println("This is the HTML help, shown "
                + app.incrementCount() + " times so far.");
        } else {
            super.writeAjaxPage(request, response, window, application);
        }
    }
    
    @Override
    protected Class<? extends Application> getApplicationClass() {
        return CountApplication.class;
    }
    
}]]></programlisting>

            <para>
            	The user can freely move between Vaadin and non-Vaadin portlet
            	modes with the user interface provided by the portal (for
            	standard modes) or the portlet (e.g. action links). Once the
            	server side application has been started, it continues to run
            	as long as the session is alive.
            	If necessary, specific portlet mode transitions can be
            	disallowed in <filename>portlet.xml</filename>.
            </para>

            <para>
                In the case of Portlet 1.0, both a portlet and a servlet are involved.
                A render request is received by
                <classname>ApplicationPortlet</classname> when the portlet mode is
                changed, and serving pure HTML in some modes can be achieved by
                overriding the method <methodname>render</methodname> and handling
                the modes of interest separately while calling
                <methodname>super.render()</methodname> for other modes. As always,
                when extending the portlet, the reference to the portlet class in
                <filename>portlet.xml</filename> needs to be updated.
            </para>
            
            <para>
                To serve HTML-only content in the Portlet 1.0 case after starting the
                server side application and calling the relevant listeners, the servlet
                class <classname>ApplicationServlet</classname> should be subclassed
                instead of the portlet. The method
                <methodname>writeAjaxPage</methodname> can be overridden to produce
                custom HTML content for certain modes. However, it should be noted
                that some HTML content (e.g. loading the portal-wide Vaadin theme) is
                created by the portlet and not the servlet.
            </para>

        </section>

        <indexterm startref="term.advanced.portal" class="endofrange"/>
    </section>

	<section xml:id="advanced.gae">
		<title>Google App Engine Integration</title>

		<para>
			Vaadin includes support to run Vaadin applications in the Google App Engine
			(GAE). The most essential requirement for GAE is the ability to serialize the
			application state. Vaadin applications are serializable through the
			<classname>java.io.Serializable</classname> interface.
		</para>

		<para>
			To run as a GAE application, an application must use
			<classname>GAEApplicationServlet</classname> instead of
			<classname>ApplicationServlet</classname> in <filename>web.xml</filename>, and
			of course implement the <classname>java.io.Serializable</classname> interface
			for all persistent classes.  You also need to enable session support in
			<filename>appengine-web.xml</filename> with:
		</para>
		
		<programlisting><![CDATA[<sessions-enabled>true</sessions-enabled>]]></programlisting>

		<para>
			The Vaadin Project wizard can create the configuration files needed for GAE
			deployment. See <xref linkend="getting-started.first-project.creation"/>. When
			the Google App Engine deployment configuration is selected, the wizard will
			create the project structure following the GAE Servlet convention instead of
			the regular Servlet convention. The main differences are:
		</para>

		<itemizedlist>
			<listitem>Source directory: <filename>src/main/java</filename></listitem>
			<listitem>Output directory: <filename>war/WEB-INF/classes</filename></listitem>
			<listitem>Content directory: <filename>war</filename></listitem>
		</itemizedlist>

		<simplesect>
			<title>Rules and Limitations</title>

			<para>
				Running Vaadin applications in Google App Engine has the following rules
				and limitations:
			</para>
			
			<itemizedlist>
				<listitem><para>Avoid using the session for storage, usual App Engine
				limitations apply (no synchronization, that is, it is
				unreliable).</para></listitem>

				<listitem><para>Vaadin uses memcache for mutex, the key is of the form
				<parameter>_vmutex&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para>The Vaadin <classname>WebApplicationContext</classname>
				class is serialized separately into memcache and datastore; the memcache
				key is <parameter>_vac&lt;sessionid&gt;</parameter> and the datastore
				entity kind is <parameter>_vac</parameter> with identifiers of the type
				<parameter>_vac&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para><emphasis>Do not</emphasis> update the application state when serving an
				<classname>ApplicationResource</classname> (such as
				<classname>ClassResource</classname>.<methodname>getStream()</methodname>).</para></listitem>

				<listitem><para><emphasis>Avoid</emphasis> (or be very careful when)
				updating application state in a <classname>TransactionListener</classname>
				- it is called even when the application is not locked and won't be
				serialized (such as with <classname>ApplicationResource</classname>), and
				changes can therefore be lost (it should be safe to update things that can
				be safely discarded later, that is, valid only for the current
				request).</para></listitem>

				<listitem><para>The application remains locked during uploads - a progress
				bar is not possible.</para></listitem>
			</itemizedlist>
		</simplesect>
	</section>

	<section xml:id="advanced.security">
		<title>Common Security Issues</title>

		<section xml:id="advanced.security.sanitizing">
			<title>Sanitizing User Input to Prevent Cross-Site Scripting</title>
			
			<para>
				You can put raw XHTML content in many components, such as the
				<classname>Label</classname> and <classname>CustomLayout</classname>, as
				well as in tooltips and notifications. In such cases, you should make sure
				that if the content has any possibility to come from user input, the input
				is well sanitized before displaying it. Otherwise, a malicious user can
				easily make a cross-site scripting attack by injecting offensive
				JavaScript code in such components.
			</para>

			<para>
				Offensive code can easily be injected with
				<literal>&lt;script&gt;</literal> markup or in tag attributes as events,
				such as <parameter>onLoad</parameter>. Cross-site scripting
				vulnerabilities are browser dependent, depending on the situations in
				which different browsers execute scripting markup.
			</para>

			<para>
				There is no generic way to sanitize user input as different applications
				can allow different kinds of input. Pruning (X)HTML tags out is somewhat
				simple, but some applications may need to allow (X)HTML.  It is therefore
				the responsibility of the application to sanitize the input.
			</para>

			<para>
				Character encoding can make sanitization more difficult, as offensive tags
				can be encoded so that they are not recognized by a sanitizer. This can be
				done, for example, with HTML character entities and with variable-width
				encodings such as UTF-8 or various CJK encodings, by abusing multiple
				representations of a character. Most trivially, you could input
				<literal>&lt;</literal> and <literal>&gt;</literal> with
				<literal>&amp;lt;</literal> and <literal>&amp;gt;</literal>,
				respectively. The input could also be malformed and the sanitizer must be
				able to interpret it exactly as the browser would, and different browsers
				can interpret malformed HTML and variable-width character encodings
				differently.
			</para>

			<para>
				Notice that the problem applies also to user input from a
				<classname>RichTextArea</classname> is transmitted as XHTML from the
				browser to server-side and is not sanitized. As the entire purpose of the
				<classname>RichTextArea</classname> component is to allow input of
				formatted text, you can not just remove all HTML tags. Also many
				attributes, such as <parameter>style</parameter>, should pass through the
				sanitization.
			</para>

			<!-- NOTE: Document the rude HTML sanitization method when #3382 is closed. -->
		</section>
	</section>

	<section xml:id="advanced.urifu">
		<title>URI Fragment and History Management with <classname>UriFragmentUtility</classname></title>

        <para>
            A major issue in AJAX applications is that as they run in a single web page,
            bookmarking the application URL (or more generally the
            <emphasis>URI</emphasis>) can only bookmark the application, not an
            application state. This is a problem for many applications such as product
            catalogs and forums, in which it would be good to provide links to specific
            products or messages. Consequently, as browsers remember the browsing history
            by URI, the history and the <guibutton>Back</guibutton> button do not normally
            work. The solution is to use the <emphasis>fragment</emphasis> part of the
            URI, which is separated from the primary part (address + path + optional query
            parameters) of the URI with the hash (#) character. For example:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[http://example.com/path#myfragment]]></programlisting>

        <para>
            The exact syntax of the fragment part is defined in RFC 3986 (Internet
            standard STD 66) that defines the URI syntax. A fragment may only contain the
            regular URI <emphasis>path characters</emphasis> (see the standard) and
            additionally the slash and the question mark.
        </para>

        <para>
            The <classname>UriFragmentUtility</classname> is a special-purpose component
            that manages the URI fragment; it allows setting the fragment and to handle
            user-made changes to it. As it is a regular component, though invisible, you
            must add it to a layout in an application window with the
            <methodname>addComponent()</methodname>, as usual.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    Window main = new Window("URI Fragment Example");
    setMainWindow(main);

    // Create the URI fragment utility
    final UriFragmentUtility urifu = new UriFragmentUtility();
    main.addComponent(urifu);]]></programlisting>

        <para>
            Notice that the utility component can work only when it is attached to the
            window, so in practice it must be added in the <methodname>init()</methodname>
            method of the application and must afterwards always remain in the
            application's user interface.
        </para>

        <para>
            You can set the URI fragment with the <methodname>setFragment()</methodname>
            method of the <classname>UriFragmentUtility</classname> object. The method takes the
            fragment as a string parameter. In the following example, we have a menu, from
            which the user can select the URI fragment.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Application state menu
final ListSelect menu = new ListSelect("Select a URI Fragment");
menu.addItem("mercury");
menu.addItem("venus");
menu.addItem("earth");
menu.addItem("mars");
menu.setImmediate(true);
main.addComponent(menu);

// Set the URI Fragment when menu selection changes
menu.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        String itemid = (String) event.getProperty().getValue();
        urifu.setFragment(itemid);
    }
});]]></programlisting>

        <para>
            The URI fragment and any changes to it are passed to an application as
            <classname>FragmentChangedEvent</classname>s, which you can handle with a
            <classname>FragmentChangedListener</classname>. You can get the new fragment
            value with the <methodname>getFragment()</methodname> method from the URI
            fragment utility component.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// When the URI fragment is given, use it to set menu selection 
urifu.addListener(new FragmentChangedListener() {
    public void fragmentChanged(FragmentChangedEvent source) {
        String fragment =
                  source.getUriFragmentUtility().getFragment();
        if (fragment != null)
            menu.setValue(fragment);
    }
});]]></programlisting>

        <para>
            <xref linkend="figure.advanced.urifu"/> shows an application that allows
            specifying the menu selection with a URI fragment and correspondingly sets the
            fragment when the user selects a menu item, as done in the code examples
            above.
        </para>

        <figure xml:id="figure.advanced.urifu">
            <title>Application State Management with URI Fragment Utility</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

    <section xml:id="advanced.httpservletrequestlistener">
        <title>Capturing HTTP Requests</title>

        <indexterm xml:id="term:advanced.httpservletrequestlistener" class="startofrange">
            <primary>HttpServletRequestListener</primary>
        </indexterm>

        <para>
            Behind the event-driven processing model of Vaadin lies the Java Servlet API,
            which is based on processing HTTP requests. These requests are normally
            hidden from Vaadin applications, but can be caught using the
            <classname>HttpServletRequestListener</classname> interface. You must
            implement the interface in your application class. The two methods defined in
            the interface, <methodname>onRequestStart()</methodname> and
            <methodname>onRequestEnd()</methodname>, allow processing the request before
            and after other processing.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.vaadin.Application;
import com.vaadin.terminal.gwt.server.HttpServletRequestListener;
import com.vaadin.ui.*;

public class HttpServletRequestApplication extends Application
       implements HttpServletRequestListener {

    @Override
    public void init() {
        System.out.println("  Application.init() called.");
        
        Window main = new Window("URI Fragment Example");
        setMainWindow(main);
        setTheme("book-examples");
                
        // Does nothing but causes a request
        Button button = new Button ("Make a request");
        main.addComponent(button);
    }

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        System.out.println("[Start of request");
        System.out.println(" Query string: " +
                           request.getQueryString());
        System.out.println(" Path: " +
                           request.getPathInfo());
    }

    public void onRequestEnd(HttpServletRequest request,
                             HttpServletResponse response) {
        System.out.println(" End of request]");
    }
}]]></programlisting>

        <para>
            The <methodname>onRequestStart()</methodname> is called for the first time
            when the application class is loaded but the <methodname>init()</methodname>
            is not yet called. This can be seen in the output of the above code example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[[Start of request
 Query string: null
 Path: null
  Application.init() called.
 End of request]
[Start of request
 Query string: repaintAll=1&sh=1050&sw=1680&cw=500&ch=300&vw=500
 Path: /UIDL/
 End of request]
[Start of request
 Query string: windowName=1071684214
 Path: /UIDL/
 End of request]]]></programlisting>

        <para>
            The first call is a regular HTML page load, so the URL path is simply the
            application path. The subsequent calls are AJAX calls made using the UIDL
            protocol, so the request path includes the <literal>/UIDL/</literal> part. This is
            important to know when using cookies, as explained later.
        </para>

        <section>
            <title>Using Request and Response Objects</title>

            <indexterm xml:id="term:advanced.httpservletrequestlistener.httpservletrequest" class="startofrange">
                <primary>HttpServletRequest</primary>
            </indexterm>
            <indexterm xml:id="term:advanced.httpservletrequestlistener.httpservletresponse" class="startofrange">
                <primary>HttpServletResponse</primary>
            </indexterm>
            
            <para>
                The <classname>HttpServletRequest</classname> object provides access to
                the request data, such as request headers, path info, and query string, as
                well as to some higher-level information such as cookies.
            </para>

            <para>
                The <classname>HttpServletResponse</classname> object is somewhat
                different, as most write operations write data directly to the output
                stream of the server request. It is therefore possible to add new headers
                and cookies in the <methodname>onRequestStart()</methodname>, and make
                other settings, but not later on, especially not in the
                <methodname>onRequestEnd()</methodname>, as all the UIDL response data has
                already been written to the output stream. The framework writes the UIDL
                response to the output stream of the response <emphasis>before</emphasis>
                calling <methodname>onRequestEnd()</methodname>. You therefore have to be
                careful when writing to the response object. You can usually write to it
                when handling component events in listeners, as is done in the cookie
                example later.
            </para>

            <para>
                While it is theoretically possible to redirect the output stream of the
                response object to write custom data to the response, you should never
                need to do that, as it would break the UIDL communication protocol.
            </para>
        
            <para>
                The servlet request and response objects are defined in the Java Servlet
                API. Please refer to its documentation for more detailed information.
            </para>

            <indexterm startref="term:advanced.httpservletrequestlistener.httpservletrequest" class="endofrange"/>
            <indexterm startref="term:advanced.httpservletrequestlistener.httpservletresponse" class="endofrange"/>
        </section>

        <section>
            <title>Managing Cookies</title>

            <indexterm xml:id="term:advanced.httpservletrequestlistener.cookies" class="startofrange">
                <primary>cookies</primary>
            </indexterm>

            <para>
                Setting and reading cookies is one of the typical uses of
                <classname>HttpServletRequestListener</classname>. The application gets
                the <classname>HttpServletRequest</classname> object containing the
                cookies in the <methodname>onRequestStart()</methodname> method.
            </para>

            <section>
                <title>Setting a Cookie</title>

                <para>
                    You normally set a cookie in an event listener. As the request object
                    is a transient object that exists only for the duration of the
                    request, it is not accessible from the
                    <classname>Application</classname> object. The only way to access it
                    is to store it in <methodname>onRequestStart()</methodname>, as done
                    in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    HttpServletResponse response;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        // Store the reference to the response object for
        // using it in event listeners
        this.response = response;
        ...
   }
   ...]]></programlisting>

                <para>
                    We can then use the reference to set or delete cookies in event
                    listeners. Notice that the <emphasis>cookie path</emphasis> property
                    is automatically set to the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent calls
                    (such as <filename>/book-examples/cookies/UIDL</filename>). As the
                    cookies are matched against this path, you may need to set the path
                    explicitly with <methodname>setPath()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[newuser = new TextField ("Give a user name");
login = new Button("Login");
login.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        Object value = newuser.getValue(); 
        if (value != null &&
            !((String)value).equals("")) {
            username = (String) value;

            Cookie cookie = new Cookie("username",
                                       username);
            // Use a fixed path
            cookie.setPath("/book-examples");
            cookie.setMaxAge(3600); // One hour
            response.addCookie(cookie);
            System.out.println("Set cookie.");

            newuser.setEnabled(false);
            login.setEnabled(false);
            restart.setEnabled(true);
            logout.setEnabled(true);
        }
    }
});
loginrow.addComponent(newuser);
loginrow.addComponent(login);]]></programlisting>

                <para>
                    Removing cookie can be set in similar way by setting the
                    <emphasis>maxAge</emphasis> property to zero.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Delete the cookie
Cookie cookie = new Cookie("username", username);
cookie.setPath("/book-examples");
cookie.setMaxAge(0); // Delete
response.addCookie(cookie);]]></programlisting>
            </section>

            <section>
                <title>Reading a Cookie</title>

                <para>
                    Reading a cookie can be done in the
                    <methodname>onRequestStart()</methodname> event. As this method is
                    called also on the first client request before the application is
                    initialized, it is possible to read user identification cookies and
                    such on the first request.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    String username;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        if (username == null) {
            Cookie[] cookies = request.getCookies();
            for (int i=0; i<cookies.length; i++) {
                if (cookies[i].getName().equals("username"))
                    // Log the user in automatically
                    username = cookies[i].getValue();
            }
        }
    }
    ...]]></programlisting>

                <para>
                    Notice that the request path is the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent AJAX
                    calls (such as <filename>/book-examples/cookies/UIDL</filename>). So,
                    if you have set the cookie in an AJAX request without setting the
                    cookie path explicitly to such that does not contain the
                    <filename>UIDL</filename> subpath, the cookie will be filtered out on
                    the initial <methodname>onRequestStart()</methodname> call.
                </para>
            </section>

            <indexterm startref="term:advanced.httpservletrequestlistener.cookies" class="endofrange"/>
        </section>

        <indexterm startref="term:advanced.httpservletrequestlistener" class="endofrange"/>
    </section>

    <section xml:id="advanced.dragndrop">
        <title>Drag and Drop</title>

        <indexterm xml:id="term:advanced.dragndrop" class="startofrange">
            <primary>Drag and Drop</primary>
        </indexterm>

        <para>
            Dragging an object from one location to another by grabbing it with mouse,
            holding the mouse button pressed, and then releasing the button to "drop" it
            to the other location is a common way to move, copy, or associate objects. For
            example, most operating systems allow dragging and dropping files between
            folders or dragging a document on a program to open it. In Vaadin, it is
            possible to drag and drop components and parts of certain components.
        </para>

        <para>
            Dragged objects, or <emphasis>transferables</emphasis>, are essentially data
            objects. You can drag and drop rows in <classname>Table</classname> and nodes
            in <classname>Tree</classname> components, either within or between the
            components. You can also drag entire components by wrapping them inside
            <classname>DragAndDropWrapper</classname>.
        </para>

        <para>
            Dragging starts from a <emphasis>drag source</emphasis>, which defines the
            transferable. Transferables implement the <classname>Transferable</classname>
            interfaces. For trees and tables, which are bound to
            <classname>Container</classname> data sources, a node or row transferable is a
            reference to an <classname>Item</classname> in the Vaadin Data Model. Dragged
            components are referenced with a
            <classname>WrapperTransferable</classname>. Starting dragging does not require
            any client-server communication, you only need to enable dragging. All drag
            and drop logic occurs in two operations: determining
            (<emphasis>accepting</emphasis>) where dropping is allowed and actually
            dropping. Drops can be done on a <emphasis>drop target</emphasis>, which
            implements the <classname>DropTarget</classname> interface. Three components
            implement the interface: <classname>Tree</classname>,
            <classname>Table</classname>, and
            <classname>DragAndDropWrapper</classname>. These accept and drop operations
            need to be provided in a <emphasis>drop handler</emphasis>. Essentially all
            you need to do to enable drag and drop is to enable dragging in the drag
            source and implement the <methodname>getAcceptCriterion()</methodname> and
            <methodname>drop()</methodname> methods in the
            <classname>DropHandler</classname> interface.
        </para>

        <para>
            The client-server architecture of Vaadin causes special requirements for the
            drag and drop functionality. The logic for determining where a dragged object
            can be dropped, that is, <emphasis>accepting</emphasis> a drop, should
            normally be done on the client-side, in the browser. Server communications are
            too slow to have much of such logic on the server-side. The drag and drop
            feature therefore offers a number of ways to avoid the server communications
            to ensure a good user experience.
        </para>

        <section xml:id="advanced.dragndrop.drophandler">
            <title>Handling Drops</title>

            <para>
                Most of the user-defined drag and drop logic occurs in a <emphasis>drop
                handler</emphasis>, which is provided by implementing the
                <methodname>drop()</methodname> method in the
                <classname>DropHandler</classname> interface. A closely related definition
                is the drop accept criterion, which is defined in the
                <methodname>getAcceptCriterion()</methodname> method in the same
                interface. It is described in <xref
                linkend="advanced.dragndrop.acceptcriteria"/> later.
            </para>

            <para>
                The <methodname>drop()</methodname> method gets a
                <classname>DragAndDropEvent</classname> as its parameters. The event
                object provides references to two important object:
                <classname>Transferable</classname> and
                <classname>TargetDetails</classname>.
            </para>

            <para>
                A <classname>Transferable</classname> contains a reference to the object
                (component or data item) that is being dragged. A tree or table item is
                represented as a <classname>TreeTransferable</classname> or
                <classname>TableTransferable</classname> object, which carries the item
                identifier of the dragged tree or table item. These special transferables,
                which are bound to some data in a container, are
                <classname>DataBoundTransferable</classname>. Dragged components are
                represented as <classname>WrapperTransferable</classname> objects, as the
                components are wrapped in a <classname>DragAndDropWrapper</classname>.
            </para>

            <para>
                The <classname>TargetDetails</classname> object provides details
                regarding the exact location where the transferable object is being
                dropped. If the target is a tree or a table, the
                <classname>TreeTargetDetails</classname> and
                <classname>TableTargetDetails</classname> objects provide the tree or
                table item on which the drop is being made. For entire components, the
                information is provided in a <classname>WrapperDropDetails</classname>
                object. In addition to the target item or component, the details objects
                provide a <emphasis>drop location</emphasis>. For selection components,
                the location can be obtained with the
                <methodname>getDropLocation()</methodname> and for wrapped components with
                <methodname>verticalDropLocation()</methodname> and
                <methodname>horizontalDropLocation()</methodname>. The locations are
                specified as either <classname>VerticalDropLocation</classname> or
                <classname>HorizontalDropLocation</classname> objects. The drop location
                objects specify whether the transferable is being dropped above, below, or
                directly on (at the middle of) a component or item.
            </para>

            <para>
                Dropping on a <classname>Tree</classname>, <classname>Table</classname>,
                and a wrapped component is explained further in the following sections.
            </para>
        </section>

        <section xml:id="advanced.dragndrop.treedrop">
            <title>Dropping Items On a <classname>Tree</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Tree</classname>. Making tree a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Tree</classname>
                currently supports only one drag mode,
                <literal>TreeDragMode.NODE</literal>, which allows dragging single tree
                nodes. While dragging, the dragged node is referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. The tree node is identified
                by the item ID of the container item.
            </para>

            <para>
                When a transferable is dropped on a tree, the drop location is stored in a
                <classname>TreeTargetDetails</classname> object, which identifies the
                target location by item ID of the tree node on which the drop is made. You
                can get the item ID with <methodname>getItemIdOver()</methodname> method
                in <classname>AbstractSelectTargetDetails</classname>, which the
                <classname>TreeTargetDetails</classname> inherits. A drop can occur
                directly on or above or below a node; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method.
            </para>

            <para>
                In the example below, we have a <classname>Tree</classname> and we allow
                reordering the tree items by drag and drop.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final Tree tree = new Tree("Inventory");
tree.setContainerDataSource(TreeExample.createTreeContent());
layout.addComponent(tree);
        
// Expand all items
for (Iterator<?> it = tree.rootItemIds().iterator(); it.hasNext();)
    tree.expandItemsRecursively(it.next());
        
// Set the tree in drag source mode
tree.setDragMode(TreeDragMode.NODE);
        
// Allow the tree to receive drag drops and handle them
tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }

    public void drop(DragAndDropEvent event) {
        // Wrapper for the object that is dragged
        Transferable t = event.getTransferable();
        
        // Make sure the drag source is the same tree
        if (t.getSourceComponent() != tree)
            return;
        
        TreeTargetDetails target = (TreeTargetDetails)
            event.getTargetDetails();

        // Get ids of the dragged item and the target item
        Object sourceItemId = t.getData("itemId");
        Object targetItemId = target.getItemIdOver();

        // On which side of the target the item was dropped 
        VerticalDropLocation location = target.getDropLocation();
        
        HierarchicalContainer container = (HierarchicalContainer)
        tree.getContainerDataSource();

        // Drop right on an item -> make it a child
        if (location == VerticalDropLocation.MIDDLE)
            tree.setParent(sourceItemId, targetItemId);

        // Drop at the top of a subtree -> make it previous
        else if (location == VerticalDropLocation.TOP) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
            container.moveAfterSibling(targetItemId, sourceItemId);
        }
        
        // Drop below another item -> make it next 
        else if (location == VerticalDropLocation.BOTTOM) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
        }
    }
});]]></programlisting>

            <section>
                <title>Accept Criteria for Trees</title>

                <para>
                    <classname>Tree</classname> defines some specialized accept
                    criteria for trees.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TargetInSubtree</classname> (client-side)</term>
                        <listitem>
                            Accepts if the target item is in the specified sub-tree. The
                            sub-tree is specified by the item ID of the root of the
                            sub-tree in the constructor. The second constructor includes a
                            depth parameter, which specifies how deep from the given root
                            node are drops accepted. Value <literal>-1</literal> means
                            infinite, that is, the entire sub-tree, and is therefore the
                            same as the simpler constructor.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemAllowsChildren</classname> (client-side)</term>
                        <listitem>
                            Accepts a drop if the tree has
                            <methodname>setChildrenAllowed()</methodname> enabled for the
                            target item. The criterion does not require parameters, so the
                            class is a singleton and can be acquired with
                            <methodname>Tree.TargetItemAllowsChildren.get()</methodname>. For
                            example, the following composite criterion accepts drops only
                            on nodes that allow children, but between all nodes:

                            <programlisting><?pocket-size 65% ?><![CDATA[return new Or (Tree.TargetItemAllowsChildren.get(), new Not(VerticalLocationIs.MIDDLE));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TreeDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops on only some items, which as specified by a set
                            of item IDs. You must extend the abstract class and implement
                            the <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target nodes is loaded only once
                            from the server for each drag operation. See <xref
                            linkend="advanced.dragndrop.acceptcriteria"/> for an example.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, the accept criteria defined in
                    <classname>AbstractSelect</classname> are available for a
                    <classname>Tree</classname>, as listed in <xref
                    linkend="advanced.dragndrop.acceptcriteria"/>.
                </para>
            </section>
            
        </section>

        <section xml:id="advanced.dragndrop.tabledrop">
            <title>Dropping Items On a <classname>Table</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Table</classname>. Making table a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Table</classname>
                supports dragging both single rows, with
                <literal>TableDragMode.ROW</literal>, and multiple rows, with
                <literal>TableDragMode.MULTIROW</literal>. While dragging, the dragged
                node or nodes are referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. Tree nodes are identified by
                the item IDs of the container items.
            </para>

            <para>
                When a transferable is dropped on a table, the drop location is stored in
                a <classname>AbstractSelectTargetDetails</classname> object, which
                identifies the target row by its item ID. You can get the item ID with
                <methodname>getItemIdOver()</methodname> method. A drop can occur directly
                on or above or below a row; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method from the details object.
            </para>

            <section>
                <title>Accept Criteria for Tables</title>

                <para>
                    <classname>Table</classname> defines one specialized accept
                    criterion for tables.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TableDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops only on (or above or below) items that are
                            specified by a set of item IDs. You must extend the abstract
                            class and implement the
                            <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target items is loaded only once
                            from the server for each drag operation.
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="advanced.dragndrop.acceptcriteria">
            <title>Accepting Drops</title>

            <indexterm xml:id="term:advanced.dragndrop.acceptcriteria" class="startofrange">
                <primary>Drag and Drop</primary>
                <secondary>Accept Criteria</secondary>
            </indexterm>

            <para>
                You can not drop the objects you are dragging around just anywhere. Before
                a drop is possible, the specific drop location on which the mouse hovers
                must be <emphasis>accepted</emphasis>. Hovering a dragged object over an
                accepted location displays an <emphasis>accept indicator</emphasis>, which
                allows the user to position the drop properly. As such checks have to be
                done all the time when the mouse pointer moves around the drop targets, it
                is not feasible to send the accept requests to the server-side, so drops
                on a target are normally accepted by a client-side <emphasis>accept
                criterion</emphasis>.
            </para>

            <para>
                A drop handler must define the criterion on the objects which it accepts
                to be dropped on the target. The criterion needs to be provided in the
                <classname>getAcceptCriterion()</classname> method of the
                <classname>DropHandler</classname> interface. A criterion is represented
                in an <classname>AcceptCriterion</classname> object, which can be a
                composite of multiple criteria that are evaluated using logical
                operations. There are two basic types of criteria:
                <emphasis>client-side</emphasis> and <emphasis>server-side
                criteria</emphasis>. The various built-in criteria allow accepting drops
                based on the identity of the source and target components, and on the
                <emphasis>data flavor</emphasis> of the dragged objects.
            </para>

            <para>
                To allow dropping any transferable objects, you can return a universal
                accept criterion, which you can get with
                <methodname>AcceptAll.get()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    ...]]></programlisting>

            <section>
                <title>Client-Side Criteria</title>

                <para>
                    The <emphasis>client-side criteria</emphasis>, which inherit the
                    <classname>ClientSideCriterion</classname>, are verified on the
                    client-side, so server requests are not needed for verifying whether each
                    component on which the mouse pointer hovers would accept a certain object.
                </para>

                <para>
                    The following client-side criteria are define in
                    <package>com.vaadin.event.dd.acceptcriterion</package>:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptAll</classname></term>
                        <listitem>
                            Accepts all transferables and targets.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>And</classname></term>
                        <listitem>
                            Logical AND operation on two client-side criterion; accepts
                            the transferable if all the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>ContainsDataFlavour</classname></term>
                        <listitem>
                            The transferable must contain the defined
                            data flavour.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Not</classname></term>
                        <listitem>
                            Logical NOT operation on two client-side criterion; accepts
                            the transferable if and only if the sub-criterion does not
                            accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Or</classname></term>
                        <listitem>
                            Logical OR operation on two client-side criterion; accepts
                            the transferable if any of the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIs</classname></term>
                        <listitem>
                            Accepts all transferables from any of the given source
                            components
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIsTarget</classname></term>
                        <listitem>
                            Accepts the transferable only if the source component is the
                            same as the target. This criterion is useful for ensuring that
                            items are dragged only within a tree or a table, and not from
                            outside it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetDetailIs</classname></term>
                        <listitem>
                            Accepts any transferable if the target detail, such as the
                            item of a tree node or table row, is of the given data flavor
                            and has the given value.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, target components such as <classname>Tree</classname> and
                    <classname>Table</classname> define some component-specific
                    client-side accept criteria. See <xref
                    linkend="advanced.dragndrop.treedrop"/> for more details.
                </para>

                <para>
                    <classname>AbstractSelect</classname> defines the following criteria
                    for all selection components, including <classname>Tree</classname>
                    and <classname>Table</classname>.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptItem</classname></term>
                        <listitem>
                            Accepts only specific items from a specific selection
                            component. The selection component, which must inherit
                            <classname>AbstractSelect</classname>, is given as the first
                            parameter for the constructor. It is followed by a list of
                            allowed item identifiers in the drag source.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>AcceptItem.ALL</classname></term>
                        <listitem>
                            Accepts all transferables as long as they are items.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemIs</classname></term>
                        <listitem>
                            Accepts all drops on the specified target items. The
                            constructor requires the target component
                            (<classname>AbstractSelect</classname>) followed by a list of
                            allowed item identifiers.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>VerticalLocationIs.MIDDLE</classname>,
                        <classname>TOP</classname>, and
                        <classname>BOTTOM</classname></term>
                        <listitem>
                            The three static criteria accepts drops on, above, or below an
                            item. For example, you could accept drops only in between
                            items with the following:

                            <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    return new Not(VerticalLocationIs.MIDDLE);
}]]></programlisting>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section>
                <title>Server-Side Criteria</title>

                <para>
                    The <emphasis>server-side criteria</emphasis> are verified on the
                    server-side with the <methodname>accept()</methodname> method of the
                    <classname>ServerSideCriterion</classname> class. This allows fully
                    programmable logic for accepting drops, but the negative side is that
                    it causes a very large amount of server requests. A request is made
                    for every target position on which the pointer hovers. This problem is
                    eased in many cases by the component-specific lazy loading criteria
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname>. They do the server visit
                    once for each drag and drop operation and return all accepted rows or 
                    nodes for current <classname>Transferable</classname> at once.
                </para>

                <para>
                    The <methodname>accept()</methodname> method gets the drag event as a
                    parameter so it can perform its logic much like in
                    <methodname>drop()</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any other
    // location except on nodes that may not have children
    ServerSideCriterion criterion = new ServerSideCriterion() {
        public boolean accept(DragAndDropEvent dragEvent) {
            TreeTargetDetails target = (TreeTargetDetails)
                dragEvent.getTargetDetails();

            // The tree item on which the load hovers
            Object targetItemId = target.getItemIdOver();

            // On which side of the target the item is hovered
            VerticalDropLocation location = target.getDropLocation();
            if (location == VerticalDropLocation.MIDDLE)
                if (! tree.areChildrenAllowed(targetItemId))
                    return false; // Not accepted

            return true; // Accept everything else
        }
    };
    return criterion;
}]]></programlisting>
                
                <para>
                    The server-side criteria base class
                    <classname>ServerSideCriterion</classname> provides a generic
                    <methodname>accept()</methodname> method. The more specific
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname> are conveniency extensions
                    that allow definiting allowed drop targets as a set of items. They
                    also provide some optimization by lazy loading, which reduces server
                    communications significantly.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any
    // other tree node except on node that may not have children
    TreeDropCriterion criterion = new TreeDropCriterion() {
        @Override
        protected Set<Object> getAllowedItemIds(
                DragAndDropEvent dragEvent, Tree tree) {
            HashSet<Object> allowed = new HashSet<Object>();
            for (Iterator<Object> i =
                   tree.getItemIds().iterator(); i.hasNext();) {
                Object itemId = i.next();
                if (tree.hasChildren(itemId))
                    allowed.add(itemId);
            }
            return allowed;
        }
    };
    return criterion;
}]]></programlisting>

            </section>

            <section>
                <title>Accept Indicators</title>

                <para>
                    When a dragged object hovers on a drop target, an <emphasis>accept
                    indicator</emphasis> is displayed to show whether or not the location
                    is accepted. For <parameter>MIDDLE</parameter> location, the indicator
                    is a box around the target (tree node, table row, or component). For
                    vertical drop locations, the accepted locations are shown as
                    horizontal lines, and for horizontal drop locations as vertical lines.
                </para>

                <para>
                    You can disable the accept indicators or <emphasis>drag
                    hints</emphasis> with the
                    <parameter>no-vertical-drag-hints</parameter>,
                    <parameter>no-horizontal-drag-hints</parameter>, and
                    <parameter>no-box-drag-hints</parameter> styles, as shown in the
                    following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[wrapper.addStyleName("no-vertical-drag-hints");
wrapper.addStyleName("no-horizontal-drag-hints");
wrapper.addStyleName("no-box-drag-hints");]]></programlisting>
            </section>

            <indexterm startref="term:advanced.dragndrop.acceptcriteria" class="endofrange"/>
        </section>

        <section>
            <title>Dragging Components</title>

            <para>
                Dragging a component requires wrapping the source component within a
                <classname>DragAndDropWrapper</classname>. You can then allow dragging by
                putting the wrapper (and the component) in drag mode with
                <methodname>setDragStartMode()</methodname>. The method supports two drag
                modes: <parameter>DragStartMode.WRAPPER</parameter> and
                <parameter>DragStartMode.COMPONENT</parameter>, which defines whether the
                entire wrapper is shown as the drag image while dragging or just the
                wrapped component.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a component to drag
final Button button = new Button("An Absolute Button");

// Put the component in a D&D wrapper and allow dragging it
final DragAndDropWrapper buttonWrap = new DragAndDropWrapper(button);
buttonWrap.setDragStartMode(DragStartMode.COMPONENT);

// Set the wrapper to wrap tightly around the component
buttonWrap.setSizeUndefined();
        
// Add the wrapper, not the component, to the layout
layout.addComponent(buttonWrap, "left: 50px; top: 50px;");]]></programlisting>

            <para>
                The default height of <classname>DragAndDropWrapper</classname> is
                undefined, but the default width is 100%. If you want to ensure that the
                wrapper fits tightly around the wrapped component, you should call
                <methodname>setSizeUndefined()</methodname> for the wrapper. Doing so, you
                should make sure that the wrapped component does not have a relative size,
                which would cause a paradox.
            </para>

            <para>
                Dragged components are referenced in the
                <classname>WrapperTransferable</classname>. You can get the reference to
                the dragged component with
                <methodname>getDraggedComponent()</methodname>. The method will return
                <literal>null</literal> if the transferable is not a component. Also HTML
                5 drags (see later) are held in wrapper transferables.
            </para>

        </section>

        <section xml:id="advanced.dragndrop.drop-on-component">
            <title>Dropping on a Component</title>

            <para>
                Drops on a component are enabled by wrapping the component in a
                <classname>DragAndDropWrapper</classname>. The wrapper is an ordinary
                component; the constructor takes the wrapped component as a parameter. You
                just need to define the <classname>DropHandler</classname> for the wrapper
                with <methodname>setDropHandler()</methodname>.
            </para>

            <para>
                In the following example, we allow moving components in an absolute
                layout. Details on the drop handler are given later.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A layout that allows moving its contained components
// by dragging and dropping them
final AbsoluteLayout absLayout = new AbsoluteLayout();
absLayout.setWidth("100%");
absLayout.setHeight("400px");

... put some (wrapped) components in the layout ...

// Wrap the layout to allow handling drops
DragAndDropWrapper layoutWrapper =
        new DragAndDropWrapper(absLayout);

// Handle moving components within the AbsoluteLayout
layoutWrapper.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    
    public void drop(DragAndDropEvent event) {
        ...        
    }
});]]></programlisting>

            <section>
                <title>Target Details for Wrapped Components</title>

                <para>
                    The drop handler receives the drop target details in a
                    <classname>WrapperTargetDetails</classname> object, which implements
                    the <classname>TargetDetails</classname> interface.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public void drop(DragAndDropEvent event) {
    WrapperTransferable t =
        (WrapperTransferable) event.getTransferable();
    WrapperTargetDetails details =
        (WrapperTargetDetails) event.getTargetDetails();]]></programlisting>

                <para>
                    The wrapper target details include a
                    <classname>MouseEventDetails</classname> object, which you can get
                    with <methodname>getMouseEvent()</methodname>. You can use it to get
                    the mouse coordinates for the position where the mouse button was
                    released and the drag ended. Similarly, you can find out the drag
                    start position from the transferable object (if it is a
                    <classname>WrapperTransferable</classname>) with
                    <methodname>getMouseDownEvent()</methodname>.
                </para>
                
                <programlisting><?pocket-size 65% ?><![CDATA[// Calculate the drag coordinate difference
int xChange = details.getMouseEvent().getClientX()
              - t.getMouseDownEvent().getClientX();
int yChange = details.getMouseEvent().getClientY()
              - t.getMouseDownEvent().getClientY();

// Move the component in the absolute layout
ComponentPosition pos =
    absLayout.getPosition(t.getSourceComponent());
pos.setLeftValue(pos.getLeftValue() + xChange);
pos.setTopValue(pos.getTopValue() + yChange);]]></programlisting>

                <para>
                    You can get the absolute x and y coordinates of the target wrapper
                    with <methodname>getAbsoluteLeft()</methodname> and
                    <methodname>getAbsoluteTop()</methodname>, which allows you to
                    translate the absolute mouse coordinates to coordinates relative to
                    the wrapper. Notice that the coordinates are really the position of
                    the wrapper, not the wrapped component; the wrapper reserves some
                    space for the accept indicators.
                </para>

                <para>
                    The <methodname>verticalDropLocation()</methodname> and
                    <methodname>horizontalDropLocation()</methodname> return the more
                    detailed drop location in the target.
                </para>
            </section>
        </section>

        <section>
            <title>Dragging Files from Outside the Browser</title>
            
            <para>
                The <classname>DragAndDropWrapper</classname> allows dragging files from
                outside the browser and dropping them on a component wrapped in the
                wrapper. Dropped files are automatically uploaded to the application and
                can be acquired from the wrapper with
                <methodname>getFiles()</methodname>. The files are represented as
                <classname>Html5File</classname> objects as defined in the inner
                class. You can define an upload <classname>Receiver</classname> to receive
                the content of a file to an <classname>OutputStream</classname>.
            </para>

            <para>
                Dragging and dropping files to browser is supported in HTML 5 and
                requires a compatible browser, such as Mozilla Firefox 3.6 or newer.
            </para>
        </section>

        <indexterm startref="term:advanced.dragndrop" class="endofrange"/>
    </section>

    <section xml:id="advanced.addons">
        <title>Using Add-on Components</title>

		<para>
            In addition to the built-in components, layouts, themes, and data sources,
            many others are available as add-ons, either from the Vaadin Directory or from
            independent sources. Both commercial and free components exist.
        </para>

		<para>
            Installation of themes, data sources, and components built with server-side
            component composition is simple, just dropping a JAR package in a project
            and, usually, compiling the included widget set (the client-side
            implementation).
        </para>

        <section xml:id="advanced.addons.downloading">
            <title>Downloading Add-ons from Vaadin Directory</title>

            <para>
                Vaadin Directory at <uri>http://vaadin.com/directory/</uri> provides a
                rich collection of add-ons for Vaadin. You can download Directory add-on
                packages from the details page of an add-on.
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        Select the version; some add-ons have several versions available.
                        The latest is shown by default, but you can choose another the
                        version to download from the dropdown menu in the header of the
                        details page.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Click <guibutton>Download Now</guibutton> and save the JAR or Zip
                        file on your computer.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        If the add-on is packaged in a Zip package, unzip the package and
                        follow any instructions provided inside the package. Typically,
                        you just need to copy a JAR file to your web project under the
                        <filename>WEB-INF/lib</filename> directory.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Update and recompile your project. In Eclipse, select the project
                        and press F5.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        You need to compile the client-side implementations of the add-on
                        components, that is, a <emphasis>widget set</emphasis>. This is
                        the case for majority of add-ons, except for pure server-side,
                        theme, or data binding add-ons. You must recompile the widget set
                        if you install a new version of the add-on or the Vaadin
                        library. See the subsequent sections for detailed instructions for
                        compiling widget sets.
                    </para>
                </listitem>

                <listitem>
                    <para>
                        Update the project in web server and possibly restart the server.
                    </para>
                </listitem>
            </orderedlist>

            <para>
                After trying out an add-on, you can give some feedback to the author of
                the add-on by rating the add-on with one to five stars and optionally
                leaving a comment.
            </para>

            <para>
                Please note the add-on license. While most commercial add-ons can be
                downloaded directly, you should note their license and other terms and
                conditions. Many are offered under a dual licensing agreement so that they
                can be used in open source projects for free, and many have a trial period
                for closed-source development.
            </para>
        </section>

        <section xml:id="advanced.addons.compiling-eclipse">
            <title>Compiling Add-on Widget Sets in Eclipse</title>

            <para>
                To be able to compile widget sets in Eclipse, you need to have the Vaadin
                Plugin for Eclipse installed, as instructed in <xref
                linkend="getting-started.environment.eclipse-plugin"/>.
            </para>

            <para>
                An application can only have one widget set, so if you use multiple
                add-ons and possibly your own custom widgets, they need to be combined to
                a single widget set that inherits them. You can create the combining
                widget set manually and the Eclipse plugin simply update it when you add
                new add-ons. Otherwise, the Eclipse plugin automatically creates a
                project-specific widget set under the project root source folder.
            </para>

            <para>
                The Eclipse plugin compiles widget sets automatically by default. They do
                not normally need to be recompiled after changes to server-side classes,
                so if the automatic recompilation get annoying, disable it from the
                project settings.
            </para>

            <para>
                To compile the widget set(s) manually, click the <guilabel>Compile Vaadin
                widgets</guilabel> button in Eclipse toolbar or press
                <keycombo><keycap>Ctrl</keycap><keycap>6</keycap></keycombo>. You must
                recompile the widget set(s) always when you install a new version of the
                add-on or of the Vaadin library.
            </para>

            <!-- TODO: Better icon as requested in #3692. -->
            <figure xml:id="figure.advanced.addons.compiling-eclipse.toolbar">
				<title>The <guibutton>Compile Vaadin widgets</guibutton> Button in Eclipse Toolbar</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/eclipse/widgetset-compiling-toolbar-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="70%" align="center" fileref="img/eclipse/widgetset-compiling-toolbar-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Further information on defining and compiling widget sets is given in
                <xref linkend="gwt.eclipse.compiling"/>, <xref linkend="gwt.widgetset"/>,
                and <xref linkend="gwt.development.compiler"/>.
            </para>
        </section>

        <section xml:id="advanced.addons.compiling-ant">
            <title>Compiling Add-on Widget Sets with an Ant Script</title>

            <para>
                The Vaadin installation package (the Zip package) includes an example Ant
                build script for compiling a widget set. The script is located in
                <filename>WebContent/docs/example-source/build-widgetset.xml</filename>. Once
                you have unpacked the installation package and changed to the directory in
                a command-line window, you can enter:
            </para>

			<screen><prompt>$</prompt> <command>ant -f WebContent/docs/example-source/build-widgetset.xml</command></screen>

            <para>
                You can copy the build script to your project. See <xref
                linkend="gwt.development.compiler"/> for details on configuring the build
                script and the available build targets, and <xref
                linkend="gwt.widgetset"/> for information on the widget set definition
                file.
            </para>

            <para>
                If you are using an IDE such as Eclipse, <emphasis>always</emphasis>
                remember to refresh the project after compiling the widget set.
            </para>
        </section>

        <section xml:id="advanced.addons.troubleshooting">
            <title>Troubleshooting</title>

            <para>
                If you experience problems, do the following:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Check the <filename>.gwt.xml</filename> widget set definition file
                        under the widget set folder in the project root package. For
                        example, if the project root package is
                        <filename>com.example.myproject</filename>, the widget set
                        definition file would be
                        <filename>com.example.myproject.widgetset.MyprojectWidgetset.gwt.xml</filename>. See
                        <xref linkend="gwt.widgetset"/> for details on the contents of the
                        widget set definition file.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Check the <filename>WEB-INF/web.xml</filename> deployment
                        descriptor and see that the servlet for your application has a
                        widget set parameter, such as the following:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<init-param>
  <description>Application widgetset</description>
  <param-name>widgetset</param-name>
  <param-value>com.example.myproject.widgetset.MyprojectWidgetset</param-value>
</init-param>]]></programlisting>
                </listitem>
                <listitem>
                    <para>
                        See the <filename>VAADIN/widgetsets</filename> directory and check
                        that the widget set appears there. You can remove it and recompile
                        to see that compilation works properly.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Use the <guilabel>Net</guilabel> tab in Firebug to see that the
                        widget set (and theme) is loaded properly.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Use the <uri>?debug</uri> parameter for the application to see if
                        there is any version conflict between the widget set and the
                        Vaadin library, or the themes. See <xref
                        linkend="advanced.debug-production-modes.debug.mode"/> for
                        details.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Refresh and recompile the project. In Eclipse, select the project
                        and press <keycap>F5</keycap>, stop the server, clean the server
                        temporary directories, and restart it.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Check the Error Log view in Eclipse (or the IDE you use).
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                For more specific problems related to widget sets definition and
                compilation, see <xref linkend="gwt.development.troubleshooting"/>.
            </para>
        </section>

        <section xml:id="advanced.addons.removing">
            <title>Removing Widget Sets</title>

            <para>
                Version mismatch problems with custom widget sets are a common source of
                grief for many beginners in Vaadin. If you need add-ons or your own custom
                components that include widget sets, you of course need to compile them,
                but otherwise it is unnecessary.
            </para>

            <para>
                If you do not use any such add-ons or your own custom components, do the
                following:
            </para>

            <orderedlist>
                <listitem>
                    <para>
                        If you are using the Eclipse plugin, disable automatic widget set
                        compilation from project preferences, in the
                        <guilabel>Vaadin</guilabel> category, by selecting
                        <guilabel>Suspend automatic widgetset builds</guilabel>. This
                        prevents accidental compilation of the unnecessary widget
                        sets. You may want to do this anyhow as the automatic builds can
                        be annoying. You can still always build the widget set with the
                        button in the toolbar.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Remove all widget set folders from under the
                        <filename>VAADIN/widgetsets</filename> folder.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Edit the <filename>WEB-INF/web.xml</filename> file and remove the
                        <parameter>widgetset</parameter> init parameter from the
                        servlet. It looks as follows:
                    </para>

                    <programlisting><?pocket-size 65% ?><![CDATA[<init-param>
  <description>Application widgetset</description>
  <param-name>widgetset</param-name>
  <param-value>com.vaadin.demo.colorpicker.widgetset.ColorPickerWidgetSet</param-value>
</init-param>]]></programlisting>
                </listitem>
                <listitem>
                    <para>
                        Refresh the project. In Eclipse, select the project and press F5,
                        stop the server, clean the server temporary directories, and
                        restart it.
                    </para>
                </listitem>
            </orderedlist>
        </section>

        <para>
            At least in development environments, if you have extracted Vaadin themes to
            the <filename>VAADIN/themes</filename> folder, you should remove them and let
            them be loaded dynamically from the Vaadin JAR.
        </para>
    </section>

    <!-- TODO
    <section xml:id="advanced.browserinfo">
        <title>Browser Information</title>

        <para>
            
        </para>

    </section> -->
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

