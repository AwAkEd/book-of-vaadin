<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="advanced">
	<title>Advanced Web Application Topics</title>

    <para>
        This chapter covers various features and topics often needed in
        applications.
    </para>

	<section xml:id="advanced.windows">
		<title>Handling Browser Windows</title>

		<para>
            The UI of a Vaadin application runs in a web page displayed in a browser
            window or tab. An application can be used from multiple UIs in different
            windows or tabs, either opened by the user using an URL or by the Vaadin
            application.
        </para>

        <para>
            In addition to native browser windows, Vaadin has a
            <classname>Window</classname> component, which is a floating panel or
            <emphasis>sub-window</emphasis> inside a page, as described in <xref
            linkend="layout.sub-window"/>.
        </para>

		<itemizedlist>
			<listitem>
				<emphasis>Native popup windows</emphasis>. An application can open popup
				windows for sub-tasks.
			</listitem>
			<listitem>
				<emphasis>Page-based browsing</emphasis>. The application can allow the
				user to open certain content to different windows. For example, in a
				messaging application, it can be useful to open different messages to
				different windows so that the user can browse through them while writing a
				new message.
			</listitem>
			<listitem>
				<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide an
				entry-point to some content provided by an application.
			</listitem>
			<listitem>
				<emphasis>Embedding UIs</emphasis>. UIs can be embedded in web
				pages, thus making it possible to provide different views to an
				application from different pages or even from the same page, while keeping
				the same session. See <xref linkend="advanced.embedding"/>.
			</listitem>
		</itemizedlist>

        <para>
            Use of multiple windows in an application may require defining and providing
            different UIs for the different windows. The UIs of an application share the
            same user session, that is, the <classname>VaadinSession</classname> object,
            as described in <xref linkend="application.lifecycle.session"/>. Each UI is
            identified by a URL that is used to access it, which makes it possible to
            bookmark application UIs. UI instances can even be created dynamically based
            on the URLs or other request parameters, such as browser information, as
            described in <xref linkend="application.lifecycle.ui"/>.
		</para>

		<para>
			Because of the special nature of AJAX applications, use of multiple windows
			uses require some caveats. We will go through them later in <xref
			linkend="advanced.windows.caveats"/>.
		</para>
		
        <section xml:id="advanced.windows.popup">
			<title>Opening Popup Windows</title>

            <para>
                Popup windows are native browser windows or tabs opened by user
                interaction with an existing window.  Due to browser security reasons, it
                is made incovenient for a web page to open popup windows using JavaScript
                commands. At the least, the browser will ask for a permission to open the
                popup, if it is possible at all. This limitation can be circumvented by
                letting the browser open the new window or tab directly by its URL when
                the user clicks some target. This is realized in Vaadin with the
                <classname>BrowserWindowOpener</classname> component extension, which
                causes the browser to open a window or tab when the component is clicked.
            </para>

            <section xml:id="advanced.windows.popup.ui">
                <title>The Popup Window UI</title>

                <para>
                    A popup Window displays an <classname>UI</classname>. The UI of a
                    popup window is defined just like a main UI in a Vaadin application,
                    and it can have a theme, title, and so forth.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[@Theme("book-examples")
public static class MyPopupUI extends UI {
    @Override
    protected void init(VaadinRequest request) {
        getPage().setTitle("Popup Window");
        
        // Have some content for it
        VerticalLayout content = new VerticalLayout();
        Label label =
            new Label("I just popped up to say hi!");
        label.setSizeUndefined();
        content.addComponent(label);
        content.setComponentAlignment(label,
            Alignment.MIDDLE_CENTER);
        content.setSizeFull();
        setContent(content);
    }
}]]></programlisting>
            </section>

            <section xml:id="advanced.windows.popup.popping">
                <title>Popping It Up</title>

                <para>
                    A popup window is opened using the
                    <classname>BrowserWindowOpener</classname> extension, which you can
                    attach to any component. The constructor of the extension takes the
                    class object of the UI class to be opened as a parameter.
                </para>

                <para>
                    You can configure the features of the popup window with
                    <methodname>setFeatures()</methodname>. It takes as its parameter a
                    semicolon-separated list of window features, as defined in the HTML
                    specification.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><varname>status</varname>=<parameter>0|1</parameter></term>
                        <listitem>Whether the status bar at the bottom of the window should be enabled.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname></varname><parameter></parameter></term>
                        <listitem></listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>scrollbars</varname></term>
                        <listitem>Enables scrollbars in the window if the document area is bigger than the view area of the window.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>resizable</varname></term>
                        <listitem>Allows the user to resize the browser window (no effect for tabs).</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>menubar</varname></term>
                        <listitem>Enables the browser menu bar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>location</varname></term>
                        <listitem>Enables the location bar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>toolbar</varname></term>
                        <listitem>Enables the browser toolbar.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>height</varname>=<parameter>value</parameter></term>
                        <listitem>Specifies the height of the window in pixels.</listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><varname>width</varname>=<parameter>value</parameter></term>
                        <listitem>Specifies the width of the window in pixels.</listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Create an opener extension
BrowserWindowOpener opener =
    new BrowserWindowOpener(MyPopupUI.class);
opener.setFeatures("height=200,width=300,resizable");

// Attach it to a button
Button button = new Button("Pop It Up");
opener.extend(button);]]></programlisting>

                <para>
                    The resulting popup window is shown in <xref
                    linkend="figure.advanced.windows.popup.popping"/>.
                </para>

                <figure xml:id="figure.advanced.windows.popup.popping">
                    <title>A Popup Window</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/advanced/windows-popup.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="70" smallscale="80%" align="center" fileref="img/advanced/windows-popup.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>

            <section xml:id="advanced.windows.popup.target">
                <title>Popup Window Name (Target)</title>

                <para>
                    The target name is one of the default HTML target names
                    (<parameter>_new</parameter>, <parameter>_blank</parameter>,
                    <parameter>_top</parameter>, etc.) or a custom target name.  How the
                    window is exactly opened depends on the browser. Browsers that support
                    tabbed browsing can open the window in another tab, depending on the
                    browser settings.
                </para>
            </section>

            <section xml:id="advanced.windows.popup.target">
                <title>URL and Session</title>
                
                <para>
                    The URL path for a popup window UI is by default determined from
                    the UI class name, by prefixig it with
                    "<literal>popup/</literal>". For example, for the example UI giver
                    earlier, the URL would be
                    <literal>/book-examples/book/popup/MyPopupUI</literal>.
                </para>
            </section>
        </section>

		<section xml:id="advanced.windows.caveats">
			<title>Caveats in Using Multiple Windows</title>

			<section>
				<title>Communication Between Windows</title>
				
				<para>
                    Handling communication between multiple browser windows is not quite
                    as straight-forward as it is with sub-windows, as an UI running in a
                    browser window can not easily update the data shown in other
                    windows. The contents of a UI are normally updated only when the UI
                    makes a request to the server. The request can be caused by user input
                    or through polling. You could also use server push.
				</para>

				<para>
					However, changing the server-side state of a UI while processing a
					user event from another UI can potentially cause serious
					problems. Changing the client-side state of a UI does not always
					immediately communicate the changes to the server. The server-side
					state can therefore be out of sync with the client-side state.
				</para>

				<figure xml:id="figure.advanced.windows.polling">
					<title>Communication Between Two Browser Windows</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/advanced/window-polling-example1.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/advanced/window-polling-example1.png"/>
						</imageobject>
					</mediaobject>
				</figure>

                <!-- TODO: Provide an example. The old example was in MagiTestApplication.java (TK5.2) -->
			</section>
		</section>
	</section>

	<section xml:id="advanced.embedding">
		<title>Embedding UIs in Web Pages</title>

		<para>
			Many web sites are not all Vaadin, but Vaadin UIs are used only for specific
			functionalities. In practice, many web applications are a mixture of dynamic
			web pages, such as JSP, and Vaadin UIs embedded in such pages.
		</para>

		<para>
			Embedding Vaadin UIs in web pages is easy and there are several different ways
			to embed them. One is to have a <literal>&lt;div&gt;</literal> placeholder for
			the UI and load the Vaadin Client-Side Engine with a simple JavaScript
			code. Another method is even easier, which is to simply use the
			<literal>&lt;iframe&gt;</literal> element. Both of these methods have
			advantages and disadvantages. One disadvantage of the
			<literal>&lt;iframe&gt;</literal> method is that the size of the
			<literal>&lt;iframe&gt;</literal> element is not flexible according to the
			content while the <literal>&lt;div&gt;</literal> method allows such
			flexibility. The following sections look closer into these two embedding
			methods. Additionally, the Vaadin XS add-on allows embedding Vaadin
			UIs in websites running in another server.
		</para>

		<section xml:id="advanced.embedding.div">
			<title>Embedding Inside a <literal>div</literal> Element</title>

			<para>
				You can embed one or more Vaadin UIs inside a web page with a method that
				is equivalent to loading the initial page content from the Vaadin servlet
				in a non-embedded UI. Normally, the <classname>VaadinServlet</classname>
				generates an initial page that contains the correct parameters for the
				specific UI. You can easily configure it to load multiple Vaadin UIs in
				the same page. They can have different widget sets and different themes.
			</para>

            <para>
                Embedding an UI requires the following basic tasks:
            </para>

            <itemizedlist>
                <listitem>Set up the page header</listitem>
                <listitem>Include a GWT history frame in the page</listitem>
                <listitem>Call the <filename>vaadinBootstrap.js</filename> file</listitem>
                <listitem>Define the <literal>&lt;div&gt;</literal> element for the UI</listitem>
                <listitem>Configure and initialize the UI</listitem>
            </itemizedlist>

			<para>
                Notice that you can view the loader page for the UI easily by opening the
                UI in a web browser and viewing the HTML source code of the page. You
                could just copy and paste the embedding code from the page, but some
                modifications and additional settings are required, mainly related to the
                URLs that have to be made relative to the page instead of the servlet URL.
			</para>

            <section xml:id="advanced.embedding.div.head">
                <title>The Head Matter</title>

                <para>
                    The HTML page in which the Vaadin UI is embedded should be a valid
                    XHTML document, as defined in the document type. The content of the
                    head element is largely up to you. The character encoding must be
                    UTF-8. Some meta declarations are necessary for compatibility. You can
                    also set the page favicon in the head element.
                </para>

                <programlisting><?pocket-size 65% ?>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;
&lt;head&gt;
  &lt;meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8" /&gt;
  &lt;meta http-equiv="X-UA-Compatible"
        content="IE=9;chrome=1" /&gt;

  &lt;title&gt;<replaceable>This is my Embedding Page</replaceable>&lt;/title&gt;
  
  &lt;!-- Set up the favicon from the Vaadin theme --&gt;
  &lt;link rel="shortcut icon" type="image/vnd.microsoft.icon"
        href="/VAADIN/themes/<replaceable>reindeer</replaceable>/favicon.ico" /&gt;
  &lt;link rel="icon" type="image/vnd.microsoft.icon"
           href="/VAADIN/themes/<replaceable>reindeer</replaceable>/favicon.ico" /&gt; 
&lt;/head&gt;</programlisting>
            </section>
            
            <section xml:id="advanced.embedding.div.body">
                <title>The Body Matter</title>

                <para>
                    The page content must include some Vaadin-related definitions before
                    you can embed Vaadin UIs in it.
                </para>

                <para>
                    The <filename>vaadinBootstrap.js</filename> script makes definitions
                    for starting up the UI. It must be called before initializing the
                    UI. The source path must be relative to the path of the embedding
                    page.
                </para>

                <programlisting>&lt;body&gt;
  &lt;script type="text/javascript"
          src="<replaceable>./</replaceable>VAADIN/vaadinBootstrap.js"&gt;&lt;/script&gt;</programlisting>

                <para>
                    The bootstrap script is served by the Vaadin servlet from inside the
                    <filename>vaadin-server</filename> JAR.
                </para>

                <para>
                    Vaadin, or more exactly GWT, requires an invisible history frame,
                    which is used for tracking the page or fragment history in the
                    browser.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[  <iframe tabindex="-1" id="__gwt_historyFrame"
          style="position: absolute; width: 0; height: 0;
                 border: 0; overflow: hidden"
          src="javascript:false"></iframe>]]></programlisting>
            </section>

            <section xml:id="advanced.embedding.div.div">
                <title>UI Placeholder Element</title>

                <para>
                    A Vaadin UI is embedded in a placeholder
                    <literal>&lt;div&gt;</literal> element. It should have the following
                    features:
                </para>

                <itemizedlist>
                    <listitem>The <literal>&lt;div&gt;</literal> element must have an
                    <literal>id</literal> attribute, which must be a unique ID in the
                    page, normally something that identifies the servlet of the UI
                    uniquely. </listitem>

                    <listitem>It must have at least the <literal>v-app</literal> style
                    class.</listitem>

                    <listitem>it should have a nested <literal>&lt;div&gt;</literal>
                    element with <literal>v-app-loading</literal> style class. This is a
                    placeholder for the loading indicator that is displayed while the UI
                    is being loaded.</listitem>

                    <listitem>It should also contain a <literal>&lt;noscript&gt;</literal>
                    element that is shown if the browser does not support JavaScript or it
                    has been disabled. The content of the element should instruct the use
                    to enable JavaScript in the browser.</listitem>
                </itemizedlist>

                <para>
                    The placeholder element can include style settings, typically a width
                    and height. If the sizes are not defined, the UI will have an
                    undefined size in the particular dimension, which must be in
                    accordance with the sizing of the UI components.
                </para>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?>&lt;div style="<replaceable>width: 300px; border: 2px solid green;</replaceable>"
     id="helloworldui" class="v-app"&gt;
  &lt;div class="v-app-loading"&gt;&lt;/div&gt;
  &lt;noscript&gt;<replaceable>You have to enable javascript in your browser to</replaceable>
            <replaceable>use an application built with Vaadin.</replaceable>&lt;/noscript&gt;
&lt;/div&gt;</programlisting>

            </section>

            <section xml:id="advanced.embedding.div.init">
                <title>Initializing the UI</title>

                <para>
                    The UI is loaded by calling the <literal>initApplication()</literal>
                    method for the <literal>vaadin</literal> object defined in the
                    bootstrap script. Before calling it, you should check that the
                    bootstrap script was loaded properly.
                </para>

                <programlisting><?pocket-size 75% ?>&lt;script type="text/javascript"&gt;//&lt;![CDATA[
  if (!window.vaadin)
      alert("<replaceable>Failed to load the bootstrap JavaScript:</replaceable>"+
            "<replaceable>VAADIN/vaadinBootstrap.js</replaceable>");</programlisting>

                <para>
                    The <literal>initApplication()</literal> takes two parameters. The
                    first parameter is the UI identifier, exactly as given as the
                    <literal>id</literal> attribute of the placeholder element. The second
                    parameter is an associative map that contains parameters for the
                    UI. 
                </para>

                <para>
                    The map must contain the following items:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><parameter>browserDetailsUrl</parameter></term>
                        <listitem>
                            <para>
                                This should be the URL path (relative to the embedding
                                page) to the Vaadin servlet of the UI. It is used by the
                                bootstrap to communicate browser details.
                            </para>

                            <para>
                                Notice that this parameter not included in the loader page
                                generated by the servlet, as in that case it can default
                                to the current URL.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>widgetset</parameter></term>
                        <listitem>
                            This should be the exact class name of the widget set for the
                            UI, that is, without the <filename>.gwt.xml</filename> file
                            name extension. If the UI has no compiled widget set, you can
                            use the <classname>com.vaadin.DefaultWidgetSet</classname>.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>theme</parameter></term>
                        <listitem>
                            Name of the theme. It must exist under the
                            <filename>VAADIN/themes</filename> folder.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>versionInfo</parameter></term>
                        <listitem>
                            This parameter is itself an associative map that can contain
                            two parameters: <parameter>vaadinVersion</parameter> contains
                            the version number of the Vaadin version used by the
                            application. The <parameter>applicationVersion</parameter>
                            parameter contains the version of the particular
                            application. The contained parameters are optional, but the
                            <parameter>versionInfo</parameter> parameter itself is not.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>vaadinDir</parameter></term>
                        <listitem>
                            Relative path to the <filename>VAADIN</filename> directory. It
                            is relative to the URL of the embedding page.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>heartbeatInterval</parameter></term>
                        <listitem>
                            The <parameter>hearbeatInterval</parameter> parameter defines
                            the frequency of the keep-alive hearbeat for the UI in
                            seconds, as described in <xref
                            linkend="application.lifecycle.ui-expiration"/>.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>debug</parameter></term>
                        <listitem>
                            The parameter defines whether the debug window, as described in
                            <xref linkend="advanced.debug-production-modes"/>, is enabled.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>standalone</parameter></term>
                        <listitem>
                            The parameter defines whether the UI is rendered on its own in
                            the browser window or in some context. A standalone UI may do
                            things that might interfere with other parts of the page, such
                            as change the page title and request focus when it is
                            loaded. When embedding, the UI is not standalone, so you may
                            want to set the parameter as <parameter>false</parameter>.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><parameter>authErrMsg</parameter>, <parameter>comErrMsg</parameter>, and <parameter>sessExpMsg</parameter></term>
                        <listitem>
                            These three parameters define the client-side error messages
                            for authentication error, communication error, and session
                            expiration, respectively. The parameters are associative maps
                            themselves and must contain two key-value pairs:
                            <parameter>message</parameter>, which should contain the error
                            text in HTML, and <parameter>caption</parameter>, which should
                            be the error caption.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    For example:
                </para>

                <programlisting><?pocket-size 75% ?>  vaadin.initApplication("<replaceable>helloworldui</replaceable>", {
      "browserDetailsUrl": "<replaceable>helloworld</replaceable>",
      "widgetset": "<replaceable>com.example.MyWidgetSet</replaceable>",
      "theme": "<replaceable>mytheme</replaceable>",
      "versionInfo": {"vaadinVersion": "<replaceable>7.0.0</replaceable>"},
      "vaadinDir": "<replaceable>VAADIN/</replaceable>",
      "heartbeatInterval": <replaceable>300</replaceable>,
      "debug": <replaceable>true</replaceable>,
      "standalone": false,
      "authErrMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Authentication problem"
      },
      "comErrMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Communication problem"
      },
      "sessExpMsg": {
          "message": "<replaceable>Take note of any unsaved data, "+
                     "and &lt;u&gt;click here&lt;\/u&gt; to continue.</replaceable>",
          "caption": "Session Expired"
      }
  });//]]&gt;
&lt;/script&gt;</programlisting>

                <para>
                    Notice that many of the parameters are normally deployment parameters,
                    specified in the deployment descriptor, as described in <xref
                    linkend="application.environment.parameters"/>.
                </para>
            </section>

            <section xml:id="advanced.embedding.div.summary">
                <title>Summary of Div Embedding</title>

                <para>
                    Below is a complete example of embedding an UI in a
                    <literal>&lt;div&gt;</literal> element.
                </para>

			<programlisting><?pocket-size 65% ?><![CDATA[<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type"
        content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible"
        content="IE=9;chrome=1" />

  <title>Embedding a Vaadin Application in HTML Page</title>
  
  <!-- Set up the favicon from the Vaadin theme -->
  <link rel="shortcut icon" type="image/vnd.microsoft.icon"
        href="/VAADIN/themes/reindeer/favicon.ico" />
  <link rel="icon" type="image/vnd.microsoft.icon"
           href="/VAADIN/themes/reindeer/favicon.ico" /> 
</head>

<body>
  <!-- Loads the Vaadin widget set, etc. -->
  <script type="text/javascript"
          src="VAADIN/vaadinBootstrap.js"></script>

  <!-- GWT requires an invisible history frame. It is   -->
  <!-- needed for page/fragment history in the browser. -->
  <iframe tabindex="-1" id="__gwt_historyFrame"
          style="position: absolute; width: 0; height: 0;
                 border: 0; overflow: hidden"
          src="javascript:false"></iframe>  

  <h1>Embedding a Vaadin UI</h1>
    
  <p>This is a static web page that contains an embedded Vaadin
     application. It's here:</p>

  <!-- So here comes the div element in which the Vaadin -->
  <!-- application is embedded.                          -->
  <div style="width: 300px; border: 2px solid green;"
       id="helloworld" class="v-app">

    <!-- Optional placeholder for the loading indicator -->
    <div class=" v-app-loading"></div>

    <!-- Alternative fallback text -->
    <noscript>You have to enable javascript in your browser to
              use an application built with Vaadin.</noscript>
  </div>
  
  <script type="text/javascript">//<![CDATA[
    if (!window.vaadin)
        alert("Failed to load the bootstrap JavaScript: "+
              "VAADIN/vaadinBootstrap.js");

    /* The UI Configuration */
	vaadin.initApplication("helloworld", {
	    "browserDetailsUrl": "helloworld",
	    "widgetset": "com.example.MyWidgetSet",
	    "theme": "mytheme",
	    "versionInfo": {"vaadinVersion": "7.0.0"},
	    "vaadinDir": "VAADIN/",
	    "heartbeatInterval": 300,
	    "debug": true,
	    "standalone": false,
	    "authErrMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Authentication problem"
	    },
	    "comErrMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Communication problem"
	    },
	    "sessExpMsg": {
	        "message": "Take note of any unsaved data, "+
	                   "and <u>click here<\/u> to continue.",
	        "caption": "Session Expired"
	    }
	});//]] >
  </script>
  
  <p>Please view the page source to see how embedding works.</p>
</body>
</html>]]></programlisting>
            </section>
        </section>

		<section xml:id="advanced.embedding.iframe">
			<title>Embedding Inside an <literal>iframe</literal> Element</title>

			<para>
				Embedding a Vaadin UI inside an <literal>&lt;iframe&gt;</literal> element
				is even easier than the method described above, as it does not require
				definition of any Vaadin specific definitions.
			</para>

			<para>
				You can embed an UI with an element such as the following:
			</para>

			<programlisting>&lt;iframe src="<replaceable>/myapp/myui</replaceable>"&gt;&lt;/iframe&gt;</programlisting>

			<para>
				The <literal>&lt;iframe&gt;</literal> elements have several downsides for
				embedding. One is that their size of is not flexible depending on the
				content of the frame, but the content must be flexible to accommodate in
				the frame. You can set the size of an <literal>&lt;iframe&gt;</literal>
				element with <literal>height</literal> and <literal>width</literal>
				attributes. Other issues arise from themeing and communication with the
				frame content and the rest of the page.
			</para>

			<para>
				Below is a complete example of using the <literal>&lt;iframe&gt;</literal>
				to embed two applications in a web page.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
  <head>
    <title>Embedding in IFrame</title>
  </head>

  <body style="background: #d0ffd0;">
    <h1>This is a HTML page</h1>
    <p>Below are two Vaadin applications embedded inside
       a table:</p>

    <table align="center" border="3">
      <tr>
        <th>The Calculator</th>
        <th>The Color Picker</th>
      </tr>
      <tr valign="top">
        <td>
          <iframe src="/vaadin-examples/Calc" height="200"
                  width="150" frameborder="0"></iframe>
        </td>
        <td>
          <iframe src="/vaadin-examples/colorpicker"
                  height="330" width="400"
                  frameborder="0"></iframe>
        </td>
      </tr>
    </table>
  </body>
</html>]]></programlisting>

			<para>
				The page will look as shown in <xref linkend="figure.embedding.iframe"/>
				below.
			</para>

			<figure xml:id="figure.embedding.iframe">
				<title>Vaadin Applications Embedded Inside IFrames</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/application/embedding3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                You can embed almost anything in an iframe, which essentially acts as a
                browser window. However, this creates various problems. The iframe must
                have a fixed size, inheritance of CSS from the embedding page is not
                possible, and neither is interaction with JavaScript, which makes mashups
                impossible, and so on. Even bookmarking with URI fragments will not work.
            </para>

            <para>
                Note also that websites can forbid iframe embedding by specifying an
                <literal>X-Frame-Options: SAMEORIGIN</literal> header in the HTTP
                response.
            </para>
		</section>

		<section xml:id="advanced.embedding.xs">
            <title>Cross-Site Embedding with the Vaadin XS Add-on</title>

            <para>
                In the previous sections, we described the two basic methods for embedding
                Vaadin applications: in a <literal>&lt;div&gt;</literal> element and in an
                <literal>&lt;iframe&gt;</literal>. One problem with div embedding is that
                it does not work between different Internet domains, which is a problem if
                you want to have your website running in one server and your Vaadin
                application in another. The security model in browsers effectively
                prevents such cross-site embedding of Ajax applications by enforcing the
                <emphasis>same origin policy</emphasis> for XmlHttpRequest calls, even if
                the server is running in the same domain but different port. While iframe
                is more permissive, allowing embedding almost anything in anywhere, it has
                many disadvantanges, as described earlier.
            </para>

            <para>
                The Vaadin XS (Cross-Site) add-on works around the limitation in div
                embedding by using JSONP-style communication instead of the standard
                XmlHttpRequests.
            </para>

            <para>
                Embedding is done simply with:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>]]></programlisting>

            <para>
                This includes an automatically generated embedding script in the page,
                thereby making embedding effortless.
            </para>

            <para>
                This assumes that the main layout of the application has undefined
                height. If the height is 100%, you have to wrap it inside an element with
                a defined height. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[ <div style="height: 500px;">
  <script src="http://demo.vaadin.com/xsembed/getEmbedJs"
          type="text/javascript"></script>
</div>]]></programlisting>

            <para>
                It is possible to restrict where the application can be embedded by using
                a whitelist. The add-on also encrypts the client-server communication,
                which is more important for embedded applications than usual.
            </para>

            <para>
                You can get the Vaadin XS add-on from Vaadin Directory. It is provided as
                a Zip package. Download and extract the installation package to a local
                folder. Instructions for installation and further information is given in
                the <filename>README.html</filename> file in the package.
            </para>

            <para>
                Some restrictions apply. You can have only one embedded application in one
                page. Also, some third-party libraries may interfere with the
                communication. Other notes are given in the README.
            </para>
        </section>

        <!-- TODO
		<section xml:id="advanced.embedding.jsp">
			<title>Embedding Into JSP and JSF Applications</title>

        </section>
         -->
	</section>

	<section xml:id="advanced.debug-production-modes">
		<title>Debug and Production Mode</title>

		<para>
			Vaadin applications can be run in two modes: <emphasis>debug
			mode</emphasis> and <emphasis>production mode</emphasis>. The debug mode,
			which is on by default, enables a number of built-in debug features for the
			developers. The features include:
		</para>

		<itemizedlist>
			<listitem>Debug Window for accessing debug functionalities</listitem>
			<listitem>Display debug information in the Debug Window and server console.</listitem>
			<listitem><guibutton>Analyze layouting</guibutton> button that analyzes the layout for possible problems.</listitem>
		</itemizedlist>

		<para>
			All applications are run in the debug mode by default (since IT Mill Toolkit
			version 5.3.0). The production mode can be enabled, and debug mode thereby
			disabled, by adding a <parameter>productionMode=true</parameter> parameter to
			the servlet context in the <filename>web.xml</filename> deployment descriptor:
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[<context-param>
  <description>Vaadin production mode</description>
  <param-name>productionMode</param-name>
  <param-value>true</param-value>
</context-param>]]></programlisting>
		
		<para>
			Enabling the production mode disables the debug features, thereby preventing
			users from easily inspecting the inner workings of the application from the
			browser.
		</para>
		
		<section xml:id="advanced.debug-production-modes.debug.mode">
			<title>Debug Mode</title>

            <para>
                Running an application in the debug mode enables the client-side Debug
                Window in the browser. You can open the Debug Window by adding
                "<uri>?debug</uri>" to the application URL, for example,
                <uri>http://localhost:8080/myapp/?debug</uri>. The Debug Window, shown in
                <xref linkend="figure.debug.window"/>, consists of buttons controlling the
                debugging features and a scrollable log of debug messages.
            </para>

			<figure id="figure.debug.window">
				<title>Debug Window</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<variablelist>
				<varlistentry>
					<term><guibutton>Clear console</guibutton></term>
					<listitem>
						Clears the log in the Debug Window.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Restart app</guibutton></term>
					<listitem>
						Restarts the application.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Force layout</guibutton></term>
					<listitem>
						Causes all currently visible layouts to recalculate their
						appearance. Layout components calculate the space required by all
						child components, so the layout appearance must be recalculated
						whenever the size of a child component is changed. In normal
						applications, this is done automatically, but when you do themeing
						or alter the CSS with Firebug, you may need to force all layouts
						to recalculate themselves, taking into account the recently made
						changes.
					</listitem>
				</varlistentry>
				<varlistentry>
					<term><guibutton>Analyze layouts</guibutton></term>
					<listitem>
						This is described in the following section.
					</listitem>
				</varlistentry>
			</variablelist>

			<para>
				If you use the Firebug plugin in Mozilla Firefox, the log messages will
				also be printed to the Firebug console. In such a case, you may want to
				enable client-side debugging without showing the Debug Window with
				"<uri>?debug=quiet</uri>" in the URL. In the quiet debug mode, log
				messages will only be printed to the Firebug console.
			</para>
		</section>

 		<section>
			<title>Analyzing Layouts</title>
			<para>
				The <guilabel>Analyze layouts</guilabel> button analyzes the currently
				visible layouts and makes a report of possible layout related
				problems. All detected layout problems are displayed in the log and also
				printed to the console.
			</para>

			<para>
				The most common layout problem is caused by placing a component that has a
				relative size inside a container (layout) that has undefined size, for
				example, adding a 100% wide <classname>Panel</classname> inside a
				<classname>HorizontalLayout</classname> with no width specification. In
				such a case, the error will look as shown below:
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Vaadin DEBUG
- Window/1a8bd74 "My window" (width: MAIN WINDOW)
  - HorizontalLayout/1cf243b (width: UNDEFINED)
    - Panel/12e43f1 "My panel" (width: RELATIVE, 100.0 %)
Layout problem detected: Component with relative width inside a HorizontalLayout with no width defined
Relative sizes were replaced by undefined sizes, components may not render as expected.]]>
			</programlisting>
			
			<para>
				This particular error tells that the <classname>Panel</classname> "My
				panel" is 100% wide while the width of the containing
				<classname>HorizontalLayout</classname> is undefined. The components will
				be rendered as if the the width of the contained
				<classname>Panel</classname> was undefined, which might not be what the
				developer wanted. There are two possible fixes for this case: if the
				<classname>Panel</classname> should fill the main window horizontally, set
				a width for the <classname>HorizontalLayout</classname> (for example 100%
				wide), or set the width of the <classname>Panel</classname> to "undefined"
				to render the it as it is currently rendered but avoiding the warning
				message.
			</para>

            <para>
                The same error is shown in the Debug Window in a slightly different form
                and with an additional feature (see <xref
                linkend="figure.debug-window.analyze-layouts"/>). Checking the
                <guilabel>Emphasize component in UI</guilabel> box will turn red the
                background of the component that caused a warning, making it easy for the
                developer to figure out which component each warning relates to. The
                messages will also be displayed hierarchically, as a warning from a
                containing component often causes more warnings from its child
                components. A good rule of thumb is to work on the upper-level problems
                first and only after that worry about the warnings from the children.
            </para>

			<figure id="figure.debug-window.analyze-layouts">
				<title>Debug Window Showing the Result of <guilabel>Analyze layouts</guilabel>.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata smallscale="100%" align="center" fileref="img/debug/debug-window-analyze-layouts.png"/>
					</imageobject>
				</mediaobject>
			</figure>
						
		</section>

		<section>
			<title>Custom Layouts</title>

			<para>
				<classname>CustomLayout</classname> components can not be analyzed in the
				same way as other layouts. For custom layouts, the <guibutton>Analyze
				layouts</guibutton> button analyzes all contained relative-sized
				components and checks if any relative dimension is calculated to zero so
				that the component will be invisible. The error log will display a warning
				for each of these invisible components. It would not be meaningful to
				emphasize the component itself as it is not visible, so when you select
				such an error, the parent layout of the component is emphasized if
				possible.
			</para>

		</section>

		<section>
			<title>Debug Functions for Component Developers</title>

			<para>
				You can take advantage of the debug mode when developing client-side
				components. The static function
				<methodname>ApplicationConnection.getConsole()</methodname> will return a
				reference to a <classname>Console</classname> object which contains
				logging methods such as <methodname>log(String msg)</methodname> and
				<methodname>error(String msg)</methodname>.  These functions will print
				messages to the Debug Window and Firebug console in the same way as other
				debugging functionalities of Vaadin do. No messages will be
				printed if the Debug Window is not open or if the application is running
				in production mode.
			</para>
		</section>
	</section>

	<section xml:id="advanced.requesthandler">
		<title>Request Handlers</title>

        <para>
            Request handlers are useful for catching request parameters or generating
            dynamic content, such as HTML, images, PDF, or other content. You can provide
            HTTP content easily also with stream resources, as described in <xref
            linkend="application.resources.stream"/>. The stream resources, however, are
            only usable from within a Vaadin application, such as in the
            <classname>Embedded</classname> component. Request handlers allow responding
            to HTTP requests made with the application URL, including GET or POST
            parameters. You could also use a separate servlet to generate dynamic content,
            but a request handler is associated with the Vaadin session and it can easily
            access all the session data.
        </para>

        <para>
            To handle requests, you need to implement the
            <interfacename>RequestHandler</interfacename> interface. The
            <methodname>handleRequest()</methodname> method gets the session, request, and
            response objects as parameters.
		</para>

        <para>
            If the handler writes a response, it must return <literal>true</literal>. This
            stops running other possible request handlers. Otherwise, it should return
            <literal>false</literal> so that another handler could return a
            response. Eventually, if no other handler writes a response, a UI will be
            created and initialized.
        </para>

        <para>
            In the following example, we catch requests for a sub-path in the URL for the
            servlet and write a plain text response. The servlet path consists of the
            context path and the servlet (sub-)path. Any additional path is passed to the
            request handler in the <parameter>pathInfo</parameter> of the request. For
            example, if the full path is <filename>/myapp/myui/rhexample</filename>, the
            path info will be <filename>/rhexample</filename>. Also, request parameters
            are available.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[VaadinSession.getCurrent().addRequestHandler(
        new RequestHandler() {
    @Override
    public boolean handleRequest(VaadinSession session,
                                 VaadinRequest request,
                                 VaadinResponse response)
            throws IOException {
        if ("/rhexample".equals(request.getPathInfo())) {
            response.setContentType("text/plain");
            response.getWriter().append(
                "Here's some dynamically generated content.\n"+
                "Time: " + (new Date()).toString());
            return true; // We wrote a response
        } else
            return false; // No response was written
    }
});

// Find out the base bath for the servlet
String servletPath = VaadinServlet.getCurrent()
    .getServletContext().getContextPath() + VaadinServletService 
    .getCurrentServletRequest().getServletPath();
        
// Display the page in a popup window
Link open = new Link("Click to Show the Page",
    new ExternalResource(servletPath + "/rhexample"),
    "_blank", 500, 350, BorderStyle.DEFAULT);
layout.addComponent(open);]]></programlisting>
	</section>

	<section xml:id="advanced.shortcuts">
		<title>Shortcut Keys</title>

        <para>
            Vaadin provides simple ways for defining shortcut keys for field components
            and a default button, and a lower-level generic shortcut key binding API based
            on actions.
        </para>

        <section xml:id="advanced.shortcuts.defaultbutton">
            <title>Click Shortcuts for Default Buttons</title>

            <para>
                You can add or set a <emphasis>click shortcut</emphasis> to a button to
                set it as "default" button; pressing the defined key, typically
                <keycap>Enter</keycap>, in any component in the window causes a click
                event for the button.
            </para>

            <para>
                You can define a click shortcut with the
                <methodname>setClickShortcut()</methodname> shorthand method:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an OK button and set it as the default button
Button ok = new Button("OK");
ok.setClickShortcut(KeyCode.ENTER);
ok.addStyleName("primary");]]></programlisting>

            <para>
                The <literal>primary</literal> style name highlights a button to show the
                default button status; usually with a bolder font than usual, depending on
                the theme. The result can be seen in <xref
                linkend="figure.advanced.shortcuts.defaultbutton"/>.
            </para>

			<figure xml:id="figure.advanced.shortcuts.defaultbutton">
				<title>Default Button with Click Shortcut</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="70" smallscale="100%" align="center" fileref="img/advanced/shortcut-defaultbutton.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="advanced.shortcuts.focus">
            <title>Field Focus Shortcuts</title>

            <para>
                You can define a shortcut key that sets the focus to a field component
                (any component that inherits <classname>AbstractField</classname>) by
                adding a <classname>FocusShortcut</classname> as a shortcut listener to
                the field.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A field with Alt+N bound to it
TextField name = new TextField("Name (Alt+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.ALT));
layout.addComponent(name);

// A field with Alt+A bound to it
TextField address = new TextField("Address (Alt+A)");
address.addShortcutListener(
        new AbstractField.FocusShortcut(address, KeyCode.A,
                                        ModifierKey.ALT));
layout.addComponent(address);]]></programlisting>

            <para>
                The constructor of the <classname>FocusShortcut</classname> takes the
                field component as its first parameter, followed by the key code, and an
                optional list of modifier keys, as listed in <xref
                    linkend="advanced.shortcuts.keycodes"/>.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.actions">
            <title>Generic Shortcut Actions</title>

            <para>
                Shortcut keys can be defined as <emphasis>actions</emphasis> using the
                <classname>ShortcutAction</classname> class. ShortcutAction extends the
                generic <classname>Action</classname> class that is used for example in
                <classname>Tree</classname> and <classname>Table</classname> for context
                menus.  Currently, the only classes that accept
                <classname>ShortcutAction</classname>s are <classname>Window</classname>
                and <classname>Panel</classname>.
            </para>
		
            <para>
                To handle key presses, you need to define an action handler by
                implementing the <classname>Handler</classname> interface. The interface
                has two methods that you need to implement:
                <methodname>getActions()</methodname> and
                <methodname>handleAction()</methodname>.
            </para>

            <para>
                The <methodname>getActions()</methodname> method must return an array of
                <classname>Action</classname> objects for the component, specified with the
                second parameter for the method, the <parameter>sender</parameter> of an
                action. For a keyboard shortcut, you use a
                <classname>ShortcutAction</classname>. The implementation of the method
                could be following:
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an event
Action action_ok = new ShortcutAction("Default key",
        ShortcutAction.KeyCode.ENTER, null);

// Have the C key modified with Alt cause an event
Action action_cancel = new ShortcutAction("Alt+C",
        ShortcutAction.KeyCode.C,
        new int[] { ShortcutAction.ModifierKey.ALT });

Action[] actions = new Action[] {action_cancel, action_ok};

public Action[] getActions(Object target, Object sender) {
    if (sender == myPanel)
        return actions;

    return null;
}]]></programlisting>

            <para>
                The returned <classname>Action</classname> array may be static or you can
                create it dynamically for different senders according to your needs.
            </para>

            <para>
                The constructor of <classname>ShortcutAction</classname> takes a symbolic
                caption for the action; this is largely irrelevant for shortcut actions in
                their current implementation, but might be used later if implementors use
                them both in menus and as shortcut actions.  The second parameter is the
                key code and the third a list of modifier keys, which are listed in <xref
                linkend="advanced.shortcuts.keycodes"/>.
            </para>

            <para>
                The following example demonstrates the definition of a default button for a
                user interface, as well as a normal shortcut key,
                <keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> for clicking the
                <guibutton>Cancel</guibutton> button.
            </para>

            <programlisting language="java"><?pocket-size 65% ?><![CDATA[public class DefaultButtonExample extends CustomComponent
                                  implements Handler {
    // Define and create user interface components
    Panel panel = new Panel("Login");
    FormLayout formlayout = new FormLayout();
    TextField username = new TextField("Username");
    TextField password = new TextField("Password");
    HorizontalLayout buttons = new HorizontalLayout();

    // Create buttons and define their listener methods.
    Button ok = new Button("OK", this, "okHandler");
    Button cancel = new Button("Cancel", this, "cancelHandler");

    // Have the unmodified Enter key cause an event
    Action action_ok = new ShortcutAction("Default key",
            ShortcutAction.KeyCode.ENTER, null);

    // Have the C key modified with Alt cause an event
    Action action_cancel = new ShortcutAction("Alt+C",
            ShortcutAction.KeyCode.C,
            new int[] { ShortcutAction.ModifierKey.ALT });

    public DefaultButtonExample() {
        // Set up the user interface
        setCompositionRoot(panel);
        panel.addComponent(formlayout);
        formlayout.addComponent(username);
        formlayout.addComponent(password);
        formlayout.addComponent(buttons);
        buttons.addComponent(ok);
        buttons.addComponent(cancel);

        // Set focus to username
        username.focus();

        // Set this object as the action handler
        System.out.println("adding ah");
        panel.addActionHandler(this);

        System.out.println("start done.");
    }

    /**
     * Retrieve actions for a specific component. This method
     * will be called for each object that has a handler; in
     * this example just for login panel. The returned action
     * list might as well be static list.
     */
    public Action[] getActions(Object target, Object sender) {
        System.out.println("getActions()");
        return new Action[] { action_ok, action_cancel };
    }

    /**
     * Handle actions received from keyboard. This simply directs
     * the actions to the same listener methods that are called
     * with ButtonClick events.
     */
    public void handleAction(Action action, Object sender,
                             Object target) {
        if (action == action_ok) {
            okHandler();
        }
        if (action == action_cancel) {
            cancelHandler();
        }
    }

    public void okHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("OK clicked. "
                + "User=" + username.getValue() + ", password="
                + password.getValue()));
    }

    public void cancelHandler() {
        // Do something: report the click
        formlayout.addComponent(new Label("Cancel clicked. User="
                + username.getValue() + ", password="
                + password.getValue()));
    }
}]]></programlisting>

            <para>
                Notice that the keyboard actions can currently be attached only to
                <classname>Panel</classname>s and <classname>Window</classname>s. This can
                cause problems if you have components that require a certain key. For
                example, multi-line <classname>TextField</classname> requires the
                <keycap>Enter</keycap> key. There is currently no way to filter the
                shortcut actions out while the focus is inside some specific component, so
                you need to avoid such conflicts.
            </para>
        </section>

        <section xml:id="advanced.shortcuts.keycodes">
            <title>Supported Key Codes and Modifier Keys</title>
            
            <para>
                The shortcut key definitions require a key code to identify the pressed
                key and modifier keys, such as Shift, Alt, or Ctrl, to specify a key
                combination.
            </para>

            <para>
                The key codes are defined in the
                <classname>ShortcutAction.KeyCode</classname> interface and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term>Keys <parameter>A</parameter> to <parameter>Z</parameter></term>
                    <listitem>Normal letter keys</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>F1</parameter> to <parameter>F12</parameter></term>
                    <listitem>
                        <para>Function keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, <parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, <parameter>INSERT</parameter>, <parameter>TAB</parameter></term>
                    <listitem>
                        <para>Control keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>NUM0</parameter> to <parameter>NUM9</parameter></term>
                    <listitem>
                        <para>Number pad keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, <parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter></term>
                    <listitem>
                        <para>Arrow keys</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</parameter>, <parameter>PAGE_DOWN</parameter></term>
                    <listitem>
                        <para>Other movement keys</para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <para>
                Modifier keys are defined in
                <classname>ShortcutAction.ModifierKey</classname> and are:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>ModifierKey.ALT</parameter></term>
                    <listitem>Alt key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.CTRL</parameter></term>
                    <listitem>Ctrl key</listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>ModifierKey.SHIFT</parameter></term>
                    <listitem>Shift key</listitem>
                </varlistentry>
            </variablelist>

            <para>
                All constructors and methods accepting modifier keys take them as a
                variable argument list following the key code, separated with commas. For
                example, the following defines a
                <keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>N</keycap></keycombo>
                key combination for a shortcut.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField name = new TextField("Name (Ctrl+Shift+N)");
name.addShortcutListener(
        new AbstractField.FocusShortcut(name, KeyCode.N,
                                        ModifierKey.CTRL,
                                        ModifierKey.SHIFT));]]></programlisting>

            <section>
                <title>Supported Key Combinations</title>

                <para>
                    The actual possible key combinations vary greatly between browsers, as
                    most browsers have a number of built-in shortcut keys, which can not
                    be used in web applications. For example, Mozilla Firefox allows
                    binding almost any key combination, while Opera does not even allow
                    binding Alt shortcuts. Other browsers are generally in between these
                    two. Also, the operating system can reserve some key combinations and
                    some computer manufacturers define their own system key combinations.
                </para>
            </section>
        </section>
    </section>

    <section xml:id="advanced.printing">
		<title>Printing</title>

        <indexterm xml:id="term.advanced.printing" class="startofrange">
            <primary>printing</primary>
        </indexterm>

		<para>
			Vaadin does not currently have any special support for
			printing. Printing on the server-side is, in any case, largely independent from the
			web UI of an application. You just have to take care that the printing does
			not block server requests, possibly by running printing in another thread.
		</para>

		<para>
            <indexterm xml:id="term.advanced.printing.print" class="startofrange">
                <primary><methodname>print()</methodname></primary>
            </indexterm>
            <indexterm xml:id="term.advanced.printing.JavaScript.print" class="startofrange">
                <primary>JavaScript</primary>
                <secondary><methodname>print()</methodname></secondary>
            </indexterm>
            
			For client-side printing, most browsers support printing the web page. Vaadin
			does not explicitly support launching the printing in browser, but you can
			easily use the JavaScript <methodname>print()</methodname> method that opens
			the print window of the browser.
		</para>

        <indexterm><primary>JavaScript</primary><secondary><methodname>executeJavaScript()</methodname></secondary></indexterm>
        <indexterm><primary><methodname>executeJavaScript()</methodname></primary></indexterm>

		<programlisting><?pocket-size 65% ?><![CDATA[final Button print = new Button("Print This Page");
print.addListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        print.getWindow().executeJavaScript("print();");
    }
});]]></programlisting>

		<para>
			This button would print the current page, including the button itself. Often,
			you want to be able to print a report or receipt and it should not have any
			visible UI components. In such a case, you could offer it as a PDF resource,
			or you could open a new window, as is done below, and automatically launch
			printing.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[// A button to open the printer-friendly page.
Button print = new Button("Click to Print");

print.addListener(new Button.ClickListener() {
	public void buttonClick(ClickEvent event) {
        // Create a window that contains what you want to print
        Window window = new Window("Window to Print");

        // Have some content to print
        window.addComponent(new Label(
                "<h1>Here's some dynamic content</h1>\n" +
                "<p>This is to be printed to the printer.</p>",
                Label.CONTENT_XHTML));

        // Add the printing window as a new application-level
        // window
        getApplication().addWindow(window);

        // Open it as a popup window with no decorations
        getWindow().open(new ExternalResource(window.getURL()),
                "_blank", 500, 200,  // Width and height 
                Window.BORDER_NONE); // No decorations

        // Print automatically when the window opens.
        // This call will block until the print dialog exits!
        window.executeJavaScript("print();");

        // Close the window automatically after printing
        window.executeJavaScript("self.close();");
    }
});]]></programlisting>

		<para>
			How the browser opens the window, as an actual (popup) window or just a tab, depends
			on the browser. Notice that calling the <methodname>print()</methodname> method in the
            window will block the entire application until the print dialog exits.

            <indexterm><primary><classname>Window</classname></primary><secondary>closing</secondary></indexterm>

            After printing, we automatically close the window with another JavaScript
            call, as there is no <methodname>close()</methodname> method in
            <classname>Window</classname>.
		</para>

        <indexterm startref="term.advanced.printing.print" class="endofrange"/>
        <indexterm startref="term.advanced.printing.JavaScript.print" class="endofrange"/>

		<para>
            <indexterm><primary>PDF</primary></indexterm>

			Printing as PDF would not require creating a <classname>Window</classname>
			object, but you would need to provide the content as a static or a dynamic
			resource for the <methodname>open()</methodname> method. Printing a PDF file
			would obviously require a PDF viewer cabability (such as Adobe Reader) in the
			browser.
		</para>

        <indexterm startref="term.advanced.printing" class="endofrange"/>
	</section>

	<section xml:id="advanced.gae">
		<title>Google App Engine Integration</title>

		<para>
			Vaadin includes support to run Vaadin applications in the Google App Engine
			(GAE). The most essential requirement for GAE is the ability to serialize the
			application state. Vaadin applications are serializable through the
			<classname>java.io.Serializable</classname> interface.
		</para>

		<para>
			To run as a GAE application, an application must use
			<classname>GAEApplicationServlet</classname> instead of
			<classname>ApplicationServlet</classname> in <filename>web.xml</filename>, and
			of course implement the <classname>java.io.Serializable</classname> interface
			for all persistent classes.  You also need to enable session support in
			<filename>appengine-web.xml</filename> with:
		</para>
		
		<programlisting><![CDATA[<sessions-enabled>true</sessions-enabled>]]></programlisting>

		<para>
			The Vaadin Project wizard can create the configuration files needed for GAE
			deployment. See <xref linkend="getting-started.first-project.creation"/>. When
			the Google App Engine deployment configuration is selected, the wizard will
			create the project structure following the GAE Servlet convention instead of
			the regular Servlet convention. The main differences are:
		</para>

		<itemizedlist>
			<listitem>Source directory: <filename>src/main/java</filename></listitem>
			<listitem>Output directory: <filename>war/WEB-INF/classes</filename></listitem>
			<listitem>Content directory: <filename>war</filename></listitem>
		</itemizedlist>

		<simplesect>
			<title>Rules and Limitations</title>

			<para>
				Running Vaadin applications in Google App Engine has the following rules
				and limitations:
			</para>
			
			<itemizedlist>
				<listitem><para>Avoid using the session for storage, usual App Engine
				limitations apply (no synchronization, that is, it is
				unreliable).</para></listitem>

				<listitem><para>Vaadin uses memcache for mutex, the key is of the form
				<parameter>_vmutex&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para>The Vaadin <classname>WebApplicationContext</classname>
				class is serialized separately into memcache and datastore; the memcache
				key is <parameter>_vac&lt;sessionid&gt;</parameter> and the datastore
				entity kind is <parameter>_vac</parameter> with identifiers of the type
				<parameter>_vac&lt;sessionid&gt;</parameter>.</para></listitem>

				<listitem><para><emphasis>Do not</emphasis> update the application state when serving an
				<classname>ApplicationResource</classname> (such as
				<classname>ClassResource</classname>.<methodname>getStream()</methodname>).</para></listitem>

				<listitem><para><emphasis>Avoid</emphasis> (or be very careful when)
				updating application state in a <classname>TransactionListener</classname>
				- it is called even when the application is not locked and won't be
				serialized (such as with <classname>ApplicationResource</classname>), and
				changes can therefore be lost (it should be safe to update things that can
				be safely discarded later, that is, valid only for the current
				request).</para></listitem>

				<listitem><para>The application remains locked during uploads - a progress
				bar is not possible.</para></listitem>
			</itemizedlist>
		</simplesect>
	</section>

	<section xml:id="advanced.security">
		<title>Common Security Issues</title>

		<section xml:id="advanced.security.sanitizing">
			<title>Sanitizing User Input to Prevent Cross-Site Scripting</title>
			
			<para>
				You can put raw XHTML content in many components, such as the
				<classname>Label</classname> and <classname>CustomLayout</classname>, as
				well as in tooltips and notifications. In such cases, you should make sure
				that if the content has any possibility to come from user input, the input
				is well sanitized before displaying it. Otherwise, a malicious user can
				easily make a cross-site scripting attack by injecting offensive
				JavaScript code in such components.
			</para>

			<para>
				Offensive code can easily be injected with
				<literal>&lt;script&gt;</literal> markup or in tag attributes as events,
				such as <parameter>onLoad</parameter>. Cross-site scripting
				vulnerabilities are browser dependent, depending on the situations in
				which different browsers execute scripting markup.
			</para>

			<para>
				There is no generic way to sanitize user input as different applications
				can allow different kinds of input. Pruning (X)HTML tags out is somewhat
				simple, but some applications may need to allow (X)HTML.  It is therefore
				the responsibility of the application to sanitize the input.
			</para>

			<para>
				Character encoding can make sanitization more difficult, as offensive tags
				can be encoded so that they are not recognized by a sanitizer. This can be
				done, for example, with HTML character entities and with variable-width
				encodings such as UTF-8 or various CJK encodings, by abusing multiple
				representations of a character. Most trivially, you could input
				<literal>&lt;</literal> and <literal>&gt;</literal> with
				<literal>&amp;lt;</literal> and <literal>&amp;gt;</literal>,
				respectively. The input could also be malformed and the sanitizer must be
				able to interpret it exactly as the browser would, and different browsers
				can interpret malformed HTML and variable-width character encodings
				differently.
			</para>

			<para>
				Notice that the problem applies also to user input from a
				<classname>RichTextArea</classname> is transmitted as XHTML from the
				browser to server-side and is not sanitized. As the entire purpose of the
				<classname>RichTextArea</classname> component is to allow input of
				formatted text, you can not just remove all HTML tags. Also many
				attributes, such as <parameter>style</parameter>, should pass through the
				sanitization.
			</para>

			<!-- NOTE: Document the rude HTML sanitization method when #3382 is closed. -->
		</section>
	</section>

	<section xml:id="advanced.urifu">
		<title>URI Fragment and History Management with <classname>UriFragmentUtility</classname></title>

        <para>
            <emphasis>This section is not yet updated for Vaadin 7. The
            <classname>UriFragmentUtility</classname> is obsolete in Vaadin 7 and URI
            fragment changes are handled with a
            <interfacename>FragmentChangedListener</interfacename> and
            <methodname>setFragment()</methodname> in the <classname>Page</classname>
            class, for example:
            <literal>Page.getCurrent().setFragment("foo")</literal>.</emphasis>
        </para>

        <para>
            A major issue in AJAX applications is that as they run in a single web page,
            bookmarking the application URL (or more generally the
            <emphasis>URI</emphasis>) can only bookmark the application, not an
            application state. This is a problem for many applications such as product
            catalogs and forums, in which it would be good to provide links to specific
            products or messages. Consequently, as browsers remember the browsing history
            by URI, the history and the <guibutton>Back</guibutton> button do not normally
            work. The solution is to use the <emphasis>fragment</emphasis> part of the
            URI, which is separated from the primary part (address + path + optional query
            parameters) of the URI with the hash (#) character. For example:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[http://example.com/path#myfragment]]></programlisting>

        <para>
            The exact syntax of the fragment part is defined in RFC 3986 (Internet
            standard STD 66) that defines the URI syntax. A fragment may only contain the
            regular URI <emphasis>path characters</emphasis> (see the standard) and
            additionally the slash and the question mark.
        </para>

        <para>
            The <classname>UriFragmentUtility</classname> is a special-purpose component
            that manages the URI fragment; it allows setting the fragment and to handle
            user-made changes to it. As it is a regular component, though invisible, you
            must add it to a layout in an application window with the
            <methodname>addComponent()</methodname>, as usual.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[public void init() {
    Window main = new Window("URI Fragment Example");
    setMainWindow(main);

    // Create the URI fragment utility
    final UriFragmentUtility urifu = new UriFragmentUtility();
    main.addComponent(urifu);]]></programlisting>

        <para>
            Notice that the utility component can work only when it is attached to the
            window, so in practice it must be added in the <methodname>init()</methodname>
            method of the application and must afterwards always remain in the
            application's user interface.
        </para>

        <para>
            You can set the URI fragment with the <methodname>setFragment()</methodname>
            method of the <classname>UriFragmentUtility</classname> object. The method takes the
            fragment as a string parameter. In the following example, we have a menu, from
            which the user can select the URI fragment.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Application state menu
final ListSelect menu = new ListSelect("Select a URI Fragment");
menu.addItem("mercury");
menu.addItem("venus");
menu.addItem("earth");
menu.addItem("mars");
menu.setImmediate(true);
main.addComponent(menu);

// Set the URI Fragment when menu selection changes
menu.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        String itemid = (String) event.getProperty().getValue();
        urifu.setFragment(itemid);
    }
});]]></programlisting>

        <para>
            The URI fragment and any changes to it are passed to an application as
            <classname>FragmentChangedEvent</classname>s, which you can handle with a
            <classname>FragmentChangedListener</classname>. You can get the new fragment
            value with the <methodname>getFragment()</methodname> method from the URI
            fragment utility component.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// When the URI fragment is given, use it to set menu selection 
urifu.addListener(new FragmentChangedListener() {
    public void fragmentChanged(FragmentChangedEvent source) {
        String fragment =
                  source.getUriFragmentUtility().getFragment();
        if (fragment != null)
            menu.setValue(fragment);
    }
});]]></programlisting>

        <para>
            <xref linkend="figure.advanced.urifu"/> shows an application that allows
            specifying the menu selection with a URI fragment and correspondingly sets the
            fragment when the user selects a menu item, as done in the code examples
            above.
        </para>

        <figure xml:id="figure.advanced.urifu">
            <title>Application State Management with URI Fragment Utility</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/urifu-1.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>

	<section xml:id="advanced.navigator">
		<title>Navigating in an Application</title>

        <para>
            Plain Vaadin applications do not have normal web page navigation as they
            usually run on a single page, as all Ajax applications do. Quite commonly,
            however, applications have different views between which the user should be
            able to navigate. The <classname>Navigator</classname> in Vaadin can be used
            for most cases of navigation. Views managed by the navigator automatically get
            a distinct URI fragment, which can be used to be able to bookmark the views
            and their states and to go back and forward in the browser history.
        </para>

        <section xml:id="application.navigator.navigating">
            <title>Setting Up for Navigation</title>

            <para>
                The <classname>Navigator</classname> class manages a collection of
                <emphasis>views</emphasis> that implement the
                <interfacename>View</interfacename> interface. The views can be either
                registered beforehand or acquired from a <emphasis>view
                provider</emphasis>.  When registering, the views must have a name
                identifier and be added to a navigator with
                <methodname>addView()</methodname>. You can register new views at any
                point. Once registered, you can navigate to them with
                <methodname>navigateTo()</methodname>.
            </para>

            <para>
                The views managed by the <classname>Navigator</classname> are displayed in a
                <interfacename>ViewDisplay</interfacename>. The framework includes a
                <classname>SimpleViewDisplay</classname> component, which can be used in most
                cases to display views.
            </para>

            <para>
                Let us consider the following application with two views: start and
                main. Here, we define their names with enums to be typesafe.
            </para>

            <book-example id="advanced.navigator.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[public class NavigatorRoot extends Root {
    Navigator  navigator;
    
    enum Views {START, MAIN};

    @Override
    protected void init(WrappedRequest request) {
        getPage().setTitle("Navigation Example");
        
        // Fill the page with a view display
        SimpleViewDisplay viewDisplay = new SimpleViewDisplay();
        viewDisplay.setSizeFull();
        setContent(viewDisplay);

        // Create the navigator to control the page
        navigator = new Navigator(Page.getCurrent(),
                                  viewDisplay);
        
        // Create and register the views
        navigator.addView(Views.START.name(), new StartView());
        navigator.addView(Views.MAIN.name(), new MainView());

        // Navigate to the start view
        navigator.navigateTo(Views.START.name());
    }
}]]></programlisting>

            <para>
                The <classname>Navigator</classname> automatically sets the URI fragment
                of the application URL.  It also registers a
                <interfacename>FragmentChangeListener</interfacename> in the page (see
                <xref linkend="advanced.urifu"/>) to show the view identified by the URI
                fragment if entered or navigated to in the browser. This also enables
                browser navigation history in the application.
            </para>

            <section xml:id="application.navigator.navigating.viewprovider">
                <title>View Providers</title>

                <para>
                    You can create new views dynamically using a <emphasis>view
                    provider</emphasis> that implement the
                    <interfacename>ViewProvider</interfacename> interface. A provider is
                    registered in <classname>Navigator</classname> with
                    <methodname>registerProvider()</methodname>.
                </para>

                <para>
                    The <methodname>ClassBasedViewProvider</methodname> is a view provider
                    that can dynamically create new instances of a specified view class
                    based on the view name.
                </para>

                <para>
                    The <methodname>StaticViewProvider</methodname> returns an existing
                    view instance based on the view name. The
                    <methodname>addView()</methodname> in <classname>Navigator</classname>
                    is actually just a shorthand for creating a static view provider for
                    each registered view.
                </para>
           </section>

            <section xml:id="application.navigator.navigating.viewchangelistener">
                <title>View Change Listeners</title>

                <para>
                    You can handle view changes also by implementing a
                    <interfacename>ViewChangeListener</interfacename> and adding it to a
                    <classname>Navigator</classname>. When a view change occurs, a
                    listener receives a <classname>ViewChangeEvent</classname> object,
                    which has references to the old and the activated view, the name of
                    the activated view, as well as the fragment parameters.
                </para>
            </section>
        </section>

        <section xml:id="application.navigator.view">
            <title>Implementing a View</title>

            <para>
                Views can be any objects that implement the
                <interfacename>View</interfacename> interface. When the
                <methodname>navigateTo()</methodname> is called for the navigator, or the
                application is opened with the URI fragment associated with the view, it
                switches to the view and calls its <methodname>navigateTo()</methodname>
                method.
            </para>

            <para>
                To continue with the example, consider the following simple view just lets the
                user to navigate to the other view. It doesn't do anything special when the
                user navigates to it.
            </para>

            <book-example id="advanced.navigator.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[/** A start view for navigating to the main view */
public class StartView extends VerticalLayout implements View {
    public StartView() {
        setSizeFull();

        Button button = new Button("Go to Main View",
                new Button.ClickListener() {
            @Override
            public void buttonClick(ClickEvent event) {
                navigator.navigateTo(Views.MAIN.name());
            }
        });
        addComponent(button);
        setComponentAlignment(button, Alignment.MIDDLE_CENTER);
    }        
        
    @Override
    public void navigateTo(String fragmentParameters) {
        // Nothing to do here really
    }
}]]></programlisting>
        </section>

        <section xml:id="application.navigator.urifragment">
            <title>Handling URI Fragment Path</title>

            <para>
                URI fragments can be used with <classname>Navigator</classname> in two
                ways: for navigating to a specific view and for navigating to a state
                within the view. The URI fragment accepted by
                <methodname>navigateTo()</methodname> can have the view name at the root,
                followed by fragment parameters after a slash
                ("<literal>/</literal>"). These parameters are passed to the
                <methodname>navigateTo()</methodname> method in the
                <interfacename>View</interfacename>.
            </para>

            <para>
                In the following example, we implement within-view navigation.
            </para>

            <book-example id="advanced.navigator.basic" style="float: right"/>
            <programlisting><?pocket-size 65% ?><![CDATA[/** Main view with a menu */
public class MainView extends VerticalLayout implements View {

    // Menu navigation button listener
    class ButtonListener implements Button.ClickListener {
        String menuitem;
        public ButtonListener(String menuitem) {
            this.menuitem = menuitem;
        }

        @Override
        public void buttonClick(ClickEvent event) {
            // Navigate to a specific state
            navigator.navigateTo(Views.MAIN.name() +
                                 "/" + menuitem);
        }
    }

    public MainView() {
        setSizeFull();
        
        // Layout with menu on left and view area on right
        HorizontalLayout hLayout = new HorizontalLayout();
        hLayout.setSizeFull();

        // Have a menu on the left side of the screen
        Panel menu = new Panel("Menu");
        menu.addComponent(new Button("Cat",
                  new ButtonListener("cat")));
        menu.addComponent(new Button("Dog",      
                  new ButtonListener("dog")));
        menu.addComponent(new Button("Reindeer",
                  new ButtonListener("reindeer")));
        menu.addComponent(new Button("Penguin",
                  new ButtonListener("penguin")));
        menu.addComponent(new Button("Sheep",
                  new ButtonListener("sheep")));
        menu.setHeight("100%");
        menu.setWidth(null);
        menu.getContent().setWidth(null);
        hLayout.addComponent(menu);

        // Have a panel that contains a content area on the right
        panel = new Panel("Content Panel");
        panel.setSizeFull();
        hLayout.addComponent(panel);
        hLayout.setExpandRatio(panel, 1.0f);

        addComponent(hLayout);
        setExpandRatio(hLayout, 1.0f);
        
        // Allow going back to the start
        Button logout = new Button("Logout",
                   new Button.ClickListener() {
            @Override
            public void buttonClick(ClickEvent event) {
                navigator.navigateTo(Views.START.name());
            }
        });
        addComponent(logout);
    }        
    
    @Override
    public void navigateTo(String fragmentParameters) {
        panel.removeAllComponents();

        if (fragmentParameters == null) {
            panel.addComponent(
                new Label("Nothing to see here, " +
                          "just pass along."));
            return;
        }

        // Display some content
        panel.addComponent(
            new Label("You are currently watching a " +
                      fragmentParameters));
        panel.addComponent(new Embedded(null,
            new ThemeResource("img/" + fragmentParameters +
                              "-128px.png")));
    }
}]]></programlisting>

            <para>
                The main view is shown in <xref
                    linkend="figure.advanced.navigator.mainview"/>. At this point, the URL would
                be <literal>http://localhost:8080/myapp#MAIN/reindeer</literal>.
            </para>

            <figure xml:id="figure.advanced.navigator.mainview">
                <title>Navigator Main View</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/advanced/navigator-mainview.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
    </section>

    <!-- TODO Vaadin 7: Rewrite 
    <section xml:id="advanced.httpservletrequestlistener">
        <title>Capturing HTTP Requests</title>

        <indexterm xml:id="term.advanced.httpservletrequestlistener" class="startofrange">
            <primary>HttpServletRequestListener</primary>
        </indexterm>

        <para>
            Behind the event-driven processing model of Vaadin lies the Java Servlet API,
            which is based on processing HTTP requests. These requests are normally
            hidden from Vaadin applications, but can be caught using the
            <classname>HttpServletRequestListener</classname> interface. You must
            implement the interface in your application class. The two methods defined in
            the interface, <methodname>onRequestStart()</methodname> and
            <methodname>onRequestEnd()</methodname>, allow processing the request before
            and after other processing.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.vaadin.Application;
import com.vaadin.terminal.gwt.server.HttpServletRequestListener;
import com.vaadin.ui.*;

public class HttpServletRequestApplication extends Application
       implements HttpServletRequestListener {

    @Override
    public void init() {
        System.out.println("  Application.init() called.");
        
        Window main = new Window("URI Fragment Example");
        setMainWindow(main);
                
        // Does nothing but causes a request
        Button button = new Button ("Make a request");
        main.addComponent(button);
    }

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        System.out.println("[Start of request");
        System.out.println(" Query string: " +
                           request.getQueryString());
        System.out.println(" Path: " +
                           request.getPathInfo());
    }

    public void onRequestEnd(HttpServletRequest request,
                             HttpServletResponse response) {
        System.out.println(" End of request]");
    }
}]]></programlisting>

        <para>
            The <methodname>onRequestStart()</methodname> is called for the first time
            when the application class is loaded but the <methodname>init()</methodname>
            is not yet called. This can be seen in the output of the above code example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[[Start of request
 Query string: null
 Path: null
  Application.init() called.
 End of request]
[Start of request
 Query string: repaintAll=1&sh=1050&sw=1680&cw=500&ch=300&vw=500
 Path: /UIDL/
 End of request]
[Start of request
 Query string: windowName=1071684214
 Path: /UIDL/
 End of request]]]></programlisting>

        <para>
            The first call is a regular HTML page load, so the URL path is simply the
            application path. The subsequent calls are AJAX calls made using the UIDL
            protocol, so the request path includes the <literal>/UIDL/</literal> part. This is
            important to know when using cookies, as explained later.
        </para>

        <section>
            <title>Using Request and Response Objects</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletrequest" class="startofrange">
                <primary>HttpServletRequest</primary>
            </indexterm>
            <indexterm xml:id="term.advanced.httpservletrequestlistener.httpservletresponse" class="startofrange">
                <primary>HttpServletResponse</primary>
            </indexterm>
            
            <para>
                The <classname>HttpServletRequest</classname> object provides access to
                the request data, such as request headers, path info, and query string, as
                well as to some higher-level information such as cookies.
            </para>

            <para>
                The <classname>HttpServletResponse</classname> object is somewhat
                different, as most write operations write data directly to the output
                stream of the server request. It is therefore possible to add new headers
                and cookies in the <methodname>onRequestStart()</methodname>, and make
                other settings, but not later on, especially not in the
                <methodname>onRequestEnd()</methodname>, as all the UIDL response data has
                already been written to the output stream. The framework writes the UIDL
                response to the output stream of the response <emphasis>before</emphasis>
                calling <methodname>onRequestEnd()</methodname>. You therefore have to be
                careful when writing to the response object. You can usually write to it
                when handling component events in listeners, as is done in the cookie
                example later.
            </para>

            <para>
                While it is theoretically possible to redirect the output stream of the
                response object to write custom data to the response, you should never
                need to do that, as it would break the UIDL communication protocol.
            </para>
        
            <para>
                The servlet request and response objects are defined in the Java Servlet
                API. Please refer to its documentation for more detailed information.
            </para>

            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletrequest" class="endofrange"/>
            <indexterm startref="term.advanced.httpservletrequestlistener.httpservletresponse" class="endofrange"/>
        </section>

        <section>
            <title>Managing Cookies</title>

            <indexterm xml:id="term.advanced.httpservletrequestlistener.cookies" class="startofrange">
                <primary>cookies</primary>
            </indexterm>

            <para>
                Setting and reading cookies is one of the typical uses of
                <classname>HttpServletRequestListener</classname>. The application gets
                the <classname>HttpServletRequest</classname> object containing the
                cookies in the <methodname>onRequestStart()</methodname> method.
            </para>

            <section>
                <title>Setting a Cookie</title>

                <para>
                    You normally set a cookie in an event listener. As the request object
                    is a transient object that exists only for the duration of the
                    request, it is not accessible from the
                    <classname>Application</classname> object. The only way to access it
                    is to store it in <methodname>onRequestStart()</methodname>, as done
                    in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    HttpServletResponse response;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        // Store the reference to the response object for
        // using it in event listeners
        this.response = response;
        ...
   }
   ...]]></programlisting>

                <para>
                    We can then use the reference to set or delete cookies in event
                    listeners. Notice that the <emphasis>cookie path</emphasis> property
                    is automatically set to the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent calls
                    (such as <filename>/book-examples/cookies/UIDL</filename>). As the
                    cookies are matched against this path, you may need to set the path
                    explicitly with <methodname>setPath()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[newuser = new TextField ("Give a user name");
login = new Button("Login");
login.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        Object value = newuser.getValue(); 
        if (value != null &&
            ! "".equals((String)value)) {
            username = (String) value;

            Cookie cookie = new Cookie("username",
                                       username);
            // Use a fixed path
            cookie.setPath("/book-examples");
            cookie.setMaxAge(3600); // One hour
            response.addCookie(cookie);
            System.out.println("Set cookie.");

            newuser.setEnabled(false);
            login.setEnabled(false);
            restart.setEnabled(true);
            logout.setEnabled(true);
        }
    }
});
loginrow.addComponent(newuser);
loginrow.addComponent(login);]]></programlisting>

                <para>
                    Removing cookie can be set in similar way by setting the
                    <emphasis>maxAge</emphasis> property to zero.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Delete the cookie
Cookie cookie = new Cookie("username", username);
cookie.setPath("/book-examples");
cookie.setMaxAge(0); // Delete
response.addCookie(cookie);]]></programlisting>
            </section>

            <section>
                <title>Reading a Cookie</title>

                <para>
                    Reading a cookie can be done in the
                    <methodname>onRequestStart()</methodname> event. As this method is
                    called also on the first client request before the application is
                    initialized, it is possible to read user identification cookies and
                    such on the first request.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public class CookieExampleApplication extends Application
       implements HttpServletRequestListener {
    String username;

    public void onRequestStart(HttpServletRequest request,
                               HttpServletResponse response) {
        if (username == null) {
            Cookie[] cookies = request.getCookies();
            for (int i=0; i<cookies.length; i++) {
                if ("username".equals(cookies[i].getName()))
                    // Log the user in automatically
                    username = cookies[i].getValue();
            }
        }
    }
    ...]]></programlisting>

                <para>
                    Notice that the request path is the application path (such as
                    <filename>/book-examples/cookies</filename>) on the first request, but
                    contains the <filename>UIDL</filename> subpath on subsequent AJAX
                    calls (such as <filename>/book-examples/cookies/UIDL</filename>). So,
                    if you have set the cookie in an AJAX request without setting the
                    cookie path explicitly to such that does not contain the
                    <filename>UIDL</filename> subpath, the cookie will be filtered out on
                    the initial <methodname>onRequestStart()</methodname> call.
                </para>
            </section>

            <indexterm startref="term.advanced.httpservletrequestlistener.cookies" class="endofrange"/>
        </section>

        <indexterm startref="term.advanced.httpservletrequestlistener" class="endofrange"/>
    </section>
    -->

    <section xml:id="advanced.dragndrop">
        <title>Drag and Drop</title>

        <indexterm xml:id="term.advanced.dragndrop" class="startofrange">
            <primary>Drag and Drop</primary>
        </indexterm>

        <para>
            Dragging an object from one location to another by grabbing it with mouse,
            holding the mouse button pressed, and then releasing the button to "drop" it
            to the other location is a common way to move, copy, or associate objects. For
            example, most operating systems allow dragging and dropping files between
            folders or dragging a document on a program to open it. In Vaadin, it is
            possible to drag and drop components and parts of certain components.
        </para>

        <para>
            Dragged objects, or <emphasis>transferables</emphasis>, are essentially data
            objects. You can drag and drop rows in <classname>Table</classname> and nodes
            in <classname>Tree</classname> components, either within or between the
            components. You can also drag entire components by wrapping them inside
            <classname>DragAndDropWrapper</classname>.
        </para>

        <para>
            Dragging starts from a <emphasis>drag source</emphasis>, which defines the
            transferable. Transferables implement the <classname>Transferable</classname>
            interfaces. For trees and tables, which are bound to
            <classname>Container</classname> data sources, a node or row transferable is a
            reference to an <classname>Item</classname> in the Vaadin Data Model. Dragged
            components are referenced with a
            <classname>WrapperTransferable</classname>. Starting dragging does not require
            any client-server communication, you only need to enable dragging. All drag
            and drop logic occurs in two operations: determining
            (<emphasis>accepting</emphasis>) where dropping is allowed and actually
            dropping. Drops can be done on a <emphasis>drop target</emphasis>, which
            implements the <classname>DropTarget</classname> interface. Three components
            implement the interface: <classname>Tree</classname>,
            <classname>Table</classname>, and
            <classname>DragAndDropWrapper</classname>. These accept and drop operations
            need to be provided in a <emphasis>drop handler</emphasis>. Essentially all
            you need to do to enable drag and drop is to enable dragging in the drag
            source and implement the <methodname>getAcceptCriterion()</methodname> and
            <methodname>drop()</methodname> methods in the
            <classname>DropHandler</classname> interface.
        </para>

        <para>
            The client-server architecture of Vaadin causes special requirements for the
            drag and drop functionality. The logic for determining where a dragged object
            can be dropped, that is, <emphasis>accepting</emphasis> a drop, should
            normally be done on the client-side, in the browser. Server communications are
            too slow to have much of such logic on the server-side. The drag and drop
            feature therefore offers a number of ways to avoid the server communications
            to ensure a good user experience.
        </para>

        <section xml:id="advanced.dragndrop.drophandler">
            <title>Handling Drops</title>

            <para>
                Most of the user-defined drag and drop logic occurs in a <emphasis>drop
                handler</emphasis>, which is provided by implementing the
                <methodname>drop()</methodname> method in the
                <classname>DropHandler</classname> interface. A closely related definition
                is the drop accept criterion, which is defined in the
                <methodname>getAcceptCriterion()</methodname> method in the same
                interface. It is described in <xref
                linkend="advanced.dragndrop.acceptcriteria"/> later.
            </para>

            <para>
                The <methodname>drop()</methodname> method gets a
                <classname>DragAndDropEvent</classname> as its parameters. The event
                object provides references to two important object:
                <classname>Transferable</classname> and
                <classname>TargetDetails</classname>.
            </para>

            <para>
                A <classname>Transferable</classname> contains a reference to the object
                (component or data item) that is being dragged. A tree or table item is
                represented as a <classname>TreeTransferable</classname> or
                <classname>TableTransferable</classname> object, which carries the item
                identifier of the dragged tree or table item. These special transferables,
                which are bound to some data in a container, are
                <classname>DataBoundTransferable</classname>. Dragged components are
                represented as <classname>WrapperTransferable</classname> objects, as the
                components are wrapped in a <classname>DragAndDropWrapper</classname>.
            </para>

            <para>
                The <classname>TargetDetails</classname> object provides information about
                the exact location where the transferable object is being dropped. The
                exact class of the details object depends on the drop target and you need
                to cast it to the proper subclass to get more detailed information. If the
                target is selection component, essentially a tree or a table, the
                <classname>AbstractSelectTargetDetails</classname> object tells the item
                on which the drop is being made. For trees, the
                <classname>TreeTargetDetails</classname> gives some more details. For
                wrapped components, the information is provided in a
                <classname>WrapperDropDetails</classname> object. In addition to the
                target item or component, the details objects provide a <emphasis>drop
                location</emphasis>. For selection components, the location can be
                obtained with the <methodname>getDropLocation()</methodname> and for
                wrapped components with <methodname>verticalDropLocation()</methodname>
                and <methodname>horizontalDropLocation()</methodname>. The locations are
                specified as either <classname>VerticalDropLocation</classname> or
                <classname>HorizontalDropLocation</classname> objects. The drop location
                objects specify whether the transferable is being dropped above, below, or
                directly on (at the middle of) a component or item.
            </para>

            <para>
                Dropping on a <classname>Tree</classname>, <classname>Table</classname>,
                and a wrapped component is explained further in the following sections.
            </para>
        </section>

        <section xml:id="advanced.dragndrop.treedrop">
            <title>Dropping Items On a <classname>Tree</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Tree</classname>. Making tree a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Tree</classname>
                currently supports only one drag mode,
                <literal>TreeDragMode.NODE</literal>, which allows dragging single tree
                nodes. While dragging, the dragged node is referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. The tree node is identified
                by the item ID of the container item.
            </para>

            <para>
                When a transferable is dropped on a tree, the drop location is stored in a
                <classname>TreeTargetDetails</classname> object, which identifies the
                target location by item ID of the tree node on which the drop is made. You
                can get the item ID with <methodname>getItemIdOver()</methodname> method
                in <classname>AbstractSelectTargetDetails</classname>, which the
                <classname>TreeTargetDetails</classname> inherits. A drop can occur
                directly on or above or below a node; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method.
            </para>

            <para>
                In the example below, we have a <classname>Tree</classname> and we allow
                reordering the tree items by drag and drop.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final Tree tree = new Tree("Inventory");
tree.setContainerDataSource(TreeExample.createTreeContent());
layout.addComponent(tree);
        
// Expand all items
for (Iterator<?> it = tree.rootItemIds().iterator(); it.hasNext();)
    tree.expandItemsRecursively(it.next());
        
// Set the tree in drag source mode
tree.setDragMode(TreeDragMode.NODE);
        
// Allow the tree to receive drag drops and handle them
tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }

    public void drop(DragAndDropEvent event) {
        // Wrapper for the object that is dragged
        Transferable t = event.getTransferable();
        
        // Make sure the drag source is the same tree
        if (t.getSourceComponent() != tree)
            return;
        
        TreeTargetDetails target = (TreeTargetDetails)
            event.getTargetDetails();

        // Get ids of the dragged item and the target item
        Object sourceItemId = t.getData("itemId");
        Object targetItemId = target.getItemIdOver();

        // On which side of the target the item was dropped 
        VerticalDropLocation location = target.getDropLocation();
        
        HierarchicalContainer container = (HierarchicalContainer)
        tree.getContainerDataSource();

        // Drop right on an item -> make it a child
        if (location == VerticalDropLocation.MIDDLE)
            tree.setParent(sourceItemId, targetItemId);

        // Drop at the top of a subtree -> make it previous
        else if (location == VerticalDropLocation.TOP) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
            container.moveAfterSibling(targetItemId, sourceItemId);
        }
        
        // Drop below another item -> make it next 
        else if (location == VerticalDropLocation.BOTTOM) {
            Object parentId = container.getParent(targetItemId);
            container.setParent(sourceItemId, parentId);
            container.moveAfterSibling(sourceItemId, targetItemId);
        }
    }
});]]></programlisting>

            <section>
                <title>Accept Criteria for Trees</title>

                <para>
                    <classname>Tree</classname> defines some specialized accept
                    criteria for trees.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TargetInSubtree</classname> (client-side)</term>
                        <listitem>
                            Accepts if the target item is in the specified sub-tree. The
                            sub-tree is specified by the item ID of the root of the
                            sub-tree in the constructor. The second constructor includes a
                            depth parameter, which specifies how deep from the given root
                            node are drops accepted. Value <literal>-1</literal> means
                            infinite, that is, the entire sub-tree, and is therefore the
                            same as the simpler constructor.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemAllowsChildren</classname> (client-side)</term>
                        <listitem>
                            Accepts a drop if the tree has
                            <methodname>setChildrenAllowed()</methodname> enabled for the
                            target item. The criterion does not require parameters, so the
                            class is a singleton and can be acquired with
                            <methodname>Tree.TargetItemAllowsChildren.get()</methodname>. For
                            example, the following composite criterion accepts drops only
                            on nodes that allow children, but between all nodes:

                            <programlisting><?pocket-size 65% ?><![CDATA[return new Or (Tree.TargetItemAllowsChildren.get(), new Not(VerticalLocationIs.MIDDLE));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TreeDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops on only some items, which as specified by a set
                            of item IDs. You must extend the abstract class and implement
                            the <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target nodes is loaded only once
                            from the server for each drag operation. See <xref
                            linkend="advanced.dragndrop.acceptcriteria"/> for an example.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, the accept criteria defined in
                    <classname>AbstractSelect</classname> are available for a
                    <classname>Tree</classname>, as listed in <xref
                    linkend="advanced.dragndrop.acceptcriteria"/>.
                </para>
            </section>
            
        </section>

        <section xml:id="advanced.dragndrop.tabledrop">
            <title>Dropping Items On a <classname>Table</classname></title>

            <para>
                You can drag items from, to, or within a
                <classname>Table</classname>. Making table a drag source requires simply
                setting the drag mode with
                <methodname>setDragMode()</methodname>. <classname>Table</classname>
                supports dragging both single rows, with
                <literal>TableDragMode.ROW</literal>, and multiple rows, with
                <literal>TableDragMode.MULTIROW</literal>. While dragging, the dragged
                node or nodes are referenced with a
                <classname>TreeTransferable</classname> object, which is a
                <classname>DataBoundTransferable</classname>. Tree nodes are identified by
                the item IDs of the container items.
            </para>

            <para>
                When a transferable is dropped on a table, the drop location is stored in
                a <classname>AbstractSelectTargetDetails</classname> object, which
                identifies the target row by its item ID. You can get the item ID with
                <methodname>getItemIdOver()</methodname> method. A drop can occur directly
                on or above or below a row; the exact location is a
                <classname>VerticalDropLocation</classname>, which you can get with the
                <methodname>getDropLocation()</methodname> method from the details object.
            </para>

            <section>
                <title>Accept Criteria for Tables</title>

                <para>
                    <classname>Table</classname> defines one specialized accept
                    criterion for tables.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>TableDropCriterion</classname> (server-side)</term>
                        <listitem>
                            Accepts drops only on (or above or below) items that are
                            specified by a set of item IDs. You must extend the abstract
                            class and implement the
                            <methodname>getAllowedItemIds()</methodname> to return the
                            set. While the criterion is server-side, it is lazy-loading,
                            so that the list of accepted target items is loaded only once
                            from the server for each drag operation.
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
        </section>

        <section xml:id="advanced.dragndrop.acceptcriteria">
            <title>Accepting Drops</title>

            <indexterm xml:id="term.advanced.dragndrop.acceptcriteria" class="startofrange">
                <primary>Drag and Drop</primary>
                <secondary>Accept Criteria</secondary>
            </indexterm>

            <para>
                You can not drop the objects you are dragging around just anywhere. Before
                a drop is possible, the specific drop location on which the mouse hovers
                must be <emphasis>accepted</emphasis>. Hovering a dragged object over an
                accepted location displays an <emphasis>accept indicator</emphasis>, which
                allows the user to position the drop properly. As such checks have to be
                done all the time when the mouse pointer moves around the drop targets, it
                is not feasible to send the accept requests to the server-side, so drops
                on a target are normally accepted by a client-side <emphasis>accept
                criterion</emphasis>.
            </para>

            <para>
                A drop handler must define the criterion on the objects which it accepts
                to be dropped on the target. The criterion needs to be provided in the
                <classname>getAcceptCriterion()</classname> method of the
                <classname>DropHandler</classname> interface. A criterion is represented
                in an <classname>AcceptCriterion</classname> object, which can be a
                composite of multiple criteria that are evaluated using logical
                operations. There are two basic types of criteria:
                <emphasis>client-side</emphasis> and <emphasis>server-side
                criteria</emphasis>. The various built-in criteria allow accepting drops
                based on the identity of the source and target components, and on the
                <emphasis>data flavor</emphasis> of the dragged objects.
            </para>

            <para>
                To allow dropping any transferable objects, you can return a universal
                accept criterion, which you can get with
                <methodname>AcceptAll.get()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[tree.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    ...]]></programlisting>

            <section>
                <title>Client-Side Criteria</title>

                <para>
                    The <emphasis>client-side criteria</emphasis>, which inherit the
                    <classname>ClientSideCriterion</classname>, are verified on the
                    client-side, so server requests are not needed for verifying whether each
                    component on which the mouse pointer hovers would accept a certain object.
                </para>

                <para>
                    The following client-side criteria are define in
                    <package>com.vaadin.event.dd.acceptcriterion</package>:
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptAll</classname></term>
                        <listitem>
                            Accepts all transferables and targets.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>And</classname></term>
                        <listitem>
                            Logical AND operation on two client-side criterion; accepts
                            the transferable if all the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>ContainsDataFlavour</classname></term>
                        <listitem>
                            The transferable must contain the defined
                            data flavour.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Not</classname></term>
                        <listitem>
                            Logical NOT operation on two client-side criterion; accepts
                            the transferable if and only if the sub-criterion does not
                            accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>Or</classname></term>
                        <listitem>
                            Logical OR operation on two client-side criterion; accepts
                            the transferable if any of the defined sub-criteria accept it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIs</classname></term>
                        <listitem>
                            Accepts all transferables from any of the given source
                            components
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>SourceIsTarget</classname></term>
                        <listitem>
                            Accepts the transferable only if the source component is the
                            same as the target. This criterion is useful for ensuring that
                            items are dragged only within a tree or a table, and not from
                            outside it.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetDetailIs</classname></term>
                        <listitem>
                            Accepts any transferable if the target detail, such as the
                            item of a tree node or table row, is of the given data flavor
                            and has the given value.
                        </listitem>
                    </varlistentry>
                </variablelist>

                <para>
                    In addition, target components such as <classname>Tree</classname> and
                    <classname>Table</classname> define some component-specific
                    client-side accept criteria. See <xref
                    linkend="advanced.dragndrop.treedrop"/> for more details.
                </para>

                <para>
                    <classname>AbstractSelect</classname> defines the following criteria
                    for all selection components, including <classname>Tree</classname>
                    and <classname>Table</classname>.
                </para>

                <variablelist>
                    <varlistentry>
                        <term><classname>AcceptItem</classname></term>
                        <listitem>
                            Accepts only specific items from a specific selection
                            component. The selection component, which must inherit
                            <classname>AbstractSelect</classname>, is given as the first
                            parameter for the constructor. It is followed by a list of
                            allowed item identifiers in the drag source.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>AcceptItem.ALL</classname></term>
                        <listitem>
                            Accepts all transferables as long as they are items.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>TargetItemIs</classname></term>
                        <listitem>
                            Accepts all drops on the specified target items. The
                            constructor requires the target component
                            (<classname>AbstractSelect</classname>) followed by a list of
                            allowed item identifiers.
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>VerticalLocationIs.MIDDLE</classname>,
                        <classname>TOP</classname>, and
                        <classname>BOTTOM</classname></term>
                        <listitem>
                            The three static criteria accepts drops on, above, or below an
                            item. For example, you could accept drops only in between
                            items with the following:

                            <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    return new Not(VerticalLocationIs.MIDDLE);
}]]></programlisting>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>

            <section>
                <title>Server-Side Criteria</title>

                <para>
                    The <emphasis>server-side criteria</emphasis> are verified on the
                    server-side with the <methodname>accept()</methodname> method of the
                    <classname>ServerSideCriterion</classname> class. This allows fully
                    programmable logic for accepting drops, but the negative side is that
                    it causes a very large amount of server requests. A request is made
                    for every target position on which the pointer hovers. This problem is
                    eased in many cases by the component-specific lazy loading criteria
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname>. They do the server visit
                    once for each drag and drop operation and return all accepted rows or 
                    nodes for current <classname>Transferable</classname> at once.
                </para>

                <para>
                    The <methodname>accept()</methodname> method gets the drag event as a
                    parameter so it can perform its logic much like in
                    <methodname>drop()</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any other
    // location except on nodes that may not have children
    ServerSideCriterion criterion = new ServerSideCriterion() {
        public boolean accept(DragAndDropEvent dragEvent) {
            TreeTargetDetails target = (TreeTargetDetails)
                dragEvent.getTargetDetails();

            // The tree item on which the load hovers
            Object targetItemId = target.getItemIdOver();

            // On which side of the target the item is hovered
            VerticalDropLocation location = target.getDropLocation();
            if (location == VerticalDropLocation.MIDDLE)
                if (! tree.areChildrenAllowed(targetItemId))
                    return false; // Not accepted

            return true; // Accept everything else
        }
    };
    return criterion;
}]]></programlisting>
                
                <para>
                    The server-side criteria base class
                    <classname>ServerSideCriterion</classname> provides a generic
                    <methodname>accept()</methodname> method. The more specific
                    <classname>TableDropCriterion</classname> and
                    <classname>TreeDropCriterion</classname> are conveniency extensions
                    that allow definiting allowed drop targets as a set of items. They
                    also provide some optimization by lazy loading, which reduces server
                    communications significantly.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {
    // Server-side accept criterion that allows drops on any
    // other tree node except on node that may not have children
    TreeDropCriterion criterion = new TreeDropCriterion() {
        @Override
        protected Set<Object> getAllowedItemIds(
                DragAndDropEvent dragEvent, Tree tree) {
            HashSet<Object> allowed = new HashSet<Object>();
            for (Iterator<Object> i =
                   tree.getItemIds().iterator(); i.hasNext();) {
                Object itemId = i.next();
                if (tree.hasChildren(itemId))
                    allowed.add(itemId);
            }
            return allowed;
        }
    };
    return criterion;
}]]></programlisting>

            </section>

            <section>
                <title>Accept Indicators</title>

                <para>
                    When a dragged object hovers on a drop target, an <emphasis>accept
                    indicator</emphasis> is displayed to show whether or not the location
                    is accepted. For <parameter>MIDDLE</parameter> location, the indicator
                    is a box around the target (tree node, table row, or component). For
                    vertical drop locations, the accepted locations are shown as
                    horizontal lines, and for horizontal drop locations as vertical lines.
                </para>

                <para>
                    For <classname>DragAndDropWrapper</classname> drop targets, you can
                    disable the accept indicators or <emphasis>drag hints</emphasis> with
                    the <parameter>no-vertical-drag-hints</parameter>,
                    <parameter>no-horizontal-drag-hints</parameter>, and
                    <parameter>no-box-drag-hints</parameter> styles. You need to add the
                    styles to the <emphasis>layout that contains</emphasis> the wrapper,
                    not to the wrapper itself.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a wrapper
DragAndDropWrapper wrapper = new DragAndDropWrapper(c);
layout.addComponent(wrapper);

// Disable the hints
layout.addStyleName("no-vertical-drag-hints");
layout.addStyleName("no-horizontal-drag-hints");
layout.addStyleName("no-box-drag-hints");]]></programlisting>

                <!-- TODO: Document also styles for the Tree and Table. -->
            </section>

            <indexterm startref="term.advanced.dragndrop.acceptcriteria" class="endofrange"/>
        </section>

        <section>
            <title>Dragging Components</title>

            <para>
                Dragging a component requires wrapping the source component within a
                <classname>DragAndDropWrapper</classname>. You can then allow dragging by
                putting the wrapper (and the component) in drag mode with
                <methodname>setDragStartMode()</methodname>. The method supports two drag
                modes: <parameter>DragStartMode.WRAPPER</parameter> and
                <parameter>DragStartMode.COMPONENT</parameter>, which defines whether the
                entire wrapper is shown as the drag image while dragging or just the
                wrapped component.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have a component to drag
final Button button = new Button("An Absolute Button");

// Put the component in a D&D wrapper and allow dragging it
final DragAndDropWrapper buttonWrap = new DragAndDropWrapper(button);
buttonWrap.setDragStartMode(DragStartMode.COMPONENT);

// Set the wrapper to wrap tightly around the component
buttonWrap.setSizeUndefined();
        
// Add the wrapper, not the component, to the layout
layout.addComponent(buttonWrap, "left: 50px; top: 50px;");]]></programlisting>

            <para>
                The default height of <classname>DragAndDropWrapper</classname> is
                undefined, but the default width is 100%. If you want to ensure that the
                wrapper fits tightly around the wrapped component, you should call
                <methodname>setSizeUndefined()</methodname> for the wrapper. Doing so, you
                should make sure that the wrapped component does not have a relative size,
                which would cause a paradox.
            </para>

            <para>
                Dragged components are referenced in the
                <classname>WrapperTransferable</classname>. You can get the reference to
                the dragged component with
                <methodname>getDraggedComponent()</methodname>. The method will return
                <literal>null</literal> if the transferable is not a component. Also HTML
                5 drags (see later) are held in wrapper transferables.
            </para>

        </section>

        <section xml:id="advanced.dragndrop.drop-on-component">
            <title>Dropping on a Component</title>

            <para>
                Drops on a component are enabled by wrapping the component in a
                <classname>DragAndDropWrapper</classname>. The wrapper is an ordinary
                component; the constructor takes the wrapped component as a parameter. You
                just need to define the <classname>DropHandler</classname> for the wrapper
                with <methodname>setDropHandler()</methodname>.
            </para>

            <para>
                In the following example, we allow moving components in an absolute
                layout. Details on the drop handler are given later.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// A layout that allows moving its contained components
// by dragging and dropping them
final AbsoluteLayout absLayout = new AbsoluteLayout();
absLayout.setWidth("100%");
absLayout.setHeight("400px");

... put some (wrapped) components in the layout ...

// Wrap the layout to allow handling drops
DragAndDropWrapper layoutWrapper =
        new DragAndDropWrapper(absLayout);

// Handle moving components within the AbsoluteLayout
layoutWrapper.setDropHandler(new DropHandler() {
    public AcceptCriterion getAcceptCriterion() {
        return AcceptAll.get();
    }
    
    public void drop(DragAndDropEvent event) {
        ...        
    }
});]]></programlisting>

            <section>
                <title>Target Details for Wrapped Components</title>

                <para>
                    The drop handler receives the drop target details in a
                    <classname>WrapperTargetDetails</classname> object, which implements
                    the <classname>TargetDetails</classname> interface.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[public void drop(DragAndDropEvent event) {
    WrapperTransferable t =
        (WrapperTransferable) event.getTransferable();
    WrapperTargetDetails details =
        (WrapperTargetDetails) event.getTargetDetails();]]></programlisting>

                <para>
                    The wrapper target details include a
                    <classname>MouseEventDetails</classname> object, which you can get
                    with <methodname>getMouseEvent()</methodname>. You can use it to get
                    the mouse coordinates for the position where the mouse button was
                    released and the drag ended. Similarly, you can find out the drag
                    start position from the transferable object (if it is a
                    <classname>WrapperTransferable</classname>) with
                    <methodname>getMouseDownEvent()</methodname>.
                </para>
                
                <programlisting><?pocket-size 65% ?><![CDATA[// Calculate the drag coordinate difference
int xChange = details.getMouseEvent().getClientX()
              - t.getMouseDownEvent().getClientX();
int yChange = details.getMouseEvent().getClientY()
              - t.getMouseDownEvent().getClientY();

// Move the component in the absolute layout
ComponentPosition pos =
    absLayout.getPosition(t.getSourceComponent());
pos.setLeftValue(pos.getLeftValue() + xChange);
pos.setTopValue(pos.getTopValue() + yChange);]]></programlisting>

                <para>
                    You can get the absolute x and y coordinates of the target wrapper
                    with <methodname>getAbsoluteLeft()</methodname> and
                    <methodname>getAbsoluteTop()</methodname>, which allows you to
                    translate the absolute mouse coordinates to coordinates relative to
                    the wrapper. Notice that the coordinates are really the position of
                    the wrapper, not the wrapped component; the wrapper reserves some
                    space for the accept indicators.
                </para>

                <para>
                    The <methodname>verticalDropLocation()</methodname> and
                    <methodname>horizontalDropLocation()</methodname> return the more
                    detailed drop location in the target.
                </para>
            </section>
        </section>

        <section>
            <title>Dragging Files from Outside the Browser</title>
            
            <para>
                The <classname>DragAndDropWrapper</classname> allows dragging files from
                outside the browser and dropping them on a component wrapped in the
                wrapper. Dropped files are automatically uploaded to the application and
                can be acquired from the wrapper with
                <methodname>getFiles()</methodname>. The files are represented as
                <classname>Html5File</classname> objects as defined in the inner
                class. You can define an upload <classname>Receiver</classname> to receive
                the content of a file to an <classname>OutputStream</classname>.
            </para>

            <para>
                Dragging and dropping files to browser is supported in HTML 5 and
                requires a compatible browser, such as Mozilla Firefox 3.6 or newer.
            </para>
        </section>

        <indexterm startref="term.advanced.dragndrop" class="endofrange"/>
    </section>

    <section xml:id="advanced.logging">
        <title>Logging</title>

        <indexterm xml:id="term.advanced.logging" class="startofrange"/>

        <para>
            You can do logging in Vaadin application using the standard
            <package>java.util.logging</package> facilities. Configuring logging is as
            easy as putting a file named <filename>logging.properties</filename> in the
            default package of your Vaadin application (<filename>src</filename> in an
            Eclipse project or <filename>src/main/java</filename> or
            <filename>src/main/resources</filename> in a Maven project). This file is read
            by the <classname>Logger</classname> class when a new instance of it is
            initialize.
        </para>

        <simplesect xml:id="advanced.logging.tomcat">
            <title>Logging in Apache Tomcat</title>

            <para>
                For logging Vaadin applications deployed in Apache Tomcat, you do not need
                to do anything special to log to the same place as Tomcat itself. If you
                need to write the Vaadin application related messages elsewhere, just add
                a custom <filename>logging.properties</filename> file to the default
                package of your Vaadin application.
            </para>

            <para>
                If you would like to pipe the log messages through another logging
                solution, see <xref linkend="advanced.logging.slf4j"/> below.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.liferay">
            <title>Logging in Liferay</title>

            <para>
                Liferay mutes logging through <package>java.util.logging</package> by
                default. In order to enable logging, you need to add a
                <filename>logging.properties</filename> file of your own to the default
                package of your Vaadin application. This file should define at least one
                destination where to save the log messages.
            </para>

            <para>
                You can also log through SLF4J, which is used in and bundled with
                Liferay. Follow the instructions in <xref
                linkend="advanced.logging.slf4j"/>.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.logging.slf4j">
            <title>Piping to Log4j using SLF4J</title>

            <indexterm><primary>Log4j</primary></indexterm>
            <indexterm><primary>SLF4J</primary></indexterm>

            <para>
                Piping output from <package>java.util.logging</package> to Log4j is easy
                with SLF4J (<link
                xlink:href="http://slf4j.org/">http://slf4j.org/</link>). The basic way to
                go about this is to add the SLF4J JAR file as well as the
                <filename>jul-to-slf4j.jar</filename> file, which implements the bridge
                from <package>java.util.logging</package>, to SLF4J. You will also need to
                add a third logging implementation JAR file, that is,
                <filename>slf4j-log4j12-x.x.x.jar</filename>, to log the actual messages
                using Log4j. For more info on this, please visit the SLF4J site.
            </para>

            <para>
                In order to get the <package>java.util.logging</package> to SLF4J
                bridge installed, you need to add the following snippet of code to your
                <classname>Application</classname> class at the very top:
            </para>

            <programlisting><![CDATA[  static {
    SLF4JBridgeHandler.install();
  }]]></programlisting>

            <para>
                This will make sure that the bridge handler is installed and working
                before Vaadin starts to process any logging calls.
            </para>

            <warning>
                <title>Please note!</title>

                <para>
                    This can seriously impact on the cost of disabled logging statements
                    (60-fold increase) and a measurable impact on enabled log statements
                    (20% overall increase). However, Vaadin doesn't log very much, so the
                    effect on performance will be negligible.
                </para>
            </warning>
            </simplesect>

        <simplesect xml:id="advanced.logging.core">
            <title>Using Logger</title>

            <para>
                You can do logging with a simple pattern where you register a static
                logger instance in each class that needs logging, and use this logger
                wherever logging is needed in the class. For example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class MyClass {
  private final static Logger logger =
          Logger.getLogger(MyClass.class.getName());
  
  public void myMethod() {
    try {
      // do something that might fail
    } catch (Exception e) {
      logger.log(Level.SEVERE, "FAILED CATASTROPHICALLY!", e);
    } 
  }
}]]></programlisting>

            <para>
                <indexterm><primary>static</primary></indexterm>
                <indexterm><primary>memory leak</primary></indexterm>
                <indexterm><primary>PermGen</primary></indexterm>

                Having a <literal>static</literal> logger instance for each class needing
                logging saves a bit of memory and time compared to having a logger for
                every logging class instance. However, it could cause the application to
                leak PermGen memory with some application servers when redeploying the
                application. The problem is that the <classname>Logger</classname> may
                maintain hard references to its instances. As the
                <classname>Logger</classname> class is loaded with a classloader shared
                between different web applications, references to classes loaded with a
                per-application classloader would prevent garbage-collecting the classes
                after redeploying, hence leaking memory. As the size of the PermGen memory
                where class object are stored is fixed, the leakage will lead to a server
                crash after many redeployments. The issue depends on the way how the
                server manages classloaders, on the hardness of the back-references, and
                may also be different between Java 6 and 7. So, if you experience PermGen
                issues, or want to play it on the safe side, you should consider using
                non-static <classname>Logger</classname> instances.

                <!-- As discussed in Forum thread 1175841 (24.2.2012). -->
            </para>
        </simplesect>

        <indexterm startref="term.advanced.logging" class="endofrange"/>
    </section>

    <section xml:id="advanced.javascript">
        <title>JavaScript Interaction</title>
        
        <para>
            Vaadin supports two-direction JavaScript calls from and to the
            server-side. This allows interfacing with JavaScript code without writing
            client-side integration code.
        </para>

        <section xml:id="advanced.javascript.calling">
            <title>Calling JavaScript</title>

            <para>
                You can make JavaScript calls from the server-side with the
                <methodname>execute()</methodname> method in the
                <classname>JavaScript</classname> class. You can get a
                <classname>JavaScript</classname> instance from the current
                <classname>Page</classname> object with
                <methodname>getJavaScript()</methodname>.

                <!-- TODO Check that the API is so. -->
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Execute JavaScript in the currently processed page
Page.getCurrent().getJavaScript().execute("alert('Hello')");]]></programlisting>

            <para>
                The <classname>JavaScript</classname> class itself has a static shorthand
                method <methodname>getCurrent()</methodname> to get the instance for the
                currently processed page.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Shorthand
JavaScript.getCurrent().execute("alert('Hello')");]]></programlisting>

            <para>
                The JavaScript is executed after the server request that is currently
                processed returns. If multiple JavaScript calls are made during the
                processing of the request, they are all executed sequentially after the
                request is done. Hence, the JavaScript execution does not pause the
                execution of the server-side application and you can not return values
                from the JavaScript.
            </para>
        </section>

        <section xml:id="advanced.javascript.callback">
            <title>Handling JavaScript Callbacks</title>

            <para>
                You can make calls with JavaScript from the client-side to the
                server-side. This requires that you register JavaScript call-back methods
                from the server-side. You need to implement and register a
                <classname>JavaScriptCallback</classname> with
                <methodname>addCallback()</methodname> in the current
                <classname>JavaScript</classname> object. A callback requires a method
                name, with an optional package path, given for the
                <methodname>addCallback()</methodname>. You only need to implement the
                <methodname>call()</methodname> method to handle calls from the
                client-side JavaScript.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[JavaScript.getCurrent().addCallback("com.example.foo.myfunc",
                                    new JavaScriptCallback() {
    @Override
    public void call(JSONArray arguments) throws JSONException {
        Notification.show("Received call");
    }
});
        
Link link = new Link("Send Message", new ExternalResource(
        "javascript:com.example.foo.myfunc()"));]]></programlisting>

            <para>
                Parameters passed to the JavaScript method on the client-side are provided
                in a <classname>JSONArray</classname> passed to the
                <methodname>call()</methodname> method. The parameter values can be
                acquired with the <methodname>get()</methodname> method by the index of
                the parameter, or any of the type-casting getters. The getter must match
                the type of the passed parameter, or a
                <classname>JSONException</classname> is thrown.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[JavaScript.getCurrent().addCallback("com.example.foo.myfunc",
                                    new JavaScriptCallback() {
    @Override
    public void call(JSONArray arguments) throws JSONException {
        try {
            String message = arguments.getString(0);
            int    value   = arguments.getInt(1);
            Notification.show("Message: " + message +
                              ", value: " + value);
        } catch (JSONException e) {
            Notification.show("Error: " + e.getMessage());
        }
    }
});
        
Link link = new Link("Send Message", new ExternalResource(
        "javascript:com.example.foo.myfunc(prompt('Message'), 42)"));]]></programlisting>

            <para>
                The callback mechanism is the same as the RPC mechanism used with
                JavaScript component integration, as described in <xref
                linkend="gwt.javascript.rpc"/>.
            </para>
        </section>
    </section>

    <section xml:id="advanced.global">
        <title>Accessing Session-Global Data</title>

        <para>
            Applications typically need to access some objects from practically all user
            interface code, such as a user object, a business data model, or a database
            connection. This data is typically initialized and managed in the UI class of
            the application, or in the session or servlet.
        </para>

        <para>
            For example, you could hold it in the UI class as follows:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyUI extends UI {
    UserData userData;

    public void init() {
        userData = new UserData();
    }

    public UserData getUserData() {
        return userData;
    }
}]]></programlisting>

        <para>
            Vaadin offers two ways to access the UI object: with
            <methodname>getUI()</methodname> method from any component and the global
            <methodname>UI.getCurrent()</methodname> method.
        </para>

        <para>
            The <methodname>getUI()</methodname> works as follows:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[data = ((MyUI)component.getUI()).getUserData();]]></programlisting>

        <para>
            This does not, however work in many cases, because it requires that the
            components are attached to the UI. That is not the case most of the time when
            the UI is still being built, such as in constructors.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // This fails with NullPointerException
        Label label = new Label("Country: " +
            getApplication().getLocale().getCountry());

        setCompositionRoot(label);
    }
}]]></programlisting>


        <para>
            The global access methods for the currently served servlet, session, and UI
            allow an easy way to access the data:
        </para>

        <programlisting><![CDATA[data = ((MyUI) UI.getCurrent()).getUserData();]]></programlisting>

        <simplesect xml:id="advanced.global.passing.problem">
            <title>The Problem</title>

            <para>
                The basic problem in accessing session-global data is that the
                <methodname>getUI()</methodname> method works only after the
                component has been attached to the application. Before that, it returns
                <parameter>null</parameter>. This is the case in constructors of
                components, such as a <classname>CustomComponent</classname>:
            </para>

            <para>
                Using a static variable or a singleton implemented with such to give a
                global access to user session data is not possible, because static
                variables are global in the entire web application, not just the user
                session. This can be handy for communicating data between the concurrent
                sessions, but creates a problem within a session.
            </para>

            <para>
                The data would be shared by all users and be reinitialized every time a
                new user opens the application.
            </para>
        </simplesect>

        <simplesect xml:id="advanced.global.passing.solutions-overview">
            <title>Overview of Solutions</title>

            <para>
                To get the application object or any other global data, you have the
                following solutions:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        Pass a reference to the global data as a parameter.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Initialize components in <methodname>attach()</methodname> method.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Store a reference to global data using the <emphasis>ThreadLocal Pattern</emphasis>.
                    </para>
                </listitem>
            </itemizedlist>

            <para>
                Each solution is described in the following sections.
            </para>
        </simplesect>

        <section xml:id="advanced.global.passing">
            <title>Passing References Around</title>

            <para>
                You can pass references to objects as parameters. This is the normal way
                in object-oriented programming.
            </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyApplication extends Application {
    UserData userData;

    public void init() {
        Window mainWindow = new Window("My Window");
        setMainWindow(mainWindow);

        userData = new UserData();
        
        mainWindow.addComponent(new MyComponent(this));
    }

    public UserData getUserData() {
        return userData;
    }
}

class MyComponent extends CustomComponent {
    public MyComponent(MyApplication app) {
        Label label = new Label("Name: " +
            app.getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                If you need the reference in other methods, you either have to pass it
                again as a parameter or store it in a member variable.
            </para>

            <para>
                The problem with this solution is that practically all constructors in the
                application need to get a reference to the application object, and passing
                it further around in the classes is another hard task.
            </para>
        </section>
        
        <section xml:id="advanced.global.attach">
            <title>Overriding <methodname>attach()</methodname></title>

            <para>
                The <methodname>attach()</methodname> method is called when the component
                is attached to the application component through containment
                hierarchy. The <methodname>getApplication()</methodname> method always
                works.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {
    public MyComponent() {
        // Must set a dummy root in constructor
        setCompositionRoot(new Label(""));
    }

    @Override
    public void attach() {    
        Label label = new Label("Name: " +
            ((MyApplication)component.getApplication())
                .getUserData().getName());

        setCompositionRoot(label);
    }
}]]></programlisting>

            <para>
                While this solution works, it is slightly messy. You may need to do some
                initialization in the constructor, but any construction requiring the
                global data must be done in the <methodname>attach()</methodname> method.
                Especially, <classname>CustomComponent</classname> requires that the
                <methodname>setCompositionRoot()</methodname> method is called in the
                constructor. If you can't create the actual composition root component in
                the constructor, you need to use a temporary dummy root, as is done in the
                example above.
            </para>
            
            <para>
                Using <methodname>getApplication()</methodname> also needs casting if you
                want to use methods defined in your application class.
            </para>
        </section>

        <section xml:id="advanced.global.threadlocal">
            <title>ThreadLocal Pattern</title>

            <indexterm xml:id="term.advanced.global.threadlocal" class="startofrange"><primary>ThreadLocal pattern</primary></indexterm>

            <para>
                Vaadin uses the ThreadLocal pattern for allowing global access to the
                <classname>Application</classname>, <classname>&uiclass;</classname>,
                and <classname>Page</classname> objects of the currently processed server
                request with a static <methodname>getCurrent()</methodname> method in all
                the respective classes. This section explains why the pattern is used in
                Vaadin and how it works. The explanation is given as an implementation, if
                you find a need to reimplement the pattern for some reason.
            </para>

            <!-- TODO Vaadin 7: Clean up what is no longer necessary -->

            <para>
                The ThreadLocal pattern gives a solution to the global access problem by
                solving two sub-problems of static variables.
            </para>

            <para>
                As the first problem, assume that the servlet container processes requests
                for many users (sessions) sequentially. If a static variable is set in a
                request belonging one user, it could be read or re-set by the next
                incoming request belonging to another user. This can be solved by setting
                the global reference at the beginning of each HTTP request to point to
                data of the current user, as illustrated in Figure <xref
                linkend="figure.advanced.global.threadlocal.sequentiality"
                xrefstyle="select:labelnumber"/>.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.sequentiality">
                <title>Switching a static (or ThreadLocal) reference during sequential
                processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-sequentiality-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-sequentiality-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                It is possible to implement such switching either with the
                <classname>TransactionListener</classname> or
                <classname>HttpServletRequestListener</classname> interface by setting the
                reference in <methodname>transactionStart()</methodname> or
                <methodname>onRequestStart()</methodname>, respectively. We use the former
                interface in the example code in this section, as the latter interface has
                to be implemented in the application class.
            </para>

            <para>
                The second problem is that servlet containers typically do thread pooling
                with multiple worker threads that process requests. Therefore, setting a
                static reference would change it in all threads running concurrently,
                possibly just when another thread is processing a request for another
                user. The solution is to store the reference in a thread-local variable
                instead of a static. You can do so by using the
                <classname>ThreadLocal</classname> class in Java for the switch reference.
            </para>

            <figure xml:id="figure.advanced.global.threadlocal.concurrency">
                <title>Switching <classname>ThreadLocal</classname> references during
                concurrent processing of requests</title>

                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/advanced/threadlocal-concurrency-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="100" smallscale="100%" align="center" fileref="img/advanced/threadlocal-concurrency-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Notice that if you use a <classname>TransactionListener</classname>, the
                listeners are attached to the web application context (in practice a user
                session), not the application instance. The problem is that an application
                context can have multiple different Vaadin applications that share the
                same user session. If two of these applications add a transaction listener
                to the context to listen for requests, both are called and without any
                checks they would both set the reference to themselves. Therefore, the
                application data object needs to know which application it belongs to and
                check that when the transaction begins and ends. Using the
                <classname>HttpServletRequestListener</classname> frees you from these
                checks.
            </para>

            <para>
                While you may not absolutely need to clear the reference in
                <methodname>transactionEnd()</methodname>, you are probably on the safer
                side if you do. Setting such unneeded references to
                <literal>null</literal> can help avoid memory leaks and it could also be a
                good security precaution not to leave a reference to session data so that
                it could be seen by another user session in the next request.
            </para>

            <para>
                We end up with the following code. As we put the application data to a
                class separate from the application class, we have to make it a
                <classname>TransactionListener</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** Holds data for one user session. */
public class AppData
       implements TransactionListener, Serializable {
    private ResourceBundle bundle;
    private Locale locale;   // Current locale
    private String userData; // Trivial data model for the user
    
    private Application app; // For distinguishing between apps

    private static ThreadLocal<AppData> instance =
        new ThreadLocal<AppData>();
    
    public AppData(Application app) {
        this.app = app;

        // It's usable from now on in the current request
        instance.set(this);
    }

    @Override
    public void transactionStart(Application application,
                                 Object transactionData) {
        // Set this data instance of this application
        // as the one active in the current thread. 
        if (this.app == application)
            instance.set(this);
    }

    @Override
    public void transactionEnd(Application application,
                               Object transactionData) {
        // Clear the reference to avoid potential problems
        if (this.app == application)
            instance.set(null);
    }

    public static void initLocale(Locale locale,
                                  String bundleName) {
        instance.get().locale = locale;
        instance.get().bundle =
            ResourceBundle.getBundle(bundleName, locale);
    }
    
    public static Locale getLocale() {
        return instance.get().locale;
    }

    public static String getMessage(String msgId) {
        return instance.get().bundle.getString(msgId);
    }

    public static String getUserData() {
        return instance.get().userData;
    }

    public static void setUserData(String userData) {
        instance.get().userData = userData;
    }
}]]></programlisting>

            <para>
                We can then use it in the application as follows. Observe that we do not
                have a reference to the application object in the constructor of the
                <classname>MyComponent</classname> class.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[/** 
 * We can now nicely access the session-global data
 * in the constuctor of this class.
 */
class MyComponent extends CustomComponent {
    public MyComponent() {
        VerticalLayout layout = new VerticalLayout();
        
        // Get stuff from the application data object            
        layout.addComponent(new Label("Hello, " +
            AppData.getUserData()));

        layout.addComponent(new Label("Your locale is " +
            AppData.getLocale().getDisplayLanguage()));
        
        layout.addComponent(new Button(
            AppData.getMessage(MyAppCaptions.CancelKey)));
        
        setCompositionRoot(layout);
    }
}

/** The application class. */
public class ThreadLocalApplication extends Application {
    public void init() { 
        Window main = new Window("Hello window"); 
        setMainWindow(main);
        
        // Create the application data instance
        AppData sessionData = new AppData(this);
        
        // Register it as a listener in the application context
        getContext().addTransactionListener(sessionData);
        
        // Initialize the session-global data
        AppData.initLocale(getLocale(),
                           MyAppCaptions.class.getName());
        
        // Also set the user data model
        AppData.setUserData("Billy");
        
        // Now, we do not pass this application object
        // in the constructor, so it couldn't access the
        // app data otherwise.
        main.addComponent(new MyComponent());
    }
}]]></programlisting>

            <indexterm startref="term.advanced.global.threadlocal" class="endofrange"/>
        </section>
    </section>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

