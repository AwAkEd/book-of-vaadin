<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="components">
	<title>User Interface Components</title>
	
	<para>
		This chapter provides an overview and a detailed description of all
		non-layout components in Vaadin.
	</para>
	
	<section xml:id="components.overview">
		<title>Overview</title>

		<para>
			Vaadin provides a comprehensive set of user interface components and allows
			you to define custom components. <xref linkend="figure.uicomponents"/>
			illustrates the inheritance hierarchy of the UI component classes and
			interfaces. Interfaces are displayed in gray, abstract classes in orange, and
			regular classes in blue. An annotated version of the diagram is featured in
			the <emphasis>Vaadin Cheat Sheet</emphasis>.
		</para>

		<figure xml:id="figure.uicomponents">
			<title>UI Component Inheritance Diagram</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-diagram-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            <indexterm><primary><classname>Component</classname></primary></indexterm>

			At the top of the interface hierarchy, we have the
			<classname>Component</classname> interface.

            <indexterm><primary><classname>AbstractComponent</classname></primary></indexterm>

            At the top of the class hierarchy, we have the
            <classname>AbstractComponent</classname> class.

            <indexterm><primary><classname>AbstractField</classname></primary></indexterm>
            <indexterm><primary><classname>AbstractComponentContainer</classname></primary></indexterm>

            It is inherited by two other abstract classes:
            <classname>AbstractField</classname>, inherited further by field components,
            and <classname>AbstractComponentContainer</classname>, inherited by various
            container and layout components. Components that are not bound to a content
            data model, such as labels and links, inherit
            <classname>AbstractComponent</classname> directly.
		</para>

		<para>
            <indexterm><primary>layout</primary></indexterm>
            <indexterm><primary><classname>Layout</classname></primary></indexterm>

			The layout of the various components in a window is controlled,
			logically, by layout components, just like in conventional Java UI
			toolkits for desktop applications. In addition, with the <classname>CustomLayout</classname>
			component, you can write a custom layout as an XHTML template that
			includes the locations of any contained components. Looking at the
			inheritance diagram, we can see that layout components inherit the
			<classname>AbstractComponentContainer</classname> and the
			<classname>Layout</classname> interface. Layout components are
			described in detail in <xref linkend="layout"/>.
		</para>

		<para>
            <indexterm><primary><classname>Window</classname></primary></indexterm>

			Looking at it from the perspective of an object hierarchy, we would
			have a <classname>Window</classname> object, which contains a hierachy of
			layout components, which again contain other layout components, field
			components, and other visible components.
		</para>

		<para>
            <indexterm><primary>Sampler</primary></indexterm>
            <indexterm><primary>JavaDoc</primary></indexterm>

			You can browse the built-in UI components of Vaadin library in the
			<application>Sampler</application> application of the <application>Vaadin
			Demo</application>. The Sampler shows a description, JavaDoc documentation,
			and a code samples for each of the components.
		</para>

		<para>
            In addition to the built-in components, many components are available as
            add-ons, either from the Vaadin Directory or from independent sources. Both
            commercial and free components exist. The installation of add-ons is described
            in <xref linkend="addons"/>.
        </para>

        <note>
            <title>Vaadin Cheat Sheet and Refcard</title>

            <para>
                <xref linkend="figure.uicomponents"/> is included in the Vaadin Cheat
                Sheet that illustrates the basic relationship hierarchy of the user
                interface components and data binding classes and interfaces. You can
                download it at <link
                xlink:href="http://dev.vaadin.com/browser/doc/trunk/cheatsheet/vaadin-cheatsheet-duplex.pdf">http://dev.vaadin.com/browser/doc/trunk/cheatsheet/vaadin-cheatsheet-duplex.pdf</link>.
            </para>

            <para>
                The diagram is also included in the six-page DZone Refcard, which you can
                find at <link
                xlink:href="https://vaadin.com/refcard">https://vaadin.com/refcard</link>.
            </para>
        </note>
	</section>

	<section xml:id="components.interfaces">
		<title>Interfaces and Abstractions</title>

        <para>
            <indexterm><primary>interfaces</primary></indexterm>

			Vaadin user interface components are built on a skeleton of interfaces and
			abstract classes that define and implement the features common to all
			components and the basic logic how the component states are serialized between
			the server and the client.
        </para>
        
        <para>
			This section gives details on the basic component interfaces and
			abstractions. The layout and other component container abstractions are
			described in <xref linkend="layout"/>. The interfaces that define the Vaadin
			data model are described in <xref linkend="datamodel"/>.
        </para>

		<figure xml:id="figure.components.interfaces">
			<title>Component Interfaces and Abstractions</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/component-abstractions-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/component-abstractions-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            <indexterm><primary><classname>Paintable</classname></primary></indexterm>
            <indexterm><primary><classname>VariableOwner</classname></primary></indexterm>

			All components also implement the <classname>Paintable</classname> interface,
			which is used for serializing ("painting") the components to the client, and
			the reverse <classname>VariableOwner</classname> interface, which is needed
			for deserializing component state or user interaction from the client.
        </para>

        <para>
            <indexterm><primary><classname>Serializable</classname></primary></indexterm>

			In addition to the interfaces defined within the Vaadin framework, all
			components implement the <classname>java.io.Serializable</classname> interface
			to allow serialization. Serialization is needed in many clustering and cloud
			computing solutions.
		</para>

        <section xml:id="components.interfaces.component">
            <title><classname>Component</classname> Interface</title>

            <indexterm xml:id="term.components.interfaces.component" class="startofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>

            <para>
                The <classname>Component</classname> interface is paired with the
                <classname>AbstractComponent</classname> class, which implements all the
                methods defined in the interface.
            </para>

			<section>
				<title>Component Tree Management</title>

				<para>
					Components are laid out in the user interface hierarchically. The
					layout is managed by layout components, or more generally components
					that implement the <classname>ComponentContainer</classname>
					interface. Such a container is the parent of the contained components.
				</para>

				<para>
					The <methodname>getParent()</methodname> method allows retrieving the
					parent component of a component. While there is a
					<methodname>setParent()</methodname>, you rarely need it as you
					usually add components with the
					<methodname>addComponent()</methodname> method of the
					<classname>ComponentContainer</classname> interface, which
					automatically sets the parent.
				</para>

				<para>
					A component does not know its parent when the component is created, so
					you can not refer to the parent in the constructor with
					<methodname>getParent()</methodname>. Also, it is not possible to
					fetch a reference to the application object with
					<methodname>getApplication()</methodname> before having a parent. For
					example, the following is invalid:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[public class AttachExample extends CustomComponent {
    public AttachExample() {
        // ERROR: We can't access the application object yet.
        ClassResource r = new ClassResource("smiley.jpg",
                                            getApplication());
        Embedded image = new Embedded("Image:", r); 
        setCompositionRoot(image);
    }
}]]></programlisting>

				<para>
					Adding a component to an application triggers calling the
					<methodname>attach()</methodname> method for the
					component. Correspondingly, removing a component from a container
					triggers calling the <methodname>detach()</methodname> method. If the
					parent of an added component is already connected to the application,
					the <methodname>attach()</methodname> is called immediately from
					<methodname>setParent()</methodname>.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[public class AttachExample extends CustomComponent {
    public AttachExample() {
    }
    
    @Override
    public void attach() {
        super.attach(); // Must call.
        
        // Now we know who ultimately owns us.
        ClassResource r = new ClassResource("smiley.jpg",
                                            getApplication());
        Embedded image = new Embedded("Image:", r); 
        setCompositionRoot(image);
    }
}]]></programlisting>

				<para>
					The attachment logic is implemented in
					<classname>AbstractComponent</classname>, as described in <xref
					linkend="components.interfaces.abstractcomponent"/>.
				</para>

			</section>

            <indexterm startref="term.components.interfaces.component" class="endofterm">
                <primary><classname>Component</classname> interface</primary>
            </indexterm>
        </section>

        <section xml:id="components.interfaces.abstractcomponent">
            <title><classname>AbstractComponent</classname></title>

            <indexterm xml:id="term.components.interfaces.abstractcomponent" class="startofrange">
                <primary><classname>AbstractComponent</classname></primary>
            </indexterm>

            <para>
                <classname>AbstractComponent</classname> is the base class for all user
                interface components. It is the (only) implementation of the
                <classname>Component</classname> interface, implementing all the methods
                defined in the interface.
            </para>
			
			<para>
				<classname>AbstractComponent</classname> has a single abstract method,
				<methodname>getTag()</methodname>, which returns the serialization
				identifier of a particular component class. It needs to be implemented
				when (and only when) creating entirely new
				components. <classname>AbstractComponent</classname> manages much of the
				serialization of component states between the client and the
				server. Creation of new components and serialization is described in <xref
				linkend="gwt"/>.
			</para>

            <indexterm startref="term.components.interfaces.abstractcomponent" class="endofrange"/>
        </section>

        <section xml:id="components.interfaces.fields">
            <title>Field Components (<classname>Field</classname> and <classname>AbstractField</classname>)</title>

            <indexterm xml:id="term.components.fields" class="startofrange">
                <primary><classname>Field</classname></primary>
            </indexterm>

            <para>
				<emphasis>Fields</emphasis> are components that have a value that the user
				can change through the user interface. <xref
				linkend="figure.components.interfaces.fields"/> illustrates the inheritance
				relationships and the important interfaces and base classes.
			</para>

			<figure xml:id="figure.components.interfaces.fields">
				<title>Field Components</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/field-diagram-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-diagram-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Field components are built upon the framework defined in the
				<classname>Field</classname> interface and the
				<classname>AbstractField</classname> base class.
			</para>

			<para>
				The description of the field interfaces and base classes is broken down in
				the following sections.
			</para>

			<section xml:id="components.interfaces.fields.field">
				<title><classname>Field</classname> Interface</title>

				<para>
					The <classname>Field</classname> interface inherits the
					<classname>Component</classname> superinterface and also the
					<classname>Property</classname> interface to have a value for the
					field. <classname>AbstractField</classname> is the only class
					implementing the <classname>Field</classname> interface directly.  The
					relationships are illustrated in <xref
					linkend="figure.components.interfaces.fields.field"/>.
				</para>

				<figure xml:id="figure.components.interfaces.fields.field">
					<title><classname>Field</classname> Interface Inheritance Diagram</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/components/field-interface-lo.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="100" smallscale="100%" align="center" fileref="img/components/field-interface-hi.png"/>
						</imageobject>
					</mediaobject>
				</figure>

				<para>
					You can set the field value with the <methodname>setValue()</methodname>
					and read with the <methodname>getValue()</methodname> method defined in
					the <classname>Property</classname> interface. The actual value type
					depends on the component.
				</para>

				<para>
					The <classname>Field</classname> interface defines a number of
					attributes, which you can retrieve or manipulate with the
					corresponding setters and getters.
				</para>

				<variablelist>
					<varlistentry>
						<term><methodname>description</methodname></term>
						<listitem>
							<para>
								All fields have a description. Notice that while this
								attribute is defined in the
								<classname>Field</classname> component, it is
								implemented in <classname>AbstractField</classname>,
								which does not directly implement
								<classname>Field</classname>, but only through the
								<classname>AbstractField</classname> class.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><methodname>required</methodname></term>
						<listitem>
							<para>
								When enabled, a required indicator (usually the asterisk *
								character) is displayed on the left, above, or right the
								field, depending on the containing layout and whether the
								field has a caption. If such fields are validated but are
								empty and the <methodname>requiredError</methodname>
								property (see below) is set, an error indicator is shown
								and the component error is set to the text defined with
								the error property. Without validation, the required
								indicator is merely a visual guide.
							</para>
						</listitem>
					</varlistentry>
					<varlistentry>
						<term><methodname>requiredError</methodname></term>
						<listitem>
							<para>
								Defines the error message to show when a value is
								required, but none is entered. The error message is set as
								the component error for the field and is usually displayed
								in a tooltip when the mouse pointer hovers over the error
								indicator.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>

			<section xml:id="components.interfaces.fields.databinding">
				<title>Data Binding and Conversions</title>

                <para>
                    Fields are strongly coupled with the Vaadin data model. The field value is
                    handled as a <classname>Property</classname> of the field component, as
                    documented in <xref linkend="datamodel.properties"/>. Selection fields
                    allow management of the selectable items through the
                    <classname>Container</classname> interface.
                </para>

                <para>
                    Fields edit some particular type. For example,
                    <classname>TextField</classname> allows editing
                    <classname>String</classname> values. When bound to a data source, the
                    property type of the data model can be something different, say an
                    <classname>Integer</classname>. <emphasis>Converters</emphasis> are used
                    for converting the values between the representation and the model. They
                    are described in <xref linkend="datamodel.properties.converter"/>.
                </para>
            </section>

            <section xml:id="components.interfaces.fields.valuechanges">
				<title>Handling Field Value Changes</title>
				
				<para>
					<classname>Field</classname> inherits
					<classname>Property.ValueChangeListener</classname> to allow listening
					for field value changes and <classname>Property.Editor</classname> to
					allow editing values.
				</para>

				<para>
					When the value of a field changes, a
					<classname>Property.ValueChangeEvent</classname> is triggered for
					the field. You should not implement the
					<methodname>valueChange()</methodname> method in a class
					inheriting <classname>AbstractField</classname>, as it is already
					implemented in <classname>AbstractField</classname>. You should
					instead implement the method explicitly by adding the implementing
					object as a listener.
				</para>
			</section>

            <section xml:id="components.interfaces.fields.valuechanges">
				<title><classname>AbstractField</classname> Base Class</title>

				<para>
					<classname>AbstractField</classname> is the base class for all field
					components. In addition to the component features inherited from
					<classname>AbstractComponent</classname>, it implements a number of
					features defined in <classname>Property</classname>,
					<classname>Buffered</classname>, <classname>Validatable</classname>,
					and <classname>Component.Focusable</classname> interfaces.
				</para>

			</section>
			
        </section>

        <indexterm startref="term.components.fields" class="endofrange"/>
    </section>

	<section xml:id="components.features">
		<title>Common Component Features</title>

        <para>
            The component base classes and interfaces provide a large number of
            features. Let us look at some of the most commonly needed features. Features
            not documented here can be found from the Java API Reference.
        </para>

        <para>
            The interface defines a number of properties, which you can retrieve
            or manipulate with the corresponding setters and getters.
        </para>

        <section xml:id="components.features.caption">
            <title>Caption</title>

            <indexterm zone="components.features.caption">
                <primary>caption property</primary>
            </indexterm>

            <indexterm zone="components.features.caption">
                <primary>Component interface</primary>
                <secondary>caption</secondary>
            </indexterm>

            <para>
                A caption is an explanatory textual label accompanying a user interface
                component, usually shown above, left of, or inside the component. The
                contents of a caption are automatically quoted, so no raw XHTML can be
                rendered in a caption.
            </para>

            <para>
                The caption text can usually be given as the first parameter of a
                constructor of a component or with <methodname>setCaption()</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// New text field with caption "Name"
TextField name = new TextField("Name");
layout.addComponent(name);]]></programlisting>

            <para>
                The caption of a component is, by default, managed and displayed by the
                layout component or component container inside which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the captions left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the captions on the left
                side of the vertically laid components, with the captions and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the caption of its
                composition root, so if the root component has a caption, it will not be
                rendered.
            </para>

			<figure xml:id="figure.components.features.caption.layoutmanaged">
				<title>Caption Management by <classname>VerticalLayout</classname> and <classname>FormLayout</classname> components.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-caption-layoutmanaged.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the caption themselves and display it
                inside the component.
            </para>

            <para>
                Icon (see <xref linkend="components.features.icon"/>) is closely related
                to caption and is usually displayed horizontally before or after it,
                depending on the component and the containing layout. Also the required
                indicator in field components is usually shown before or after the
                caption.
            </para>

            <para>
                An alternative way to implement a caption is to use another component as
                the caption, typically a <classname>Label</classname>, a
                <classname>TextField</classname>, or a <classname>Panel</classname>. A
                <classname>Label</classname>, for example, allows highlighting a shortcut
                key with XHTML markup or to bind the caption to a data source. The
                <classname>Panel</classname> provides an easy way to add both a caption
                and a border around a component.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-caption {}
  .v-captiontext {}
  .v-caption-clearelem {}
  .v-required-field-indicator {}]]></programlisting>

                <para>
                    A caption is be rendered inside an HTML element that has the
                    <literal>v-caption</literal> CSS style class. The containing layout
                    may enclose a caption inside other caption-related elements.
                </para>

                <para>
                    Some layouts put the caption text in a
                    <literal>v-captiontext</literal> element. A
                    <literal>v-caption-clearelem</literal> is used in some layouts to
                    clear a CSS <literal>float</literal> property in captions. An optional
                    required indicator in field components is contained in a separate
                    element with <literal>v-required-field-indicator</literal> style.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.features.description">
			<title>Description and Tooltips</title>

            <indexterm zone="components.features.description">
                <primary>description property</primary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>Component interface</primary>
                <secondary>description</secondary>
            </indexterm>

            <indexterm zone="components.features.description">
                <primary>tooltips</primary>
            </indexterm>

			<para>
				All components (that inherit <classname>AbstractComponent</classname>)
				have a description separate from their caption. The description is usually
				shown as a tooltip that appears when the mouse pointer hovers over the
				component for a short time.
			</para>

			<para>
				You can set the description with <methodname>setDescription()</methodname>
				and retrieve with <methodname>getDescription()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[Button button = new Button("A Button");
button.setDescription("This is the tooltip");]]></programlisting>

			<para>
				The tooltip is shown in <xref
				linkend="figure.components.tooltip.plain"/>.
			</para>

			<figure xml:id="figure.components.tooltip.plain">
				<title>Component Description as a Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-plain-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="130" align="center" fileref="img/components/tooltip-plain-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				A description is rendered as a tooltip in most
				components.
			</para>

			<para>
				When a component error has been set with
				<methodname>setComponentError()</methodname>, the error is usually also
				displayed in the tooltip, below the description. Components that are in
				error state will also display the error indicator. See <xref
				linkend="application.errors.error-indicator"/>.
			</para>

			<para>
				The description is actually not plain text, but you can use XHTML tags to
				format it. Such a rich text description can contain any HTML elements,
				including images.
			</para>

			<programlisting><?pocket-size 60% ?><![CDATA[button.setDescription(
    "<h2><img src=\"../VAADIN/themes/sampler/icons/comment_yellow.gif\"/>"+
    "A richtext tooltip</h2>"+
    "<ul>"+
    "  <li>Use rich formatting with XHTML</li>"+
    "  <li>Include images from themes</li>"+
    "  <li>etc.</li>"+
    "</ul>");]]></programlisting>

			<para>
				The result is shown in <xref
				linkend="figure.components.tooltip.richtext"/>.
			</para>

			<figure xml:id="figure.components.tooltip.richtext">
				<title>A Rich Text Tooltip</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/tooltip-richtext-withpointer-lo.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100" align="center" fileref="img/components/tooltip-richtext-withpointer-hi.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				Notice that the setter and getter are defined for all fields in the
				<classname>Field</classname> interface, not for all components in the
				<classname>Component</classname> interface.
			</para>
		</section>

        <section xml:id="components.features.enabled">
            <title>Enabled</title>
            
            <indexterm zone="components.features.enabled">
                <primary>enabled property</primary>
            </indexterm>

            <indexterm zone="components.features.enabled">
                <primary>Component interface</primary>
                <secondary>enabled</secondary>
            </indexterm>

            <para>
                The <emphasis>enabled</emphasis> property controls whether the user can
                actually use the component. A disabled component is visible, but grayed to
                indicate the disabled state.
            </para>

            <para>
                Components are always enabled by default. You can disable a component with
                <methodname>setEnabled(false)</methodname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[Button enabled = new Button("Enabled");
enabled.setEnabled(true); // The default
layout.addComponent(enabled);
        
Button disabled = new Button("Disabled");
disabled.setEnabled(false);
layout.addComponent(disabled);]]></programlisting>

            <para>
                <xref linkend="figure.components.features.enabled.simple"/> shows the
                enabled and disabled buttons.
            </para>

			<figure xml:id="figure.components.features.enabled.simple">
				<title>An Enabled and Disabled <classname>Button</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="75%" align="center" fileref="img/components/features-enabled-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                A disabled component is automatically put in read-only state. No client
                interaction with such a component is sent to the server and, as an
                important security feature, the server-side components do not receive
                state updates from the client in the read-only state. This feature exists
                in all built-in components in Vaadin and is automatically handled for all
                <classname>Field</classname> components for the field property value. For
                custom widgets, you need to make sure that the read-only state is checked
                on the server-side for all safety-critical variables.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Disabled components have the <literal>v-disabled</literal> CSS style
                    in addition to the component-specific style. To match a component with
                    both the styles, you have to join the style class names with a dot as
                    done in the example below.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[.v-textfield.v-disabled {
    border: dotted;
}]]></programlisting>

                <para>
                    This would make the border of all disabled text fields dotted.
                </para>

            <programlisting><?pocket-size 75% ?><![CDATA[TextField disabled = new TextField("Disabled");
disabled.setValue("Read-only value");
disabled.setEnabled(false);
layout.addComponent(disabled);]]></programlisting>

                <para>
                    The result is illustrated in <xref
                    linkend="figure.components.features.enabled.styling"/>.
                </para>

                <figure xml:id="figure.components.features.enabled.styling">
                    <title>Styling Disabled Components</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/features-enabled-styling.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="80" smallscale="80%" align="center" fileref="img/components/features-enabled-styling.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </simplesect>
        </section>
        
        <section xml:id="components.features.icon">
            <title>Icon</title>
            
            <indexterm zone="components.features.icon">
                <primary>icon property</primary>
            </indexterm>

            <indexterm zone="components.features.icon">
                <primary>Component interface</primary>
                <secondary>icon</secondary>
            </indexterm>

            <para>
                An icon is an explanatory graphical label accompanying a user interface
                component, usually shown above, left of, or inside the component. Icon is
                closely related to caption (see <xref
                linkend="components.features.caption"/>) and is usually displayed
                horizontally before or after it, depending on the component and the
                containing layout.
            </para>

            <para>
                The icon of a component can be set with the
                <methodname>setIcon()</methodname> method. The image is provided as a
                resource, perhaps most typically a <classname>ThemeResource</classname>.
            </para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Component with an icon from a custom theme
TextField name = new TextField("Name");
name.setIcon(new ThemeResource("icons/user.png"));
layout.addComponent(name);
        
// Component with an icon from another theme ('runo')
Button ok = new Button("OK");
ok.setIcon(new ThemeResource("../runo/icons/16/ok.png"));
layout.addComponent(ok);]]></programlisting>

            <para>
                The icon of a component is, by default, managed and displayed by the
                layout component or component container in which the component is
                placed. For example, the <classname>VerticalLayout</classname> component
                shows the icons left-aligned above the contained components, while the
                <classname>FormLayout</classname> component shows the icons on the left
                side of the vertically laid components, with the icons and their
                associated components left-aligned in their own columns. The
                <classname>CustomComponent</classname> does not manage the icon of its
                composition root, so if the root component has an icon, it will not be
                rendered.
            </para>

			<figure xml:id="figure.components.features.icon">
				<title>Displaying an Icon from a Theme Resource.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-icon.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-icon.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Some components, such as <classname>Button</classname> and
                <classname>Panel</classname>, manage the icon themselves and display it
                inside the component.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    An icon will be rendered inside an HTML element that has the
                    <literal>v-icon</literal> CSS style class. The containing layout may
                    enclose an icon and a caption inside elements related to the caption,
                    such as <literal>v-caption</literal>.
                </para>
            </simplesect>
        </section>
        
        <section xml:id="components.features.locale">
            <title>Locale</title>
            
            <indexterm zone="components.features.locale">
                <primary>locale property</primary>
                <secondary>in <classname>Component</classname></secondary>
            </indexterm>

            <indexterm zone="components.features.locale">
                <primary>Component interface</primary>
                <secondary>locale</secondary>
            </indexterm>

            <para>
                The locale property defines the country and language used in a
                component. You can use the locale information in conjunction with an
                internationalization scheme to acquire localized resources. Some
                components, such as <classname>DateField</classname>, use the locale for
                component localization.
            </para>

            <para>
                You can set the locale of a component (or the application) with
                <methodname>setLocale()</methodname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Component for which the locale is meaningful
InlineDateField date = new InlineDateField("Datum");
        
// German language specified with ISO 639-1 language
// code and ISO 3166-1 alpha-2 country code. 
date.setLocale(new Locale("de", "DE"));
        
date.setResolution(DateField.RESOLUTION_DAY);
layout.addComponent(date);]]></programlisting>

            <para>
                The resulting date field is shown in <xref
                linkend="figure.components.features.locale.simple"/>.
            </para>
            
			<figure xml:id="figure.components.features.locale.simple">
				<title>Set Locale for <classname>InlineDateField</classname></title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-locale-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                <indexterm><primary><methodname>getLocale()</methodname></primary></indexterm>

                You can get the locale of a component with
                <methodname>getLocale()</methodname>. If the locale is undefined for a
                component, that is, not explicitly set, the locale of the parent component
                is used. If none of the parent components have a locale set, the locale of
                the application is used, and if that is not set, the default system locale
                is set, as given by <methodname>Locale.getDefault()</methodname>.
            </para>

            <para>
                Because of the requirement that the component must be attached to the
                application, it is awkward to use <methodname>getLocale()</methodname> for
                internationalization. You can not use it in the constructor, so you would
                have to get the locale in <methodname>attach()</methodname> as shown in
                the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Button cancel = new Button() {
    @Override
    public void attach() {
        ResourceBundle bundle = ResourceBundle.getBundle(
                MyAppCaptions.class.getName(), getLocale());
        setCaption(bundle.getString("CancelKey"));
    }
};
layout.addComponent(cancel);]]></programlisting>

            <para>
                It is normally a better practice to get the locale from an
                application-global parameter and use it to get the localized resource
                right when the component is created.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Captions are stored in MyAppCaptions resource bundle
// and the application object is known in this context.
ResourceBundle bundle =
    ResourceBundle.getBundle(MyAppCaptions.class.getName(),
                             getApplication().getLocale());
        
// Get a localized resource from the bundle
Button cancel = new Button(bundle.getString("CancelKey"));
layout.addComponent(cancel);]]></programlisting>

            <simplesect>
                <title>Selecting a Locale</title>

                <para>
                    A common task in many applications is selecting a locale. This is done
                    in the following example with a <classname>Select</classname> component.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// The locale in which we want to have the language
// selection list
Locale displayLocale = Locale.ENGLISH;
        
// All known locales
final Locale[] locales = Locale.getAvailableLocales();
        
// Allow selecting a language. We are in a constructor of a
// CustomComponent, so preselecting the current
// language of the application can not be done before
// this (and the selection) component are attached to
// the application.
final Select select = new Select("Select a language") {
    @Override
    public void attach() {
        setValue(getLocale());
    }
};
for (int i=0; i<locales.length; i++) {
    select.addItem(locales[i]);
    select.setItemCaption(locales[i],
                          locales[i].getDisplayName(displayLocale));
    
    // Automatically select the current locale
    if (locales[i].equals(getLocale()))
        select.setValue(locales[i]);
}
layout.addComponent(select);

// Locale code of the selected locale
final Label localeCode = new Label("");
layout.addComponent(localeCode);

// A date field which language the selection will change
final InlineDateField date =
    new InlineDateField("Calendar in the selected language");
date.setResolution(DateField.RESOLUTION_DAY);
layout.addComponent(date);
        
// Handle language selection
select.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        Locale locale = (Locale) select.getValue();
        date.setLocale(locale);
        localeCode.setValue("Locale code: " +
                            locale.getLanguage() + "_" +
                            locale.getCountry());
    }
});
select.setImmediate(true);]]></programlisting>

                <para>
                    The user interface is shown in <xref
                    linkend="figure.components.features.locale.selection"/>.
                </para>

                <figure xml:id="figure.components.features.locale.selection">
                    <title>Selecting a Locale</title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-locale-selection.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

            </simplesect>
        </section>

        <section xml:id="components.features.readonly">
            <title>Read-Only</title>

            <indexterm zone="components.features.readonly">
                <primary>read-only property</primary>
            </indexterm>

            <indexterm zone="components.features.readonly">
                <primary>Component interface</primary>
                <secondary>read-only</secondary>
            </indexterm>

            <para>
                The property defines whether the value of a component can be changed. The
                property is mainly applicable to <classname>Field</classname> components,
                as they have a value that can be edited by the user.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField readwrite = new TextField("Read-Write");
readwrite.setValue("You can change this");
readwrite.setReadOnly(false); // The default
layout.addComponent(readwrite);
        
TextField readonly = new TextField("Read-Only");
readonly.setValue("You can't touch this!");
readonly.setReadOnly(true);
layout.addComponent(readonly);]]></programlisting>

            <para>
                The resulting read-only text field is shown in <xref
                linkend="figure.components.features.readonly.simple"/>.
            </para>

			<figure xml:id="figure.components.features.readonly.simple">
				<title>A Read-Only Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="75%" align="center" fileref="img/components/features-readonly-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Setting a layout or some other component container as read-only does not
                usually make the contained components read-only recursively. This is
                different from, for example, the disabled state, which is usually applied
                recursively.
            </para>

            <para>
                Notice that the value of a selection component is the selection, not its
                items. A read-only selection component doesn't therefore allow its
                selection to be changed, but other changes are possible. For example, if
                you have a read-only <classname>Table</classname> in editable mode, its
                contained fields and the underlying data model can still be edited, and
                the user could sort it or reorder the columns.
            </para>

            <para>
                Client-side state modifications will not be communicated to the
                server-side and, more importantly, server-side field components will not
                accept changes to the value of a read-only <classname>Field</classname>
                component. The latter is an important security feature, because a
                malicious user can not fabricate state changes in a read-only field. This
                is handled at the level of <classname>AbstractField</classname> in
                <methodname>setValue()</methodname>, so you can not change the value
                programmatically either. Calling <methodname>setValue()</methodname> on a
                read-only field results in
                <classname>Property.ReadOnlyException</classname>. 
            </para>

            <para>
                Also notice that while the read-only status applies automatically to the
                property value of a field, it does not apply to other component
                variables. A read-only component can accept some other variable changes
                from the client-side and some of such changes could be acceptable, such as
                change in the scroll bar position of a
                <classname>Table</classname>. Custom widgets should check the read-only
                state for variables bound to business data.

                <!-- TODO: Note this also in the Advanced: Security section and
                   possibly also in the GWT chapter. -->
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <para>
                    Setting a normally editable component to read-only state can change
                    its appearance to disallow editing the value. In addition to CSS
                    styling, also the HTML structure can change. For example,
                    <classname>TextField</classname> loses the edit box and appears much
                    like a <classname>Label</classname>.
                </para>

                <para>
                    A read-only component will have the <literal>v-readonly</literal>
                    style. The following CSS rule would make the text in all read-only
                    <classname>TextField</classname> components appear in italic.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.v-textfield.v-readonly {
    font-style: italic;
}]]></programlisting>
            </simplesect>
        </section>

        <section xml:id="components.features.stylename">
            <title>Style Name</title>

            <indexterm zone="components.features.stylename">
                <primary>style name property</primary>
            </indexterm>

            <indexterm zone="components.features.stylename">
                <primary>Component interface</primary>
                <secondary>style name</secondary>
            </indexterm>

            <para>
                The <emphasis>style name</emphasis> property defines one or more custom
                CSS style class names for the component. The
                <methodname>getStyleName()</methodname> returns the current style names as
                a space-separated list. The <methodname>setStyleName()</methodname>
                replaces all the styles with the given style name or a space-separated
                list of style names. You can also add and remove individual style names
                with <methodname>addStylename()</methodname> and
                <methodname>removeStyleName()</methodname>. A style name must be a valid
                CSS style name.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[Label label = new Label("This text has a lot of style");
label.addStyleName("mystyle");
layout.addComponent(label);]]></programlisting>

            <para>
                The style name will appear in the component's HTML element in two forms:
                literally as given and prefixed with the component class specific style
                name. For example, if you add a style name <literal>mystyle</literal> to a
                <classname>Button</classname>, the component would get both
                <literal>mystyle</literal> and <literal>v-button-mystyle</literal>
                styles. Neither form may conflict with built-in style names of Vaadin. For
                example, <literal>focus</literal> style would conflict with a built-in
                style of the same name, and an <literal>option</literal> style for a
                <classname>Select</classname> component would conflict with the built-in
                <literal>v-select-option</literal> style.
            </para>

            <para>
                The following CSS rule would apply the style to any component that has the
                <literal>mystyle</literal> style.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[.mystyle {
    font-family: fantasy;
    font-style:  italic;
    font-size:   25px;
    font-weight: bolder;
    line-height: 30px;
}]]></programlisting>

            <para>
                The resulting styled component is shown in <xref
                linkend="figure.components.features.stylename"/>
            </para>

			<figure xml:id="figure.components.features.stylename">
				<title>Component with a Custom Style</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-stylename-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>
        </section>

        <section xml:id="components.features.visible">
            <title>Visible</title>
            
            <indexterm zone="components.features.visible">
                <primary>visible property</primary>
            </indexterm>

            <indexterm zone="components.features.visible">
                <primary>Component interface</primary>
                <secondary>visible</secondary>
            </indexterm>

            <para>
                Components can be hidden by setting the <emphasis>visible</emphasis>
                property to <emphasis>false</emphasis>. Also the caption, icon and any
                other component features are made hidden. Hidden components are not just
                invisible, but their content is not communicated to the browser at
                all. That is, they are not made invisible cosmetically with only CSS
                rules. This feature is important for security if you have components that
                contain security-critical information that must only be shown in specific
                application states.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[TextField readonly = new TextField("Read-Only");
readonly.setValue("You can't see this!");
readonly.setVisible(false);
layout.addComponent(readonly);]]></programlisting>

            <para>
                The resulting invisible component is shown in <xref
                linkend="figure.components.features.visible.simple"/>.
            </para>

			<figure xml:id="figure.components.features.visible.simple">
				<title>An Invisible Component.</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="80" smallscale="100%" align="center" fileref="img/components/features-visible-simple.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                Beware that invisible beings can leave footprints. The containing layout
                cell that holds the invisible component will not go away, but will show in
                the layout as extra empty space. Also expand ratios work just like if the
                component was visible - it is the layout cell that expands, not the
                component.
            </para>

            <para>
                If you need to make a component only cosmetically invisible, you should
                use a custom theme to set it <literal>display: none</literal> style. This
                is mainly useful for certain special components such as
                <classname>ProgressIndicator</classname>, which have effects even when
                made invisible in CSS. If the hidden component has undefined size and is
                enclosed in a layout that also has undefined size, the containing layout
                will collapse when the component disappears. If you want to have the
                component keep its size, you have to make it invisible by setting all its
                font and other attributes to be transparent. In such cases, the invisible
                content of the component can be made visible easily in the browser.
            </para>

            <para>
                A component made invisible with the <emphasis>visible</emphasis> property
                has no particular CSS style class to indicate that it is hidden. The
                element does exist though, but has <literal>display: none</literal> style,
                which overrides any CSS styling.
            </para>
        </section>

		<section xml:id="components.features.sizeable">
			<title>Sizing Components</title>

            <indexterm zone="components.features.sizeable">
                <primary><classname>Sizeable</classname> interface</primary>
            </indexterm>

			<para>
				Vaadin components are sizeable; not in the sense that they were
				fairly large or that the number of the components and their features are
				sizeable, but in the sense that you can make them fairly large on the
				screen if you like, or small or whatever size.
			</para>

			<para>
				The <classname>Sizeable</classname> interface, shared by all components,
				provides a number of manipulation methods and constants for setting the
				height and width of a component in absolute or relative units, or for
				leaving the size undefined.
			</para>

			<para>
				The size of a component can be set with
				<methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname> methods. The methods take the size as
				a floating-point value. You need to give the unit of the measure as the
				second parameter for the above methods. The available units are listed in
				<xref linkend="components.features.sizeable.units.table"/> below.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth(100, Sizeable.UNITS_PERCENTAGE);
mycomponent.setWidth(400, Sizeable.UNITS_PIXELS);]]></programlisting>

			<para>
				Alternatively, you can speficy the size as a string. The format of such a
				string must follow the HTML/CSS standards for specifying measures.
			</para>

			<programlisting><![CDATA[mycomponent.setWidth("100%");
mycomponent.setHeight("400px");]]></programlisting>

			<para>
				The "<literal>100%</literal>" percentage value makes the component take
				all available size in the particular direction (see the description of
				<parameter>Sizeable.UNITS_PERCENTAGE</parameter> in the table below). You
				can also use the shorthand method <methodname>setSizeFull()</methodname>
				to set the size to 100% in both directions.
			</para>

			<para>
				The size can be <emphasis>undefined</emphasis> in either or both
				dimensions, which means that the component will take the minimum necessary
				space. Most components have undefined size by default, but some layouts
				have full size in horizontal direction. You can set the height or width as
				undefined with <parameter>Sizeable.SIZE_UNDEFINED</parameter> parameter
				for <methodname>setWidth()</methodname> and
				<methodname>setHeight()</methodname>.
			</para>

			<para>
				You always need to keep in mind that <emphasis>a layout with undefined
				size may not contain components with defined relative size</emphasis>,
				such as "full size". See <xref linkend="layout.settings.size"/> for
				details.
			</para>

			<para>
				The <xref linkend="components.features.sizeable.units.table"/> lists the
				available units and their codes defined in the
				<classname>Sizeable</classname> interface.
			</para>

			<table xml:id="components.features.sizeable.units.table">
				<title>Size Units</title>
				<tgroup cols="3" align="left">
					<tbody>
						<row valign="top">
							<entry><parameter>UNITS_PIXELS</parameter></entry>
							<entry>px</entry>

							<entry>The <emphasis>pixel</emphasis> is the basic
							hardware-specific measure of one physical display
							pixel.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_POINTS</parameter></entry>
							<entry>pt</entry>

							<entry>The <emphasis>point</emphasis> is a typographical unit,
							which is usually defined as 1/72 inches or about 0.35
							mm. However, on displays the size can vary significantly
							depending on display metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_PICAS</parameter></entry>
							<entry>pc</entry>

							<entry>The <emphasis>pica</emphasis> is a typographical unit,
							defined as 12 points, or 1/7 inches or about 4.233 mm. On
							displays, the size can vary depending on display
							metrics.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_EM</parameter></entry>
							<entry>em</entry>

							<entry>A unit relative to the used font, the width of the
							upper-case "M" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_EX</parameter></entry>
							<entry>ex</entry>

							<entry>A unit relative to the used font, the height of the
							lower-case "x" letter.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_MM</parameter></entry>
							<entry>mm</entry>

							<entry>A physical length unit, millimeters on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_CM</parameter></entry>
							<entry>cm</entry>

							<entry>A physical length unit,
							<emphasis>centimeters</emphasis> on the surface of a display
							device. However, the actual size depends on the display, its
							metrics in the operating system, and the browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_INCH</parameter></entry>
							<entry>in</entry>

							<entry>A physical length unit, <emphasis>inches</emphasis> on the surface of a
							display device. However, the actual size depends on the
							display, its metrics in the operating system, and the
							browser.</entry>
						</row>
						<row valign="top">
							<entry><parameter>UNITS_PERCENTAGE</parameter></entry>
							<entry>%</entry>

							<entry>A relative percentage of the available size. For
							example, for the top-level layout <parameter>100%</parameter>
							would be the full width or height of the browser window. The
							percentage value must be between 0 and 100.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

			<para>
				If a component inside <classname>HorizontalLayout</classname> or
				<classname>VerticalLayout</classname> has full size in the namesake
				direction of the layout, the component will expand to take all available
				space not needed by the other components. See <xref
				linkend="layout.settings.size"/> for details.
			</para>
		</section>

		<!-- section>
			<title>Buffering Data (<classname>Buffered</classname> interface)</title>
		</section>
				
		<section>
			<title>Validating Fields (<classname>Validatable</classname> interface)</title>
		</section -->
				
		<section>
			<title>Managing Input Focus</title>

			<para>
				When the user clicks on a component, the component gets the
				<emphasis>input focus</emphasis>, which is indicated by highlighting
				according to style definitions. If the component allows inputting text,
				the focus and insertion point are indicated by a cursor. Pressing the
				<keycap>Tab</keycap> key moves the focus to the component next in the
				<emphasis>focus order</emphasis>.
			</para>

			<para>
				Focusing is supported by all <classname>Field</classname> components and
				also by <classname>Upload</classname>.
			</para>

			<para>
				The focus order or <emphasis>tab index</emphasis> of a component is
				defined as a positive integer value, which you can set with
				<methodname>setTabIndex()</methodname> and get with
				<methodname>getTabIndex()</methodname>. The tab index is managed in the
				context of the application-level <classname>Window</classname> in which
				the components are contained. The focus order can therefore jump between
				two any lower-level component containers, such as sub-windows or panels.
			</para>

			<para>
				The default focus order is determined by the natural hierarchical order of
				components in the order in which they were added under their parents. The
				default tab index is 0 (zero).
			</para>

			<para>
				Giving a negative integer as the tab index removes the component from the
				focus order entirely.
			</para>

			<simplesect>
				<title>CSS Style Rules</title>

				<para>
					The component having the focus will have an additional style class
					with the <literal>-focus</literal> suffix. For example, a
					<classname>TextField</classname>, which normally has the
					<literal>v-textfield</literal> style, would additionally have the
					<literal>v-textfield-focus</literal> style.
				</para>

				<para>
					For example, the following would make a text field blue when it has
					focus.
				</para>

				<programlisting><![CDATA[.v-textfield-focus {
    background: lightblue;
}]]></programlisting>
            </simplesect>
        </section>
	</section>

	<section xml:id="components.extensions">
		<title>Component Extensions</title>

        <para>
            Components can have extensions which are attached to a component
            dynamically. Especially many add-on features are extensions.
        </para>

        <para>
            To add an extension to a component, call the <methodname>extend()</methodname>
            method in the extension.
        </para>

        <programlisting><![CDATA[TextField tf = new TextField("Hello");
layout.addComponent(tf);

// Add a simple extension
new CapsLockWarning().extend(tf);

// Add an extension that requires some parameters
CSValidator validator = new CSValidator();
validator.setRegExp("[0-9]*");
validator.setErrorMessage("Must be a number");
validator.extend(tf);]]></programlisting>
    </section>

	<section xml:id="components.label">
		<title><classname>Label</classname></title>

		<para>
			<classname>Label</classname> is a text component that displays non-editable
			text. In addition to regular text, you can also display preformatted text and
			HTML, depending on the <emphasis>content mode</emphasis> of the label.
		</para>

		<book-example id="component.label.basic" style="float: right"></book-example>
        <programlisting><?pocket-size 75% ?><![CDATA[// A container that is 100% wide by default
VerticalLayout layout = new VerticalLayout();

Label label = new Label("Labeling can be dangerous");
layout.addComponent(label);]]></programlisting>

        <para>
            The text will wrap around and continue on the next line if it exceeds the
            width of the <classname>Label</classname>. The default width is 100%, so the
            containing layout must also have a defined width. Some layout components have
            undefined width by default, such as <classname>HorizontalLayout</classname>,
            so you need to pay special care with them.
        </para>

		<book-example id="component.label.wrap" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[// A container with a defined width. The default content layout
// of Panel is VerticalLayout, which has 100% default width.
Panel panel = new Panel("Panel Containing a Label");
panel.setWidth("300px");

panel.addComponent(
    new Label("This is a Label inside a Panel. There is " +
              "enough text in the label to make the text " +
              "wrap when it exceeds the width of the panel."));]]></programlisting>

        <para>
            As the size of the <classname>Panel</classname> in the above example is fixed
            and the width of <classname>Label</classname> is the default 100%, the text in
            the <classname>Label</classname> will wrap to fit the panel, as shown in <xref
            linkend="figure.components.label"/>.
        </para>

		<figure xml:id="figure.components.label">
			<title>The Label Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/label-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="80" smallscale="120" align="center" fileref="img/components/label-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Setting <classname>Label</classname> to undefined width will cause it to not
            wrap at the end of the line, as the width of the content defines the width. If
            placed inside a layout with defined width, the <classname>Label</classname>
            will overflow the layout horizontally and, normally, be truncated.
        </para>

        <para>
            Even though <classname>Label</classname> is text and often used as a caption,
            it also has a caption, just like any other component. As with other
            components, the caption is managed by the containing layout.
        </para>

        <section xml:id="components.label.content-mode">
            <title>Content Mode</title>

            <para>
                The contents of a label are formatted depending on the content mode. By
                default, the text is assumed to be plain text and any contained
                XML-specific characters will be quoted appropriately to allow rendering
                the contents of a label in XHTML in a web browser. The content mode can be
                set in the constructor or with <methodname>setContentMode()</methodname>,
                and can have the values defined in the
                <classname>Label.ContentMode</classname> enumeration type:
            </para>

            <variablelist>
                <varlistentry>
                    <term><constant>DEFAULT</constant></term>
                    <listitem>
                        <para>
                            The default content mode is <varname>TEXT</varname> (see
                            below).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>TEXT</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains only plain text. All
                            characters are allowed, including the special
                            <literal>&lt;</literal>, <literal>&gt;</literal>, and
                            <literal>&amp;</literal> characters in XML or HTML, which are
                            quoted properly in XHTML while rendering the component. This
                            is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
				<term><constant>PREFORMATTED</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains preformatted text. It will
                            be, by default, rendered with a fixed-width typewriter
                            font. Preformatted text can contain line breaks, written in Java
                            with the <literal>\n</literal> escape sequence for a newline
                            character (ASCII 0x0a), or tabulator characters written with
                            <literal>\t</literal> (ASCII 0x08).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>RAW</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains raw text. Output is not
                            required to be valid XML. It can be, for example, HTML, which
                            can be unbalanced or otherwise invalid XML. The example below
                            uses the &lt;br&gt; tag in HTML. While XHTML should be
                            preferred in most cases, this can be useful for some specific
                            purposes where you may need to display loosely formatted HTML
                            content. The raw mode also preserves character entities, some
                            of which might otherwise be interpreted incorrectly.
                        </para>

                        <para>
                            Please note the security and validity warnings regarding the
                            content mode later in this section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>XHTML</constant></term>
                    <listitem>
                        <para>
                            Content mode where the label contains XHTML. The content will
                            be enclosed in a DIV element having the namespace
                            "<uri>http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</uri>".
                        </para>

                        <para>
                            Please note the security and validity warnings regarding the
                            content mode later in this section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>XML</constant></term>
                    <listitem>
                        <para>
                            Content mode, where the label contains well-formed and
                            well-balanced XML. Each of the root elements must have their
                            default namespace specified.
                        </para>

                        <para>
                            Please note the security and validity warnings regarding the
                            content mode later in this section.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constant>UIDL</constant></term>
                    <listitem>
                        <para>
                            Formatted content mode, where the contents are XML that is
                            restricted to UIDL 1.0, the internal language of Vaadin for AJAX
                            communications between the server and the browser. Obsolete since
                            IT Mill Toolkit 5.0.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <warning>
                <title>Cross-Site Scripting Warning</title>

                <para>
                    Having <classname>Label</classname> in <constant>RAW</constant>,
                    <constant>XHTML</constant>, or <constant>XML</constant> content modes
                    allows pure HTML content. If the content comes from user input, you
                    should always carefully sanitize it to prevent cross-site scripting
                    (XSS) attacks. Please see <xref
                    linkend="advanced.security.sanitizing"/>.
                </para>

                <para>
                    Also, the validity of the XML content is not checked when rendering
                    the component and any errors can result in an error in the browser. If
                    the content comes from an uncertain source, you should always validate
                    it before displaying it in the component.
                </para>
            </warning>

            <para>
                The following example demonstrates the use of
                <classname>Label</classname> in different modes.
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[GridLayout labelgrid = new GridLayout (2,1);

labelgrid.addComponent (new Label ("DEFAULT"));
labelgrid.addComponent (
    new Label ("This is a label in default mode: <plain text>",
               Label.ContentMode.DEFAULT));

labelgrid.addComponent (new Label ("PREFORMATTED"));
labelgrid.addComponent (
    new Label ("This is a preformatted label.\n"+
               "The newline character \\n breaks the line.",
               Label.ContentMode.PREFORMATTED));

labelgrid.addComponent (new Label ("RAW"));
labelgrid.addComponent (
    new Label ("This is a label in raw mode.<br>It can contain, "+
               "for example, unbalanced markup.",
               Label.ContentMode.RAW));

labelgrid.addComponent (new Label ("TEXT"));
labelgrid.addComponent (
    new Label ("This is a label in (plain) text mode",
               Label.ContentMode.TEXT));

labelgrid.addComponent (new Label ("XHTML"));
labelgrid.addComponent (
    new Label ("<i>This</i> is an <b>XHTML</b> formatted label",
               Label.ContentMode.XHTML));

labelgrid.addComponent (new Label ("XML"));
labelgrid.addComponent (
    new Label ("This is an <myelement>XML</myelement> "+
               "formatted label",
               Label.ContentMode.XML));

main.addComponent(labelgrid);]]></programlisting>

            <para>
                The rendering will look as follows:
            </para>

            <figure>
                <title>Label Modes Rendered on Screen</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="60" smallscale="100%" align="center" fileref="img/components/label-modes.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <section xml:id="components.label.html-mode">
            <title>Making Use of the XHTML Mode</title>

            <para>
                Using the XHTML, XML, or raw modes allow inclusion of, for example,
                images within the text flow, which is not possible with any regular
                layout components. The following example includes an image within
                the text flow, with the image coming from a class loader resource.
            </para>
            
            <programlisting><?pocket-size 65% ?><![CDATA[ClassResource labelimage = new ClassResource ("labelimage.jpg",
                                              this);
main.addComponent(new Label("Here we have an image <img src=\"" +
                            this.getRelativeLocation(labelimage) +
                            "\"/> within text.",
                            Label.ContentMode.XHTML));]]></programlisting>

            <para>
                When you use a class loader resource, the image has to be included in
                the JAR of the web application. In this case, the
                <filename>labelimage.jpg</filename> needs to be in the default
                package. When rendered in a web browser, the output will look as
                follows:
            </para>

            <figure>
                <title>Referencing An Image Resource in Label</title>
                <mediaobject>
                    <imageobject>
                        <imagedata align="center" fileref="img/components/label-withimage.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            
            <para>
                Another solution would be to use the
                <classname>CustomLayout</classname> component, where you can write
                the component content as an XHTML fragment in a theme, but such a
                solution may be too heavy for most cases.
            </para>

            <para>
                Notice that the rendering of XHTML depends on the assumption that the
                client software and the terminal adapter are XHTML based. It is
                possible to write a terminal adapter for a custom thin client
                application, which may not be able to render XHTML at all. There are
                also differences between web browsers in their support of XHTML.
            </para>
        </section>

        <section xml:id="components.label.spacing">
            <title>Spacing with a <classname>Label</classname></title>
                
            <para>
                You can use a <classname>Label</classname> to create vertical or
                horizontal space in a layout. If you need a empty "line" in a vertical
                layout, having just a label with empty text is not enough, as it will
                collapse to zero height. The same goes for a label with only whitespace as
                the label text. You need to use a non-breaking space character, either
                <literal>&amp;nbsp;</literal> or <literal>&amp;#160;</literal>:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[layout.addComponent(new Label("&nbsp;", Label.ContentMode.XHTML));]]></programlisting>

            <para>
                Using the <parameter>Label.ContentMode.PREFORMATTED</parameter> mode has the
                same effect; preformatted spaces do not collapse in a vertical layout. In
                a <classname>HorizontalLayout</classname>, the width of a space character
                may be unpredictable if the label font is proportional, so you can use the
                preformatted mode to add em-width wide spaces.
            </para>

            <para>
                If you want a gap that has adjustable width or height, you can use an
                empty label if you specify a height or width for it. For example, to
                create vertical space in a <classname>VerticalLayout</classname>:
            </para>

            <programlisting><![CDATA[Label gap = new Label();
gap.setHeight("1em");
verticalLayout.addComponent(gap);]]></programlisting>

            <para>
                You can make a flexible expanding spacer by having a relatively sized
                empty label with <literal>100%</literal> height or width and setting the
                label as expanding in the layout.
            </para>

            <programlisting><![CDATA[// A wide component bar
HorizontalLayout horizontal = new HorizontalLayout();
horizontal.setWidth("100%");

// Have a component before the gap (a collapsing cell)
Button button1 = new Button("I'm on the left");
horizontal.addComponent(button1);

// An expanding gap spacer
Label expandingGap = new Label();
expandingGap.setWidth("100%");
horizontal.addComponent(expandingGap);
horizontal.setExpandRatio(expandingGap, 1.0f);

// A component after the gap (a collapsing cell)
Button button2 = new Button("I'm on the right");
horizontal.addComponent(button2);]]></programlisting>
        </section>


		<section xml:id="components.label.css">
			<title>CSS Style Rules</title>

            <para>
                The <classname>Label</classname> component has a
                <literal>v-label</literal> overall style.
            </para>

            <para>
                The Reindeer theme includes a number of predefined styles for typical
                formatting cases. These include "<literal>h1</literal>"
                (<methodname>Reindeer.LABEL_H1</methodname>) and "<literal>h2</literal>"
                (<methodname>Reindeer.LABEL_H2</methodname>) heading styles and
                "<literal>light</literal>" (<methodname>Reindeer.LABEL_SMALL</methodname>)
                style.
            </para>
        </section>
	</section>

	<section xml:id="components.link">
		<title><classname>Link</classname></title>

		<para>
			The <classname>Link</classname> component allows making hyperlinks. References
			to locations are represented as resource objects, explained in <xref
			linkend="application.resources"/>. The <classname>Link</classname> is a
			regular HTML hyperlink, that is, an <literal>&lt;a href&gt;</literal> anchor
			element that is handled natively by the browser. Unlike when clicking a
			<classname>Button</classname>, clicking a <classname>Link</classname> does not
			cause an event on the server-side.
		</para>

		<para>
			Links to an arbitrary URL can be made by using an
			<classname>ExternalResource</classname> as follows:
		</para>

		<book-example id="component.link.basic" style="float: right"></book-example>
		<programlisting><![CDATA[// Textual link
Link link = new Link("Click Me!",
        new ExternalResource("http://vaadin.com/"));]]></programlisting>

        <para>
            You can use <methodname>setIcon()</methodname> to make image links as follows:
        </para>

		<programlisting><?pocket-size 65% ?><![CDATA[// Image link
Link iconic = new Link(null,
        new ExternalResource("http://vaadin.com/"));
iconic.setIcon(new ThemeResource("img/nicubunu_Chain.png"));

// Image + caption
Link combo = new Link("To appease both literal and visual",
        new ExternalResource("http://vaadin.com/"));
combo.setIcon(new ThemeResource("img/nicubunu_Chain.png"));]]></programlisting>

        <para>
            The resulting links are shown in <xref
            linkend="figure.components.link.basic"/>. You could add a "<literal>display:
            block</literal>" style for the icon element to place the caption below it.
        </para>

		<figure xml:id="figure.components.link.basic">
			<title><classname>Link</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/link.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="80%" align="center" fileref="img/components/link.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            With the simple constructor used in the above example, the resource is opened
            in the current window. Using the constructor that takes the target window as a
            parameter, or by setting the target window with
            <methodname>setTargetName()</methodname>, you can open the resource in another
            window, such as a native popup window. As the target name is an HTML
            <literal>target</literal> string managed by the browser, the target can be any
            window, including windows not managed by the application itself. You can use
            the special underscored target names, such as <literal>_blank</literal> to
            open the link to a new browser window or tab.
		</para>

		<book-example id="component.link.target" style="float: right"></book-example>
        <programlisting><?pocket-size 65% ?><![CDATA[// Hyperlink to a given URL
Link link = new Link("Take me a away to a faraway land",
        new ExternalResource("http://vaadin.com/"));

// Open the URL in a new window/tab
link.setTargetName("_blank");
        
// Indicate visually that it opens in a new window/tab
link.setIcon(new ThemeResource("icons/external-link.png"));
link.addStyleName("icon-after-caption");]]></programlisting>

        <para>
            Normally, the link icon is before the caption. You can have it right of the
            caption by reversing the text direction in the containing element.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[/* Position icon right of the link caption. */
.icon-after-caption {
    direction: rtl;
}
/* Add some padding around the icon. */
.icon-after-caption .v-icon {
    padding: 0 3px;
}]]></programlisting>

        <para>
            The resulting link is shown in <xref linkend="figure.components.link.new-window"/>.
        </para>

		<figure xml:id="figure.components.link.new-window">
			<title>Link That Opens a New Window</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata scale="50" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/link-new.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            With the <literal>_blank</literal> target, a normal new browser window is
            opened. If you wish to open it in a popup window, you need to give a size for
            the window with <methodname>setTargetWidth()</methodname> and
            <methodname>setTargetHeight()</methodname>. You can control the window border
            style with <methodname>setTargetBorder()</methodname>, which takes any of the
            defined border styles <parameter>TARGET_BORDER_DEFAULT</parameter>,
            <parameter>TARGET_BORDER_MINIMAL</parameter>, and
            <parameter>TARGET_BORDER_NONE</parameter>. The exact result depends on the
            browser.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Open the URL in a popup
link.setTargetName("_blank");
link.setTargetBorder(Link.TARGET_BORDER_NONE);
link.setTargetHeight(300);
link.setTargetWidth(400);]]></programlisting>

        <!-- TODO: Describe _new, _black, etc. targets and give an example. -->

		<para>
            In addition to the <classname>Link</classname> component, Vaadin allows
            alternative ways to make hyperlinks. The <classname>Button</classname>
            component has a <parameter>Reindeer.BUTTON_LINK</parameter> style name that
            makes it look like a hyperlink, while handling clicks in a server-side click
            listener instead of in the browser. Also, you can make hyperlinks (or any
            other HTML) in a <classname>Label</classname> in XHTML content mode.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><?dbfo-need height="3cm" ?><![CDATA[.v-link { }
  a { }
    .v-icon {}
    span {}]]></programlisting>

			<para>
                The overall style for the <classname>Link</classname> component is
                <literal>v-link</literal>. The root element contains the <literal>&lt;a
                href&gt;</literal> hyperlink anchor. Inside the anchor are the icon, with
                <literal>v-icon</literal> style, and the caption in a text span.
            </para>

            <para>
                Hyperlink anchors have a number of <emphasis>pseudo-classes</emphasis>
                that are active at different times. An unvisited link has
                <literal>a:link</literal> class and a visited link
                <literal>a:visited</literal>. When the mouse pointer hovers over the link,
                it will have <varname>a:hover</varname>, and when the mouse button is
                being pressed over the link, the <literal>a:active</literal> class. When
                combining the pseudo-classes in a selector, please notice that
                <literal>a:hover</literal> must come after an <literal>a:link</literal>
                and <literal>a:visited</literal>, and <literal>a:active</literal> after
                the <literal>a:hover</literal>.
			</para>
		</simplesect>
	</section>

	<section xml:id="components.textfield">
		<title><classname>TextField</classname></title>

        <indexterm xml:id="term.components.textfield" class="startofrange">
            <primary><classname>TextField</classname></primary>
        </indexterm>

		<para>
			<classname>TextField</classname> is one of the most commonly used user
			interface components. It is a <classname>Field</classname> component that
			allows entering textual values using keyboard.
		</para>

		<para>
			The following example creates a simple text field:
		</para>

        <book-example id="component.textfield.basic" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a text field
TextField tf = new TextField("A Field");
        
// Put some initial content in it
tf.setValue("Stuff in the field");]]></programlisting>

        <para>
            See the result in <xref linkend="figure.components.textfield.basic"/>.
        </para>

		<figure xml:id="figure.components.textfield.basic">
			<title><classname>TextField</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="90%" align="center" fileref="img/components/textfield-example.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Value changes are handled with a
            <classname>Property.ValueChangeListener</classname>, as in most other
            fields. The value can be acquired with <methodname>getValue()</methodname>
            directly from the text field, as is done in the example below, or from the
            property reference of the event.
        </para>

        <book-example id="component.textfield.inputhandling" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[// Handle changes in the value
tf.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Assuming that the value type is a String
        String value = (String) tf.getValue();

        // Do something with the value
        Notification.show("Value is:", value);
    }
});
        
// Fire value changes immediately when the field loses focus
tf.setImmediate(true);]]></programlisting>

        <para>
            Much of the API of <classname>TextField</classname> is defined in
            <classname>AbstractTextField</classname>, which allows different kinds of text
            input fields, such as rich text editors, which do not share all the features
            of the single-line text fields.
        </para>

		<figure xml:id="figure.components.textfield.api">
			<title>Text Field Class Relationships</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textfield-diagram-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="75%" align="center" fileref="img/components/textfield-diagram-lo.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.textfield.databinding">
            <title>Data Binding</title>

            <book-example id="component.textfield.valuetype" style="float: right"></book-example>
            <para>
                <classname>TextField</classname> edits <classname>String</classname>
                values, but you can bind it to any property type that has a proper
                converter, as described in <xref
                linkend="datamodel.properties.converter"/>.
            </para>

            <book-example id="component.textfield.databinding" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[// Have an initial data model. As Double is unmodificable and
// doesn't support assignment from String, the object is
// reconstructed in the wrapper when the value is changed.
Double trouble = 42.0;
        
// Wrap it in a property data source
final ObjectProperty<Double> property =
    new ObjectProperty<Double>(trouble);
        
// Create a text field bound to it
// (StringToDoubleConverter is used automatically)
TextField tf = new TextField("The Answer", property);
tf.setImmediate(true);

// Show that the value is really written back to the
// data source when edited by user.
Label feedback = new Label(property);
feedback.setCaption("The Value");]]></programlisting>

            <para>
                When you put a <classname>Table</classname> in editable mode or create
                fields with a <classname>FieldGroup</classname>, the
                <classname>DefaultFieldFactory</classname> creates a
                <classname>TextField</classname> for almost every property type by
                default. You often need to make a custom factory to customize the creation
                and to set the field tooltip, validation, formatting, and so on.
            </para>

            <para>
                See <xref linkend="datamodel"/> for more details on data binding, field
                factories for <classname>Table</classname> in <xref
                linkend="components.table.editing"/>, and <xref
                linkend="datamodel.itembinding"/> regarding forms.
            </para>

            <book-example id="component.textfield.beanbinding">
                Bean Binding
            </book-example>
        </section>

        <section xml:id="components.textfield.length">
            <title>String Length</title>

            <para>
                The <methodname>setMaxLength()</methodname> method sets the maximum length
                of the input string so that the browser prevents the user from entering a
                longer one. As a security feature, the input value is automatically
                truncated on the server-side, as the maximum length setting could be
                bypassed on the client-side. The maximum length property is defined at
                <classname>AbstractTextField</classname> level.
            </para>

            <para>
                Notice that the maximum length setting does not affect the width of the
                field. You can set the width with <methodname>setWidth()</methodname>, as
                with other components. Using <emphasis>em</emphasis> widths is recommended
                to better approximate the proper width in relation to the size of the used
                font. There is no standard way in HTML for setting the width exactly to a
                number of letters (in a monospaced font). You can trick your way around
                this restriction by putting the text field in an undefined-width
                <classname>VerticalLayout</classname> together with an undefined-width
                <classname>Label</classname> that contains a sample text, and setting the
                width of the text field as 100%. The layout will get its width from the
                label, and the text field will use that.
            </para>

            <book-example id="component.textfield.widthfitting">
                Fitting TextField width to fixed input length
            </book-example>
        </section>

        <section xml:id="components.textfield.nullvalues">
            <title>Handling Null Values</title>

            <indexterm xml:id="term.components.textfield.nullvalues" class="startofrange">
                <primary>Null representation</primary>
            </indexterm>

            <para>
                <indexterm><primary><methodname>setNullRepresentation()</methodname></primary></indexterm>

                As with any field, the value of a <classname>TextField</classname> can be
                set as <parameter>null</parameter>. This occurs most commonly when you
                create a new field without setting a value for it or bind the field value
                to a data source that allows null values. In such case, you might want to
                show a special value that stands for the null value. You can set the null
                representation with the <methodname>setNullRepresentation()</methodname>
                method. Most typically, you use an empty string for the null
                representation, unless you want to differentiate from a string that is
                explicitly empty. The default null representation is
                "<literal>null</literal>", which essentially warns that you may have
                forgotten to initialize your data objects properly. 
            </para>

            <para>
                <indexterm><primary><methodname>setNullSettingAllowed()</methodname></primary></indexterm>

                The <methodname>setNullSettingAllowed()</methodname> controls whether the
                user can actually input a null value by using the null value
                representation. If the setting is <literal>false</literal>, which is the
                default, inputting the null value representation string sets the value as
                the literal value of the string, not null. This default assumption is a
                safeguard for data sources that may not allow null values.
            </para>

            <book-example id="component.textfield.nullvaluerepresentation" style="float: right"></book-example>

<programlisting><?pocket-size 75% ?><![CDATA[// Create a text field without setting its value
TextField tf = new TextField("Field Energy (J)");
tf.setNullRepresentation("-- null-point energy --");

// The null value is actually the default
tf.setValue(null);
        
// Allow user to input the null value by
// its representation
tf.setNullSettingAllowed(true);

// Feedback to see the value
Label value = new Label(tf);
value.setCaption("Current Value:");]]></programlisting>

            <para>
                The <classname>Label</classname>, which is bound to the value of the
                <classname>TextField</classname>, displays a null value as empty. The
                resulting user interface is shown in <xref
                linkend="figure.components.textfield.nullvalues"/>.
            </para>

            <figure xml:id="figure.components.textfield.nullvalues">
                <title>Null Value Representation</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="90%" align="center" fileref="img/components/textfield-nullrepresentation.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <indexterm startref="term.components.textfield.nullvalues" class="endofrange"/>
        </section>

        <!--section>
            <title>Formatting Text Field Values</title>

            <para>
        TODO
            </para>
        </section -->

        <section xml:id="components.textfield.textchangeevents">
            <title>Text Change Events</title>

            <indexterm xml:id="term.components.textfield.textchangeevents" class="startofrange">
                <primary><classname>Text change events</classname></primary>
            </indexterm>

            <para>
                Often you want to receive a change event immediately when the text field
                value changes. The <emphasis>immediate</emphasis> mode is not literally
                immediate, as the changes are transmitted only after the field loses
                focus. In the other extreme, using keyboard events for every keypress
                would make typing unbearably slow and also processing the keypresses is
                too complicated for most purposes. <emphasis>Text change events</emphasis>
                are transmitted asynchronously soon after typing and do not block typing
                while an event is being processed.
            </para>

            <para>
                Text change events are received with a
                <classname>TextChangeListener</classname>, as is done in the following
                example that demonstrates how to create a text length counter:
            </para>

            <book-example id="component.textfield.textchangeevents" style="float: right"></book-example>
            <programlisting><?pocket-size 65% ?><![CDATA[// Text field with maximum length
final TextField tf = new TextField("My Eventful Field");
tf.setValue("Initial content");
tf.setMaxLength(20);

// Counter for input length
final Label counter = new Label();
counter.setValue(tf.toString().length() +
                 " of " + tf.getMaxLength());
        
// Display the current length interactively in the counter
tf.addListener(new TextChangeListener() {
    public void textChange(TextChangeEvent event) {
        int len = event.getText().length();
        counter.setValue(len + " of " + tf.getMaxLength());
    }
});

// This is actually the default
tf.setTextChangeEventMode(TextChangeEventMode.LAZY);]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.textchangeevents"/>.
            </para>

            <figure xml:id="figure.components.textfield.textchangeevents">
                <title>Text Change Events</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="70%" align="center" fileref="img/components/textfield-textchangeevents.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The <emphasis>text change event mode</emphasis> defines how quickly the
                changes are transmitted to the server and cause a server-side
                event. Lazier change events allow sending larger changes in one event if
                the user is typing fast, thereby reducing server requests.
            </para>

            <para>
                You can set the text change event mode of a
                <classname>TextField</classname> with
                <methodname>setTextChangeEventMode()</methodname>. The allowed modes are
                defined in <classname>TextChangeEventMode</classname> class and are the
                following:
            </para>

            <variablelist>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.LAZY</parameter> (default)</term>
                    <listitem>
                        <para>
                            An event is triggered when there is a pause in editing the
                            text. The length of the pause can be modified with
                            <methodname>setInputEventTimeout()</methodname>. As with the
                            <parameter>TIMEOUT</parameter> mode, a text change event is
                            forced before a possible
                            <classname>ValueChangeEvent</classname>, even if the user did
                            not keep a pause while entering the text.
                        </para>

                        <para>
                            This is the default mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.TIMEOUT</parameter></term>
                    <listitem>
                        <para>
                            A text change in the user interface causes the event to be
                            communicated to the application after a timeout period. If
                            more changes are made during this period, the event sent to
                            the server-side includes the changes made up to the last
                            change. The length of the timeout can be set with
                            <methodname>setInputEventTimeout()</methodname>.
                        </para>

                        <para>
                            If a <classname>ValueChangeEvent</classname> would occur
                            before the timeout period, a
                            <classname>TextChangeEvent</classname> is triggered before it,
                            on the condition that the text content has changed since the
                            previous <classname>TextChangeEvent</classname>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>TextChangeEventMode.EAGER</parameter></term>
                    <listitem>
                        <para>
                            An event is triggered immediately for every change in the text
                            content, typically caused by a key press. The requests are
                            separate and are processed sequentially one after
                            another. Change events are nevertheless communicated
                            asynchronously to the server, so further input can be typed
                            while event requests are being processed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>

            <indexterm startref="term.components.textfield.textchangeevents" class="endofrange"/>
        </section>

        <section xml:id="components.textfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextField</classname> is extremely simple,
                consisting only of an element with <literal>v-textfield</literal> style.
            </para>

            <para>
                For example, the following custom style uses dashed border:
            </para>

            <book-example id="component.textfield.css" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[.v-textfield-dashing {
    border:     thin dashed;
    background: white; /* Has shading image by default */
}]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textfield.css"/>.
            </para>

            <figure xml:id="figure.components.textfield.css">
                <title>Styling TextField with CSS</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textfield-css.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The style name for <classname>TextField</classname> is also used in
                several components that contain a text input field, even if the text input
                is not an actual <classname>TextField</classname>. This ensures that the
                style of different text input boxes is similar.
            </para>
        </section>

        <indexterm startref="term.components.textfield" class="endofrange"/>
	</section>

	<section xml:id="components.textarea">
		<title><classname>TextArea</classname></title>

		<para>
			<classname>TextArea</classname> is a multi-line version of the
			<classname>TextField</classname> component described in <xref
			linkend="components.textfield"/>.
		</para>

		<para>
			The following example creates a simple text area:
		</para>

        <book-example id="component.textarea.basic" style="float: right"></book-example>

<programlisting><?pocket-size 65% ?><![CDATA[// Create the area
TextArea area = new TextArea("Big Area");
        
// Put some content in it
area.setValue("A row\n"+
              "Another row\n"+
              "Yet another row");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.textarea"/>.
        </para>

		<figure xml:id="figure.components.textarea">
			<title><classname>TextArea</classname> Example</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/textarea-basic.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            You can set the number of visible rows with <methodname>setRows()</methodname>
            or use the regular <methodname>setHeight()</methodname> to define the height
            in other units. If the actual number of rows exceeds the number, a vertical
            scrollbar will appear. Setting the height with
            <methodname>setRows()</methodname> leaves space for a horizontal scrollbar, so
            the actual number of visible rows may be one higher if the scrollbar is not
            visible.
        </para>

        <para>
            You can set the width with the regular <methodname>setWidth()</methodname>
            method. Setting the size with the <emphasis>em</emphasis> unit, which is
            relative to the used font size, is recommended.
        </para>

        <simplesect xml:id="components.textarea.wordwrap">
            <title>Word Wrap</title>

            <para>
                The <methodname>setWordwrap()</methodname> sets whether long lines are
                wrapped (<literal>true</literal> - default) when the line length reaches
                the width of the writing area. If the word wrap is disabled
                (<literal>false</literal>), a vertical scrollbar will appear instead. The
                word wrap is only a visual feature and wrapping a long line does not
                insert line break characters in the field value; shortening a wrapped line
                will undo the wrapping.
            </para>
            
            <book-example id="component.textarea.wordwrap" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[TextArea area1 = new TextArea("Wrapping");
area1.setWordwrap(true); // The default
area1.setValue("A quick brown fox jumps over the lazy dog");

TextArea area2 = new TextArea("Nonwrapping");
area2.setWordwrap(false);
area2.setValue("Victor jagt zw&ouml;lf Boxk&auml;mpfer quer "+
               "&uuml;ber den Sylter Deich");]]></programlisting>

            <para>
                The result is shown in <xref linkend="figure.components.textarea.wordwrap"/>.
            </para>

            <figure xml:id="figure.components.textarea.wordwrap">
                <title>Word Wrap in <classname>TextArea</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/textarea-wordwrap.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </simplesect>

        <simplesect xml:id="components.textarea.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textarea { }]]></programlisting>

            <para>
                The HTML structure of <classname>TextArea</classname> is extremely simple,
                consisting only of an element with <literal>v-textarea</literal> style.
            </para>

            <book-example id="component.textarea.css">CSS Styling</book-example>
        </simplesect>
	</section>

	<section xml:id="components.passwordfield">
		<title><classname>PasswordField</classname></title>

        <para>
            The <classname>PasswordField</classname> is a variant of
            <classname>TextField</classname> that hides the typed input from visual
            inspection.
        </para>

        <book-example id="component.passwordfield.basic" style="float: right"></book-example>

        <programlisting><?pocket-size 65% ?><![CDATA[PasswordField tf = new PasswordField("Keep it secret");]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.passwordfield.basic"/>.
        </para>

        <figure xml:id="figure.components.passwordfield.basic">
            <title><classname>PasswordField</classname></title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata smallscale="100%" align="center" fileref="img/components/passwordfield-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            You should note that the <classname>PasswordField</classname> hides the input
            only from "over the shoulder" visual observation. Unless the server connection
            is encrypted with a secure connection, such as HTTPS, the input is transmitted
            in clear text and may be intercepted by anyone with low-level access to the
            network. Also phishing attacks that intercept the input in the browser may be
            possible by exploiting JavaScript execution security holes in the browser.
        </para>

        <simplesect xml:id="components.passwordfield.css">
            <title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-textfield { }]]></programlisting>

            <para>
                The <classname>PasswordField</classname> does not have its own CSS style
                name but uses the same <literal>v-textfield</literal> style as the regular
                <classname>TextField</classname>. See <xref
                linkend="components.textfield.css"/> for information on styling it.
            </para>

            <book-example id="component.passwordfield.css">CSS Styling</book-example>
        </simplesect>
    </section>

	<section xml:id="components.richtextarea">
		<title><classname>RichTextArea</classname></title>

		<para>
			The <classname>RichTextArea</classname> field allows entering or editing
			formatted text. The toolbar provides all basic editing functionalities. The
			text content of <classname>RichTextArea</classname> is represented in HTML
			format. <classname>RichTextArea</classname> inherits
			<classname>TextField</classname> and does not add any API functionality over
			it. You can add new functionality by extending the client-side components
			<classname>VRichTextArea</classname> and
			<classname>VRichTextToolbar</classname>.
		</para>

		<para>
			As with <classname>TextField</classname>, the textual content of the rich text
			area is the <classname>Property</classname> of the field and can be set with
			<methodname>setValue()</methodname> and read with
			<methodname>getValue()</methodname>.
		</para>

		<programlisting><![CDATA[// Create a rich text area
final RichTextArea rtarea = new RichTextArea();
rtarea.setCaption("My Rich Text Area");

// Set initial content as HTML
rtarea.setValue("<h1>Hello</h1>\n" +
    "<p>This rich text area contains some text.</p>");]]></programlisting>
			
		<figure>
			<title>Rich Text Area Component</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="130" align="center" fileref="img/components/richtextarea-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Above, we used context-specific tags such as <literal>&lt;h1&gt;</literal> in
			the initial HTML content. The rich text area component does not allow creating
			such tags, only formatting tags, but it does preserve them unless the user
			edits them away. Any non-visible whitespace such as the new line character
			(<literal>\n</literal>) are removed from the content. For example, the value
			set above will be as follows when read from the field with
			<methodname>getValue()</methodname>:
		</para>
		
		<programlisting><![CDATA[<h1>Hello</h1> <p>This rich text area contains some text.</p>]]></programlisting>

		<para>
			The rich text area is one of the few components in Vaadin that contain textual
			labels. The selection boxes in the toolbar are in English and currently can
			not be localized in any other way than by inheriting or reimplementing the
			client-side <classname>VRichTextToolbar</classname> widget. The buttons can be
			localized simply with CSS by downloading a copy of the toolbar background
			image, editing it, and replacing the default toolbar. The toolbar is a single
			image file from which the individual button icons are picked, so the order of
			the icons is different from the rendered. The image file depends on the
			client-side implementation of the toolbar.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[
.v-richtextarea-richtextexample .gwt-ToggleButton
.gwt-Image {
  background-image: url(img/richtextarea-toolbar-fi.png)
                    !important;
}]]></programlisting>

		<figure>
			<title>Regular English and a Localized Rich Text Area Toolbar</title>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="img/components/richtextarea-toolbar-whitebg.png"/>
				</imageobject>
			</mediaobject>
			<mediaobject>
				<imageobject>
					<imagedata align="center" fileref="img/components/richtextarea-toolbar-mod-whitebg.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<simplesect>
			<title>Cross-Site Scripting with <classname>RichTextArea</classname></title>

			<para>
				The user input from a <classname>RichTextArea</classname> is transmitted
				as XHTML from the browser to server-side and is not sanitized. As the
				entire purpose of the <classname>RichTextArea</classname> component is to
				allow input of formatted text, you can not sanitize it just by removing
				all HTML tags. Also many attributes, such as <parameter>style</parameter>,
				should pass through the sanitization.
			</para>

			<para>
				See <xref linkend="advanced.security.sanitizing"/> for more details on
				Cross-Site scripting vulnerabilities and sanitization of user input.
			</para>
		</simplesect>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-richtextarea { }
.v-richtextarea .gwt-RichTextToolbar { }
.v-richtextarea .gwt-RichTextArea { }]]></programlisting>

			<para>
				The rich text area consists of two main parts: the toolbar with overall
				style <literal>.gwt-RichTextToolbar</literal> and the editor area with
				style <literal>.gwt-RichTextArea</literal>. The editor area obviously
				contains all the elements and their styles that the HTML content
				contains. The toolbar contains buttons and drop-down list boxes with the
				following respective style names:
			</para>

			<programlisting><![CDATA[.gwt-ToggleButton { }
.gwt-ListBox { }]]></programlisting>

		</simplesect>
		
	</section>

	<section xml:id="components.datefield">
		<title>Date and Time Input with <classname>DateField</classname></title>
		<para>
			The <classname>DateField</classname> component provides the means to display
			and input date and time. The field comes in two variations:
			<classname>PopupDateField</classname>, with a numeric input box and a popup
			calendar view, and <classname>InlineDateField</classname>, with the calendar
			view always visible. The <classname>DateField</classname> base class defaults
			to the popup variation.
		</para>

        <para>
            The example below illustrates the use of the <classname>DateField</classname>
            baseclass, which is equivalent to the
            <classname>PopupDateField</classname>. We set the initial time of the date
            field to current time by using the default constructor of the
            <classname>java.util.Date</classname> class.
        </para>

        <programlisting><![CDATA[// Create a DateField with the default style
DateField date = new DateField();
	
// Set the date and time to present
date.setValue(new Date());]]></programlisting>

        <para>
            The result is shown in <xref linkend="figure.components.datefield.basic"/>.
        </para>

		<figure xml:id="figure.components.datefield.basic">
			<title><classname>DateField</classname> (<classname>PopupDateField</classname>) for Selecting Date and Time</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata smallscale="100%" align="center" fileref="img/components/datefield-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <section xml:id="components.datefield.popupdatefield">
            <title><classname>PopupDateField</classname></title>

            <para>
                The <classname>PopupDateField</classname> provides date input using a text
                box for the date and time. As the <classname>DateField</classname>
                defaults to this component, the use is exactly the same as described
                earlier. Clicking the handle right of the date opens a popup view for
                selecting the year, month, and day, as well as time. Also the
                <keycap>Down</keycap> key opens the popup. Once opened, the user can
                navigate the calendar using the cursor keys.
            </para>

            <para>
                The date and time selected from the popup are displayed in the text box
                according to the default date and time format of the current locale, or as
                specified with <methodname>setDateFormat()</methodname>. The same format
                definitions are used for parsing user input.
            </para>

            <simplesect xml:id="components.datefield.popupdatefield.format">
                <title>Date and Time Format</title>

                <para>
                    The date and time are normally displayed according to the default
                    format for the current locale (see <xref
                    linkend="components.features.locale"/>). You can specify a custom
                    format with <methodname>setDateFormat()</methodname>. It takes a
                    format string that follows the format of the
                    <classname>SimpleDateFormat</classname> in Java.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[// Display only year, month, and day in ISO format
date.setDateFormat("yyyy-MM-dd");]]></programlisting>

                <para>
                    The result is shown in <xref
                    linkend="figure.components.datefield.popupdatefield.format"/>.
                </para>

                <figure xml:id="figure.components.datefield.popupdatefield.format">
                    <title>Custom Date Format for
                    <classname>PopupDateField</classname></title>
                    <mediaobject>
                        <imageobject role="html">
                            <imagedata align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                        <imageobject role="fo">
                            <imagedata smallscale="75%" align="center" fileref="img/components/datefield-formatting.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    The same format specification is also used for parsing user-input date
                    and time, as described later. 
                </para>
            </simplesect>

            <simplesect>
                <title>Handling Malformed User Input</title>

                <para>
                    A user can easily input a malformed or otherwise invalid date or
                    time. <classname>DateField</classname> has two validation layers:
                    first on the client-side and then on the server-side.
                </para>

                <para>
                    The validity of the entered date is first validated on the
                    client-side, immediately when the input box loses focus. If the date
                    format is invalid, the <literal>v-datefield-parseerror</literal> style
                    is set. Whether this causes a visible indication of a problem depends
                    on the theme. The built-in <literal>reindeer</literal> theme does not
                    shown any indication by default, making server-side handling of the
                    problem more convenient.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[.mydate.v-datefield-parseerror .v-textfield {
    background: pink;
}]]></programlisting>

                <para>
                    The <methodname>setLenient(true)</methodname> setting enables relaxed
                    interpretation of dates, so that invalid dates, such as February 30th
                    or March 0th, are wrapped to the next or previous month, for example.
                </para>

                <para>
                    The server-side validation phase occurs when the date value is sent to
                    the server. If the date field is set in immediate state, it occurs
                    immediately after the field loses focus. Once this is done and if the
                    status is still invalid, an error indicator is displayed beside the
                    component. Hovering the mouse pointer over the indicator shows the
                    error message.
                </para>

                <para>
                    You can handle the errors by overriding the
                    <methodname>handleUnparsableDateString()</methodname> method. The
                    method gets the user input as a string parameter and can provide a
                    custom parsing mechanism, as shown in the following example.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom parsing and a
// custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Try custom parsing
        String fields[] = dateString.split("/");
        if (fields.length >= 3) {
            try {
                int year  = Integer.parseInt(fields[0]);
                int month = Integer.parseInt(fields[1])-1;
                int day   = Integer.parseInt(fields[2]);
                GregorianCalendar c =
                    new GregorianCalendar(year, month, day);
                return c.getTime();
            } catch (NumberFormatException e) {
                throw new Property.
                    ConversionException("Not a number");
            }
        }
        
        // Bad date
        throw new Property.
            ConversionException("Your date needs two slashes");
    }
};
        
// Display only year, month, and day in slash-delimited format
date.setDateFormat("yyyy/MM/dd");

// Don't be too tight about the validity of dates
// on the client-side
date.setLenient(true);]]></programlisting>

                <para>
                    The handler method must either return a parsed
                    <classname>Date</classname> object or throw a
                    <classname>ConversionException</classname>. Returning
                    <parameter>null</parameter> will set the field value to
                    <parameter>null</parameter> and clear the input box.
                </para>
            </simplesect>

            <simplesect>
                <title>Customizing the Error Message</title>

                <para>
                    In addition to customized parsing, overriding the handler method for
                    unparseable input is useful for internationalization and other
                    customization of the error message. You can also use it for another
                    way for reporting the errors, as is done in the example below:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a date field with a custom error message for invalid format
PopupDateField date = new PopupDateField("My Date") {
    @Override
    protected Date handleUnparsableDateString(String dateString)
    throws Property.ConversionException {
        // Have a notification for the error
        Notification.show(
                "Your date needs two slashes",
                Notification.TYPE_WARNING_MESSAGE);
        
        // A failure must always also throw an exception
        throw new Property.ConversionException("Bad date");
    }
};]]></programlisting>

                <para>
                    If the input is invalid, you should always throw the exception;
                    returning a <parameter>null</parameter> value would make the input
                    field empty, which is probably undesired.
                </para>
            </simplesect>

            <simplesect>
                <title>Input Prompt</title>

                <para>
                    Like other fields that have a text box,
                    <classname>PopupDateField</classname> allows an input prompt that is
                    visible until the user has input a value. You can set the prompt with
                    <methodname>setInputPrompt</methodname>.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[PopupDateField date = new PopupDateField();

// Set the prompt
date.setInputPrompt("Select a date");
        
// Set width explicitly to accommodate the prompt
date.setWidth("10em");]]></programlisting>

                <para>
                    The date field doesn't automatically scale to accommodate the prompt,
                    so you need to set it explicitly with
                    <methodname>setWidth()</methodname>.
                </para>

                <para>
                    The input prompt is not available in the
                    <classname>DateField</classname> superclass.
                </para>
            </simplesect>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield, v-datefield-popupcalendar {}
  .v-textfield, v-datefield-textfield {}
  .v-datefield-button {}]]></programlisting>

                <para>
                    The top-level element of <classname>DateField</classname> and all its
                    variants have <literal>v-datefield</literal> style. The base class and
                    the <classname>PopupDateField</classname> also have the
                    <literal>v-datefield-popupcalendar</literal> style.
                </para>
                
                <para>
                    In addition, the top-level element has a style that indicates the
                    resolution, with <literal>v-datefield-</literal> basename and an
                    extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day. These styles are used
                    mainly for controlling the appearance of the popup calendar.
                </para>

                <para>
                    The text box has <literal>v-textfield</literal> and
                    <literal>v-datefield-textfield</literal> styles, and the calendar
                    button <literal>v-datefield-button</literal>.
                </para>

                <para>
                    Once opened, the calendar popup has the following styles at the top
                    level:
                </para>

                <programlisting><![CDATA[.v-datefield-popup {}
  .v-popupcontent {}
    .v-datefield-calendarpanel {}]]></programlisting>

                <para>
                    The top-level element of the floating popup calendar has
                    <literal>.v-datefield-popup</literal> style. Observe that the popup
                    frame is outside the HTML structure of the component, hence it is not
                    enclosed in the <literal>v-datefield</literal> element and does not
                    include any custom styles.

                    <!-- NOTE: May be changed in #5752. -->

                    The content in the <literal>v-datefield-calendarpanel</literal> is the
                    same as in <classname>InlineDateField</classname>, as described in
                    <xref linkend="components.datefield.calendar"/>.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.datefield.calendar">
			<title><classname>InlineDateField</classname></title>

			<para>
				The <classname>InlineDateField</classname> provides a date picker
				component with a month view. The user can navigate months and years by
				clicking the appropriate arrows. Unlike with the popup variant, the month
				view is always visible in the inline field.
			</para>

            <programlisting><?pocket-size 75% ?><![CDATA[// Create a DateField with the default style
InlineDateField date = new InlineDateField();
    
// Set the date and time to present
date.setValue(new java.util.Date());]]></programlisting>

            <para>
                The result is shown in <xref
                linkend="figure.components.datefield.inlinedatefield"/>.
            </para>

            <figure xml:id="figure.components.datefield.inlinedatefield">
                <title>Example of the <classname>InlineDateField</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="150" align="center" fileref="img/components/datefield-inlinedatefield.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The user can also navigate the calendar using the cursor keys.
            </para>

            <simplesect>
                <title>CSS Style Rules</title>

                <programlisting><![CDATA[.v-datefield {}
  .v-datefield-calendarpanel {}
    .v-datefield-calendarpanel-header {}
      .v-datefield-calendarpanel-prevyear {}
      .v-datefield-calendarpanel-prevmonth {}
      .v-datefield-calendarpanel-month {}
      .v-datefield-calendarpanel-nextmonth {}
      .v-datefield-calendarpanel-nextyear {}
    .v-datefield-calendarpanel-body {}
      .v-datefield-calendarpanel-weekdays,
      .v-datefield-calendarpanel-weeknumbers {}
        .v-first {}
        .v-last {}
      .v-datefield-calendarpanel-weeknumber {}
      .v-datefield-calendarpanel-day {}
    .v-datefield-calendarpanel-time {}
      .v-datefield-time {}
        .v-select {}
        .v-label {}]]></programlisting>

                <para>
                    The top-level element has the <literal>v-datefield</literal> style. In
                    addition, the top-level element has a style name that indicates the
                    resolution of the calendar, with <literal>v-datefield-</literal>
                    basename and an extension, which is one of <literal>full</literal>,
                    <literal>day</literal>, <literal>month</literal>, or
                    <literal>year</literal>. The <literal>-full</literal> style is enabled
                    when the resolution is smaller than a day.
                </para>

                <para>
                    The <literal>v-datefield-calendarpanel-weeknumbers</literal> and
                    <literal>v-datefield-calendarpanel-weeknumber</literal> styles are
                    enabled when the week numbers are enabled. The former controls the
                    appearance of the weekday header and the latter the actual week
                    numbers.
                </para>

                <para>
                    The other style names should be self-explanatory. For weekdays, the
                    <literal>v-first</literal> and <literal>v-last</literal> styles allow
                    making rounded endings for the weekday bar.
                </para>
            </simplesect>
		</section>

		<section>
            <title>Time Resolution</title>

            <para>
                The <classname>DateField</classname> displays dates by default. It can
                also display the time in hours and minutes, or just the month or year. The
                visibility of the input components is controlled by <emphasis>time
                resolution</emphasis>, which can be set with
                <methodname>setResolution()</methodname> method. The method takes as its
                parameters the lowest visible component, typically
                <parameter>RESOLUTION_DAY</parameter> for just dates and
                <parameter>RESOLUTION_MIN</parameter> for dates with time in hours and
                minutes. Please see the API Reference for the complete list of resolution
                parameters.
            </para>
        </section>

		<section>
			<title>DateField Locale</title>

			<para>
				The date and time are displayed according to the locale of the user, as
				reported by the browser. You can set a custom locale with the
				<methodname>setLocale()</methodname> method of
				<classname>AbstractComponent</classname>, as described in <xref
				linkend="components.features.locale"/>. Only Gregorian calendar is
				supported.
			</para>
		</section>
	</section>

	<section xml:id="components.button">
		<title><classname>Button</classname></title>

		<para>
			The <classname>Button</classname> is a user interface component that is
			normally used for finalizing input and initiating some action. When the user
			clicks a button, a <classname>Button.ClickEvent</classname> is emitted. A
			listener that inherits the <classname>Button.ClickListener</classname>
			interface can handle clicks with the <methodname>buttonClick()</methodname>
			method.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[public class TheButton extends CustomComponent
                       implements Button.ClickListener {
    Button thebutton;

    public TheButton() {
        // Create a Button with the given caption.
        thebutton = new Button ("Do not push this button");
        
        // Listen for ClickEvents.
        thebutton.addListener(this);

        setCompositionRoot(thebutton);
    }
    
    /** Handle click events for the button. */
    public void buttonClick (Button.ClickEvent event) {
        thebutton.setCaption ("Do not push this button again");
    }
}]]></programlisting>

		<figure>
			<title>An Example of a Button</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="150" align="center" fileref="img/components/button-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			As a user interface often has several buttons, you can differentiate
			between them either by comparing the <classname>Button</classname>
			object reference returned by the <methodname>getButton()</methodname>
			method of <classname>Button.ClickEvent</classname> to a kept
			reference or by using a separate listener method for each button. The
			listening object and method can be given to the constructor. For a
			detailed description of these patterns together with some examples,
			please see <xref linkend="architecture.events"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>

			<programlisting><![CDATA[.v-button { }]]></programlisting>

			<para>
				The exact CSS style name can be different if a <classname>Button</classname>
				has the <parameter>switchMode</parameter> attribute enabled. See the
				alternative CSS styles below.
			</para>

            <para>
                Adding the "<literal>small</literal>" style name enables a smaller style
                for the <classname>Button</classname>. You can also use the
                <parameter>BUTTON_SMALL</parameter> constant in
                <classname>Runo</classname> and <classname>Reindeer</classname> theme
                classes as well. The <classname>BaseTheme</classname> class also has a
                <parameter>BUTTON_LINK</parameter> style, with "<literal>link</literal>"
                style name, which makes the button look like a hyperlink.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.checkbox">
		<title><classname>CheckBox</classname></title>

		<para>
			<classname>CheckBox</classname> is a two-state selection component that can be
			either checked or unchecked. The caption of the check box will be placed right
			of the actual check box. Vaadin provides two ways to create check boxes:
			individual check boxes with the <classname>CheckBox</classname> component
			described in this section and check box groups with the
			<classname>OptionGroup</classname> component in multiple selection mode, as
			described in <xref linkend="components.selecting.optiongroup"/>.
		</para>

		<para>
			Clicking on a check box will change its state. The state is a
			<classname>Boolean</classname> property that you can set with the
			<methodname>setValue()</methodname> method and obtain with the
			<methodname>getValue()</methodname> method of the
			<classname>Property</classname> interface.  Changing the value of a check box
			will cause a <classname>ValueChangeEvent</classname>, which can be handled by
			a <classname>ValueChangeListener</classname>.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// A check box with default state (not checked, false).
final CheckBox checkbox1 = new CheckBox("My CheckBox");
main.addComponent(checkbox1);

// Another check box with explicitly set checked state.
final CheckBox checkbox2 = new CheckBox("Checked CheckBox");
checkbox2.setValue(true);
main.addComponent(checkbox2);

// Make some application logic. We use anonymous listener
// classes here. The above references were defined as final
// to allow accessing them from inside anonymous classes.
checkbox1.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Copy the value to the other checkbox.
        checkbox2.setValue(checkbox1.getValue());
    }
});
checkbox2.addListener(new ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        // Copy the value to the other checkbox.
        checkbox1.setValue(checkbox2.getValue());
    }
});]]></programlisting>

		<figure>
			<title>An Example of a Check Box</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="150" align="center" fileref="img/components/checkbox-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			For an example on the use of check boxes in a table, see <xref
			linkend="components.table"/>.
		</para>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-checkbox { }
  .v-checkbox > input { }
  .v-checkbox > label { }]]></programlisting>

            <para>
                The top-level element of a <classname>CheckBox</classname> has the
                <literal>v-checkbox</literal> style. It contains two sub-elements: the
                actual check box <literal>input</literal> element and the
                <literal>label</literal> element. If you want to have the label on the
                left, you can change the positions with "<literal>direction:
                rtl</literal>" for the top element.
            </para>
		</simplesect>
	</section>

	<section xml:id="components.selecting">
		<title>Selecting Items</title>

		<para>
			Vaadin gives many alternatives for selecting one or more items from a list,
			using drop-down and regular lists, radio button and check box groups, tables,
			trees, and so on.
		</para>

		<para>
			The core library includes the following selection components, all based on the
			<classname>AbstractSelect</classname> class:
		</para>

        <variablelist>
            <varlistentry>
                <term><classname>Select</classname></term>
                <listitem>
                    In single selection mode, a drop-down list with a text input area,
                    which the user can use to filter the displayed items. In multiselect
                    mode, a list box equivalent to <classname>ListSelect</classname>.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ComboBox</classname></term>
                <listitem>
                    A drop-down list for single selection. Otherwise as
                    <classname>Select</classname>, but the user can also enter new
                    items. The component also provides an input prompt.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>ListSelect</classname></term>
                <listitem>
                    A vertical list box for selecting items in either single or multiple
                    selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>NativeSelect</classname></term>
                <listitem>
                    Provides selection using the native selection component of the
                    browser, typically a drop-down list for single selection and a
                    multi-line list in multiselect mode. This uses the
                    <literal>&lt;select&gt;</literal> element in HTML.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>OptionGroup</classname></term>
                <listitem>
                    Shows the items as a vertically arranged group of radio buttons in the
                    single selection mode and of check boxes in multiple selection mode.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><classname>TwinColSelect</classname></term>
                <listitem>
                    Shows two list boxes side by side where the user can select items from
                    a list of available items and move them to a list of selected items
                    using control buttons.
                </listitem>
            </varlistentry>
        </variablelist>

		<para>
			In addition, the <classname>Tree</classname> and <classname>Table</classname>
			components allow special forms of selection. They also inherit the
			<classname>AbstractSelect</classname>.
		</para>

        <section xml:id="components.selecting.databinding">
            <title>Binding Selection Components to Data</title>

            <para>
                The selection components are strongly coupled with the Vaadin Data
                Model. The selectable items in all selection components are objects that
                implement the <classname>Item</classname> interface and are contained in a
                <classname>Container</classname>. The current selection is bound to the
                <classname>Property</classname> interface.
            </para>

            <para>
                Even though the data model is used, the selection components allow simple
                use in the most common cases. Each selection component is bound to a
                default container type, which supports management of items without need to
                implement a container.
            </para>

            <para>
                See <xref linkend="datamodel"/> for a detailed description of the data
                model, its interfaces, and built-in implementations.
            </para>

            <section xml:id="components.selecting.databinding.adding">
                <title>Adding New Items</title>
            
                <para>
                    New items are added with the <methodname>addItem()</methodname> method
                    defined in the <classname>Container</classname> interface.
                </para>

                <programlisting><![CDATA[// Create a selection component
Select select = new Select ("Select something here");

// Add some items and give each an item ID
select.addItem("Mercury");
select.addItem("Venus");
select.addItem("Earth");]]></programlisting>

                <para>
                    The <methodname>addItem()</methodname> method creates an empty
                    <classname>Item</classname>, which is identified by its <emphasis>item
                    identifier</emphasis> (IID) object, given as the parameter. This item ID
                    is by default used also as the caption of the item, as explained in
                    the next section. The identifier is typically a
                    <classname>String</classname>. The item is of a type specific to the
                    container and has itself little relevance for most selection
                    components, as the properties of an item may not be used in any way
                    (except in <classname>Table</classname>), only the item ID.
                </para>

                <para>
                    The item identifier can be of any object type. We could as well have
                    given integers for the item identifiers and set the captions
                    explicitly with <methodname>setItemCaption()</methodname>. You could
                    also add an item with the parameterless
                    <methodname>addItem()</methodname>, which returns an automatically
                    generated item ID.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Create a selection component
Select select = new Select("My Select");
        
// Add an item with a generated ID
Object itemId = select.addItem();
select.setItemCaption(itemId, "The Sun");
        
// Select the item
select.setValue(itemId);]]></programlisting>

                <para>
                    Some container types may support passing the actual data object to the
                    add method. For example, you can add items to a
                    <classname>BeanItemContainer</classname> with
                    <methodname>addBean()</methodname>. Such implementations can use a
                    separate item ID object, or the data object itself as the item ID, as
                    is done in <methodname>addBean()</methodname>. In the latter case you
                    can not depend on the default way of acquiring the item caption; see
                    the description of the different caption modes later.
                </para>

                <para>
                    The following section describes the different options for determining
                    the item captions.
                </para>
            </section>

            <section xml:id="components.selecting.databinding.captions">
                <title>Item Captions</title>

                <para>
                    The displayed captions of items in a selection component can be set
                    explicitly with <methodname>setItemCaption()</methodname> or
                    determined from the item IDs or item properties. This behaviour is
                    defined with the <emphasis>caption mode</emphasis>, which you can set
                    with <methodname>setItemCaptionMode()</methodname>. The default mode
                    is <parameter>ITEM_CAPTION_MODE_EXPLICIT_DEFAULTS_ID</parameter>,
                    which uses the item identifiers for the captions, unless given
                    explicitly.
                </para>

                <para>
                    In addition to a caption, an item can have an icon. The icon is set
                    with <methodname>setItemIcon()</methodname>.
                </para>

                <variablelist>
                    <title>Caption Modes for Selection Components</title>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_EXPLICIT_DEFAULTS_ID</constant></term>
                        <listitem>
                            <para>
                                This is the default caption mode and its flexibility
                                allows using it in most cases. By default, the item
                                identifier will be used as the caption. The identifier
                                object does not necessarily have to be a string; the
                                caption is retrieved with
                                <methodname>toString()</methodname> method. If the caption
                                is specified explicitly with
                                <methodname>setItemCaption()</methodname>, it overrides
                                the item identifier.
                            </para>

                            <programlisting><?pocket-size 65% ?><![CDATA[Select select = new Select("Moons of Mars");
        
// Use the item ID also as the caption of this item
select.addItem(new Integer(1));
        
// Set item caption for this item explicitly
select.addItem(2); // same as "new Integer(2)"
select.setItemCaption(2, "Deimos");]]></programlisting>

                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_EXPLICIT</constant></term>
                        <listitem>
                            <para>
                                Captions must be explicitly specified with
                                <methodname>setItemCaption()</methodname>. If they are
                                not, the caption will be empty. Such items with empty
                                captions will nevertheless be displayed in the
                                <classname>Select</classname> component as empty items. If
                                they have an icon, they will be visible.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ICON_ONLY</constant></term>
                        <listitem>
                            <para>
                                Only icons are shown, captions are hidden.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ID</constant></term>
                        <listitem>
                            <para>
                                String representation of the item identifier object is
                                used as caption. This is useful when the identifier is a
                                string, and also when the identifier is an complex object
                                that has a string representation. For example:
                            </para>
                            
                            <programlisting><?pocket-size 70% ?><![CDATA[Select select = new Select("Inner Planets");
select.setItemCaptionMode(Select.ITEM_CAPTION_MODE_ID);
        
// A class that implements toString()
class PlanetId extends Object implements Serializable {
    String planetName;
    PlanetId (String name) {
        planetName = name;
    }
    public String toString () {
        return "The Planet " + planetName;
    }
}

// Use such objects as item identifiers
String planets[] = {"Mercury", "Venus", "Earth", "Mars"};
for (int i=0; i<planets.length; i++)
    select.addItem(new PlanetId(planets[i]));]]></programlisting>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_INDEX</constant></term>
                        <listitem>
                            <para>
                                Index number of item is used as caption. This caption mode is
                                applicable only to data sources that implement the
                                <classname>Container.Indexed</classname> interface. If the
                                interface is not available, the component will throw a
                                <classname>ClassCastException</classname>. The
                                <classname>Select</classname> component itself does not implement
                                this interface, so the mode is not usable without a separate data
                                source. An <classname>IndexedContainer</classname>, for example,
                                would work.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_ITEM</constant></term>
                        <listitem>
                            <para>
                                <classname>String</classname> representation of item, acquired
                                with <methodname>toString()</methodname>, is used as the
                                caption. This is applicable mainly when using a custom
                                <classname>Item</classname> class, which also requires using a
                                custom <classname>Container</classname> that is used as a data
                                source for the <classname>Select</classname> component.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><constant>ITEM_CAPTION_MODE_PROPERTY</constant></term>
                        <listitem>
                            <para>
                                Item captions are read from the <classname>String</classname>
                                representation of the property with the identifier specified with
                                <methodname>setItemCaptionPropertyId()</methodname>. This is
                                useful, for example, when you have a container that you use as the
                                data source for a <classname>Select</classname>, and you want to
                                use a specific property for caption.
                            </para>
                            
                            <para>
                                In the example below, we bind a selection component to a bean
                                container and use a property of the bean as the caption.
                            </para>
                            
                            <programlisting><?pocket-size 65% ?><![CDATA[/* A bean with a "name" property. */
public class Planet implements Serializable {
    String name;

    public Planet(String name) {
        this.name = name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }
}

void propertyModeExample() {
    VerticalLayout layout = new VerticalLayout();

    // Have a bean container to put the beans in
    BeanItemContainer<Planet> container =
        new BeanItemContainer<Planet>(Planet.class);

    // Put some example data in it
    container.addItem(new Planet("Mercury"));
    container.addItem(new Planet("Venus"));
    container.addItem(new Planet("Earth"));
    container.addItem(new Planet("Mars"));

    // Create a selection component bound to the container
    Select select = new Select("Planets", container);

    // Set the caption mode to read the caption directly
    // from the 'name' property of the bean
    select.setItemCaptionMode(
            Select.ITEM_CAPTION_MODE_PROPERTY);
    select.setItemCaptionPropertyId("name");

    layout.addComponent(select);]]></programlisting>

                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>


            <section>
                <title>Getting and Setting Selection</title>

                <para>
                    A selection component provides the current selection as the property of
                    the component (with the <classname>Property</classname> interface). The
                    property value is an item identifier object that identifies the selected
                    item. You can get the identifier with <methodname>getValue()</methodname>
                    of the <classname>Property</classname> interface.
                </para>

                <para>
                    You can select an item with the corresponding
                    <methodname>setValue()</methodname> method. In multiselect mode, the
                    property will be an unmodifiable set of item identifiers. If no item
                    is selected, the property will be <parameter>null</parameter> in
                    single selection mode or an empty collection in multiselect mode.
                </para>

                <para>
                    The <classname>Select</classname> and <classname>NativeSelect</classname>
                    components will show "-" selection when no actual item is selected. This is
                    the <emphasis>null selection item identifier</emphasis>. You can set an
                    alternative ID with <methodname>setNullSelectionItemId()</methodname>. Setting
                    the alternative null ID is merely a visual text; the
                    <methodname>getValue()</methodname> will still return
                    <parameter>null</parameter> value if no item is selected, or an empty set in
                    multiselect mode.
                </para>

                <para>
                    The item identifier of the currently selected item will be set as the
                    property of the <classname>Select</classname> object. You can
                    access it with the <methodname>getValue()</methodname> method of the
                    <classname>Property</classname> interface of the component. Also,
                    when handling changes in a <classname>Select</classname> component
                    with the <classname>Property.ValueChangeListener</classname>
                    interface, the <classname>Property.ValueChangeEvent</classname> will
                    have the selected item as the property of the event, accessible with the
                    <methodname>getProperty()</methodname> method.
                </para>

                <figure>
                    <title>Selected Item</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="150" align="center" fileref="img/components/select-selected1.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>
        </section>
		<!-- <para>
		While the default caption mode is flexible enough for most
		cases where the appearance of a <classname>Select</classname>
		component is fixed, the other modes may be useful for cases where the
		user can configure what type of information is shown in the
		component. Typical situation is allowing the user to choose between
		"Show text only", "Show icons only", and "Show both icons and text".
		</para>-->

		<section xml:id="components.selecting.select">
			<title>Basic <classname>Select</classname> Component</title>

			<para>
				The <classname>Select</classname> component allows, in single selection
				mode, selecting an item from a drop-down list. The component also has a
				text field area, which allows entering search text by which the items
				shown in the drop-down list are filtered.
			</para>

            <para>
                In multiple selection mode, the component shows the items in a vertical
                list box, identical to <classname>ListSelect</classname>.
            </para>

			<figure>
				<title>The Select Component</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="130" align="center" fileref="img/components/select-select.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<section>
				<title>Filtered Selection</title>
				
				<para>
					The <classname>Select</classname> component allows filtering the items
					available for selection. The component shows as an input box for
					entering text. The text entered in the input box is used for filtering
					the available items shown in a drop-down list. Pressing
					<keycap>Enter</keycap> will complete the item in the input
					box. Pressing <keycap>Up</keycap>- and <keycap>Down</keycap>-arrows
					can be used for selecting an item from the drop-down list. The
					drop-down list is paged and clicking on the scroll buttons will change
					to the next or previous page. The list selection can also be done with
					the arrow keys on the keyboard. The shown items are loaded from the
					server as needed, so the number of items held in the component can be
					quite large.
				</para>
			
				<para>
					Vaadin provides two filtering modes:
					<parameter>FILTERINGMODE_CONTAINS</parameter> matches any item that
					contains the string given in the text field part of the component and
					<parameter>FILTERINGMODE_STARTSWITH</parameter> matches only items
					that begin with the given string. The filtering mode is set with
					<methodname>setFilteringMode()</methodname>. Setting the filtering
					mode to the default value <parameter>FILTERINGMODE_OFF</parameter>
					disables filtering.
				</para>

                <programlisting><?pocket-size 65% ?><![CDATA[Select select = new Select("Enter containing substring");

select.setFilteringMode(AbstractSelect.Filtering.FILTERINGMODE_CONTAINS);

/* Fill the component with some items. */
final String[] planets = new String[] {
        "Mercury", "Venus", "Earth", "Mars",
        "Jupiter", "Saturn", "Uranus", "Neptune" };

for (int i = 0; i < planets.length; i++)
    for (int j = 0; j < planets.length; j++) {
        select.addItem(planets[j] + " to " + planets[i]);]]></programlisting>

				<para>
					The above example uses the containment filter that matches to all
					items containing the input string. As shown in <xref
					linkend="figure.select.filter"/> below, when we type some text in the
					input area, the drop-down list will show all the matching items.
				</para>

				<figure xml:id="figure.select.filter">
					<title>Filtered Selection</title>
					<mediaobject>
						<imageobject>
							<imagedata smallscale="100%" align="center" fileref="img/components/select-filter3.png"/>
						</imageobject>
					</mediaobject>
				</figure>
            </section>
					
            <simplesect>
                <title>CSS Style Rules</title>
                
                <programlisting><![CDATA[.v-filterselect { }
.v-filterselect-input { }
.v-filterselect-button { }
.v-filterselect-suggestpopup { }
.v-filterselect-prefpage-off { }
.v-filterselect-suggestmenu { }
.v-filterselect-status { }
.v-select { }
.v-select-select { }]]></programlisting>
					
                <para>
                    In its default state, only the input field of the
                    <classname>Select</classname> component is visible. The entire
                    component is enclosed in <literal>v-filterselect</literal> style, the
                    input field has <literal>v-filterselect-input</literal> style and the
                    button in the right end that opens and closes the drop-down result
                    list has <literal>v-filterselect-button</literal> style.
                </para>

                <para>
                    The drop-down result list has an overall
                    <literal>v-filterselect-suggestpopup</literal> style. It contains the
                    list of suggestions with <literal>v-filterselect-suggestmenu</literal>
                    style and a status bar in the bottom with
                    <literal>v-filterselect-status</literal> style. The list of
                    suggestions is padded with an area with
                    <literal>v-filterselect-prefpage-off</literal> style above and below
                    the list.
                </para>

                <para>
                    In multiselect-mode, the styles of the component aere identical to
                    <classname>ListSelect</classname> component, with
                    <literal>v-select</literal> overall style and
                    <literal>v-select-select</literal> for the native selection element.
                </para>
            </simplesect>
        </section>

		<section xml:id="components.selecting.listselect">
            <title><classname>ListSelect</classname></title>

            <para>
                The <classname>ListSelect</classname> component is list box that shows the
                selectable items in a vertical list. If the number of items exceeds the
                height of the component, a scrollbar is shown. The component allows both
                single and multiple selection modes, which you can set with
                <methodname>setMultiSelect()</methodname>. It is visually identical in
                both modes.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create the selection component
ListSelect select = new ListSelect("My Selection");
        
// Add some items
select.addItem("Mercury");
select.addItem("Venus");
select.addItem("Earth");
...

select.setNullSelectionAllowed(false);

// Show 5 items and a scrollbar if there are more
select.setRows(5);]]></programlisting>

            <para>
                The number of visible items is set with
                <methodname>setRows()</methodname>.
            </para>

            <figure xml:id="figure.selecting.listselect.basic">
                <title>The <classname>ListSelect</classname> Component</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="80%" align="center" fileref="img/components/listselect-basic.png"/>
                    </imageobject>
                </mediaobject>
            </figure>


			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select {}
.v-select-select {}]]></programlisting>

				<para>
					The component has a <literal>v-select</literal> overall style. The
					native <literal>select</literal> element has
					<literal>v-select-select</literal> style.
				</para>
			</simplesect>
        </section>

		<section xml:id="components.selecting.nativeselect">
			<title>Native Selection Component <classname>NativeSelect</classname></title>
			
			<para>
				<classname>NativeSelect</classname> offers the native selection component
				of web browsers, using the HTML <literal>&lt;select&gt;</literal>
				element. The component is shown as a drop-down list.
			</para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create the selection component
final NativeSelect select = new NativeSelect("Native Selection");
        
// Add some items
select.addItem("Mercury");
select.addItem("Venus");
...
        
// Set the width in "columns" as in TextField
select.setColumns(10);
        
select.setNullSelectionAllowed(false);]]></programlisting>

            <para>
                The <methodname>setColumns()</methodname> allows setting the width of the
                list as "columns", which is a measure that depends on the browser.
            </para>

            <figure xml:id="figure.selecting.nativeselect.basic">
                <title>The <classname>NativeSelect</classname> Component</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="80%" align="center" fileref="img/components/nativeselect-basic.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                Multiple selection mode is not allowed; you should use the
                <classname>ListSelect</classname> component instead. Also adding new
                items, which would be enabled with
                <methodname>setNewItemsAllowed()</methodname>, is not allowed.
            </para>

			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select {}
.v-select-select {}]]></programlisting>

				<para>
					The component has a <literal>v-select</literal> overall style. The
					native <literal>select</literal> element has
					<literal>v-select-select</literal> style.
				</para>
			</simplesect>
		</section>

		<section xml:id="components.selecting.optiongroup">
			<title>Radio Button and Check Box Groups with <classname>OptionGroup</classname></title>
			<para>
				The <classname>OptionGroup</classname> class provides selection from
				alternatives using a group of radio buttons in single selection mode. In
				multiple selection mode, the items show up as check boxes.
			</para>

			<programlisting><?pocket-size 70% ?><![CDATA[OptionGroup optiongroup = new OptionGroup("My Option Group");

// Use the multiple selection mode.
myselect.setMultiSelect(true);]]></programlisting>

            <para>
                <xref linkend="figure.components.selecting.optiongroup"/> shows the
                <classname>OptionGroup</classname> in both single and multiple selection mode.
            </para>

			<figure xml:id="figure.components.selecting.optiongroup">
				<title>Option Button Group in Single and Multiple Selection Mode</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="130" align="center" fileref="img/components/select-optiongroup.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				You can create check boxes individually using the
				<classname>CheckBox</classname> class, as described in <xref
				linkend="components.checkbox"/>. The advantages of the
				<classname>OptionGroup</classname> component are that as it maintains the
				individual check box objects, you can get an array of the currently
				selected items easily, and that you can easily change the appearance of a
				single component.
			</para>

            <section>
                <title>Disabling Items</title>

                <para>
                    You can disable individual items in an
                    <classname>OptionGroup</classname> with
                    <methodname>setItemEnabled()</methodname>. The user can not select or
                    deselect disabled items in multi-select mode, but in single-select
                    mode the use can change the selection from a disabled to an enabled
                    item. The selections can be changed programmatically regardless of
                    whether an item is enabled or disabled. You can find out whether an
                    item is enabled with <methodname>isItemEnabled()</methodname>.
                </para>

                <para>
                    The <methodname>setItemEnabled()</methodname> identifies the item to
                    be disabled by its item ID.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have an option group
OptionGroup group = new OptionGroup("My Disabled Group");
group.addItem("One");
group.addItem("Two");
group.addItem("Three");

// Disable one item
group.setItemEnabled("Two", false);]]></programlisting>

                <para>
                    The item IDs are also used for the captions in this example. The
                    result is shown in <xref
                    linkend="figure.components.selecting.optiongroup.disabling"/>.
                </para>

                <figure xml:id="figure.components.selecting.optiongroup.disabling">
                    <title><classname>OptionGroup</classname> with a Disabled Item</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/components/optiongroup-disabling.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    Setting an item as disabled turns on the <literal>v-disabled</literal>
                    style for it.
                </para>
            </section>

			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select-optiongroup {}
.v-select-option.v-checkbox {}
.v-select-option.v-radiobutton {}]]></programlisting>

				<para>
					The <literal>v-select-optiongroup</literal> is the overall style for
					the component. Each check box will have the
					<literal>v-checkbox</literal> style, borrowed from the
					<classname>CheckBox</classname> component, and each radio button the
					<literal>v-radiobutton</literal> style. Both the radio buttons and
					check boxes will also have the <literal>v-select-option</literal>
					style that allows styling regardless of the option type. Disabled
					items have additionally the <literal>v-disabled</literal> style.
				</para>

                <para>
                    The options are normally laid out vertically. You can use horizontal
                    layout by setting <literal>display: inline-block</literal> for the
                    options. The <literal>nowrap</literal> setting for the overall element
                    prevents wrapping if there is not enough horizontal space in the
                    layout, or if the horizontal width is undefined.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[/* Lay the options horizontally */
.v-select-optiongroup-horizontal .v-select-option {
    display: inline-block;
}

/* Avoid wrapping if the layout is too tight */
.v-select-optiongroup-horizontal {
    white-space: nowrap;
}

/* Some extra spacing is needed */
.v-select-optiongroup-horizontal
  .v-select-option.v-radiobutton {
    padding-right: 10px;
}]]></programlisting>

                <para>
                    Use of the above rules requires setting a custom
                    <literal>horizontal</literal> style name for the component. The result
                    is shown in <xref
                    linkend="figure.components.selecting.optiongroup.horizontal"/>.
                </para>

                <figure xml:id="figure.components.selecting.optiongroup.horizontal">
                    <title>Horizontal <classname>OptionGroup</classname></title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="70%" align="center" fileref="img/components/optiongroup-horizontal.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

			</simplesect>
		</section>

		<section xml:id="components.selecting.twincolselect">
			<title>Twin Column Selection with <classname>TwinColSelect</classname></title>
			<para>
				The <classname>TwinColSelect</classname> field provides a multiple
				selection component that shows two lists side by side, with the left
				column containing unselected items and the right column the selected
				items. The user can select items from the list on the left and click on
				the "&gt;&gt;" button to move them to the list on the right. Items can be
				deselected by selecting them in the right list and clicking on the
				"&lt;&lt;" button.
			</para>

			<para>
                <classname>TwinColSelect</classname> is always in multi-select mode, so
                its property value is always a collection of the item IDs of the selected
                items, that is, the items in the right column.
            </para>

            <para>
                The selection columns can have their own captions, separate from the
                overall component caption, which is managed by the containing layout. You
                can set the column captions with
                <methodname>setLeftColumnCaption()</methodname> and
                <methodname>setRightColumnCaption()</methodname>.
            </para>

            <book-example id="component.select.twincolselect.captions" style="float: right"></book-example>

            <programlisting><?pocket-size 65% ?><![CDATA[final TwinColSelect select =
    new TwinColSelect("Select Targets to Destroy");

// Set the column captions (optional)
select.setLeftColumnCaption("These are left");
select.setRightColumnCaption("These are done for");
        
// Put some data in the select
String planets[] = {"Mercury", "Venus", "Earth", "Mars",
        "Jupiter", "Saturn", "Uranus", "Neptune"};
for (int pl=0; pl<planets.length; pl++)
    select.addItem(planets[pl]);

// Set the number of visible items
select.setRows(planets.length);]]></programlisting>

            <para>
                The resulting component is shown in <xref
                linkend="figure.components.selecting.twincolselect.captions"/>.
            </para>

			<figure xml:id="figure.components.selecting.twincolselect.captions">
				<title>Twin Column Selection</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/select-twincol.png"/>
					</imageobject>
				</mediaobject>
			</figure>

            <para>
                The <methodname>setRows()</methodname> method sets the height of the
                component by the number of visible items in the selection boxes. Setting
                the height with <methodname>setHeight()</methodname> to a defined value
                overrides the rows setting.
            </para>
            
			<simplesect>
				<title>CSS Style Rules</title>
				
				<programlisting><![CDATA[.v-select-twincol {}
  .v-select-twincol-options-caption {}
  .v-select-twincol-selections-caption {}
  .v-select-twincol-options {}
  .v-select-twincol-buttons {}
    .v-button {}
      .v-button-wrap {}
        .v-button-caption {}
    .v-select-twincol-deco {}
  .v-select-twincol-selections {}]]></programlisting>

                <para>
                    The <classname>TwinColSelect</classname> component has an overall
                    <literal>v-select-twincol</literal> style. If set, the left and right
                    column captions have
                    <literal>v-select-twincol-options-caption</literal> and
                    <literal>v-select-twincol-options-caption</literal> style names,
                    respectively. The left box, which displays the unselected items, has
                    <literal>v-select-twincol-options-caption</literal> style and the
                    right box, which displays the selected items, has
                    <literal>v-select-twincol-options-selections</literal> style. Between
                    them is the button area, which has overall
                    <literal>v-select-twincol-buttons</literal> style; the actual buttons
                    reuse the styles for the <classname>Button</classname>
                    component. Between the buttons is a divider element with
                    <literal>v-select-twincol-deco</literal> style.
                </para>

			</simplesect>
		</section>


		<section xml:id="components.selecting.newitems">
			<title>Allowing Adding New Items</title>

			<para>
				The selection components allow the user to add new items, with a user
				interface similar to combo boxes in desktop user interfaces. You need to
				enable the <parameter>newItemsAllowed</parameter> mode with the
				<methodname>setNewItemsAllowed()</methodname> method.
			</para>

			<programlisting><![CDATA[myselect.setNewItemsAllowed(true);]]></programlisting>

            <para>
                The user interface for adding new items depends on the selection component
                and the selection mode. The regular <classname>Select</classname>
                component in single selection mode, which appears as a combo box, allows
                you to simply type the new item in the combo box and hit
                <keycap>Enter</keycap> to add it. In most other selection components, as
                well as in the multiple selection mode of the regular
                <classname>Select</classname> component, a text field that allows entering
                new items is shown below the selection list, and clicking the
                <guibutton>+</guibutton> button will add the item in the list, as
                illustrated in <xref linkend="figure.components.selecting.newitems"/>.
            </para>

			<figure xml:id="figure.components.selecting.newitems">
				<title>Select Component with Adding New Items Allowed</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/components/select-addnewitems.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				The identifier of an item added by the user will be a
				<classname>String</classname> object identical to the caption of the
				item. You should consider this if the item identifier of automatically
				filled items is some other type or otherwise not identical to the caption.
			</para>

			<para>
				Adding new items is possible in both single and multiple
				selection modes and in all styles. Adding new items may not be
				possible if the <classname>Select</classname> is bound to an
				external <classname>Container</classname> that does not allow
				adding new items.
			</para>
		</section>

		<section xml:id="components.selecting.multiple">
			<title>Multiple Selection Mode</title>

			<!-- UNFINISHED: Check if outdated. -->
			
			<para>
				Setting the <classname>Select</classname>,
				<classname>NativeSelect</classname>, or <classname>OptionGroup</classname>
				components to multiple selection mode with the
				<methodname>setMultiSelect()</methodname> method changes their appearance
				to allow selecting multiple items.
			</para>

            <variablelist>
                <varlistentry>
                    <term><classname>Select</classname> and <classname>NativeSelect</classname></term>
                    <listitem>
                        <para>
                            These components appear as a native HTML selection list, as
                            shown in <xref
                            linkend="figure.components.selecting.newitems"/>. By holding
                            the <keycap>Ctrl</keycap> or <keycap>Shift</keycap> key
                            pressed, the user can select multiple items.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><classname>OptionGroup</classname></term>
                    <listitem>
                        The option group, which is a radio button group in single
                        selection mode, will show as a check box group in multiple
                        selection mode. See <xref
                        linkend="components.selecting.optiongroup"/>.
                    </listitem>
                </varlistentry>
            </variablelist>

			<para>
                The <classname>TwinColSelect</classname>, described in <xref
                linkend="components.selecting.twincolselect"/>, is a special multiple
                selection mode that is not meaningful for single selection.
            </para>

			<programlisting><![CDATA[myselect.setMultiSelect(true);]]></programlisting>

			<para>
				As in single selection mode, the selected items are set as the property of
				the <classname>Select</classname> object. In multiple selection mode, the
				property is a <classname>Collection</classname> of currently selected
				items. You can get and set the property with the
				<methodname>getValue()</methodname> and
				<methodname>setValue()</methodname> methods as usual.
			</para>

			<para>
                A change in the selection will trigger a
                <classname>ValueChangeEvent</classname>, which you can handle with a
                <classname>Propery.ValueChangeListener</classname>. As usual, you should
                use <methodname>setImmediate(true)</methodname> to trigger the event
                immediately when the user changes the selection. The following example
                shows how to handle selection changes with a listener.
			</para>

            <programlisting><?pocket-size 65% ?><![CDATA[public class SelectExample
           extends CustomComponent
           implements Property.ValueChangeListener {
    // Create a Select object with a caption.
    Select select = new Select("This is a Select component");

    VerticalLayout layout = new VerticalLayout();
    Label status = new Label("-");
    
    SelectExample () {
        setCompositionRoot (layout);
        layout.addComponent(select);

        // Fill the component with some items.
        final String[] planets = new String[] {
            "Mercury", "Venus", "Earth", "Mars",
            "Jupiter", "Saturn", "Uranus", "Neptune"};
        for (int i=0; i<planets.length; i++)
            select.addItem(planets[i]);

        // By default, the change event is not triggered
        // immediately when the selection changes.
        // This enables the immediate events.
        select.setImmediate(true);
        
        // Listen for changes in the selection.
        select.addListener(this);

        layout.addComponent(status);
    }

    /* Respond to change in the selection. */
    public void valueChange(Property.ValueChangeEvent event) {
        // The event.getProperty() returns the Item ID (IID) 
        // of the currently selected item in the component.
        status.setValue("Currently selected item ID: " +
                        event.getProperty());
    }
}]]></programlisting>

        </section>

		<section xml:id="components.selecting.features">
            <title>Other Common Features</title>

            <section>
                <title>Item Icons</title>

                <para>
                    You can set an icon for each item with
                    <methodname>setItemIcon()</methodname>, or define an item property
                    that provides the icon resource with
                    <methodname>setItemIconPropertyId()</methodname>, in a fashion similar
                    to captions. Notice, however, that icons are not supported in
                    <classname>NativeSelect</classname>,
                    <classname>TwinColSelect</classname>, and some other selection
                    components and modes. This is because HTML does not support images
                    inside the native <literal>select</literal> elements. Icons are also
                    not really visually applicable.
                </para>
            </section>
        </section>

	</section>

    <!-- ================================================================== -->
    <!-- Table                                                              -->
    <!-- ================================================================== -->

	<section xml:id="components.table">
		<title><classname>Table</classname></title>

        <indexterm xml:id="term.components.table" class="startofrange">
            <primary><classname>Table</classname></primary>
        </indexterm>

		<para>
			The <classname>Table</classname> component is intended for presenting tabular
			data organized in rows and columns. The <classname>Table</classname> is one of
			the most versatile components in Vaadin. Table cells can include text
			or arbitrary UI components. You can easily implement editing of the table data,
			for example clicking on a cell could change it to a text field for editing.
		</para>

		<para>
			The data contained in a <classname>Table</classname> is managed using the Data
			Model of Vaadin (see <xref linkend="datamodel"/>), through
			the <classname>Container</classname> interface of the
			<classname>Table</classname>. This makes it possible to bind a table directly
			to a data source, such as a database query. Only the visible part of the table
			is loaded into the browser and moving the visible window with the scrollbar loads
			content from the server. While the data is being loaded, a tooltip will be
			displayed that shows the current range and total number of items in the
			table. The rows of the table are <emphasis>items</emphasis> in the container
			and the columns are <emphasis>properties</emphasis>. Each table row (item) is
			identified with an <emphasis>item identifier</emphasis> (IID), and each column
			(property) with a <emphasis>property identifier</emphasis> (PID).
		</para>

		<para>
			When creating a table, you first need to define columns with
			<methodname>addContainerProperty()</methodname>. This method comes in two
			flavors. The simpler one takes the property ID of the column and uses it also
			as the caption of the column. The more complex one allows differing PID and
			header for the column. This may make, for example, internationalization of
			table headers easier, because if a PID is internationalized, the
			internationalization has to be used everywhere where the PID is used. The
			complex form of the method also allows defining an icon for the column from a
			resource. The "default value" parameter is used when new properties (columns)
			are added to the table, to fill in the missing values. (This default has no
			meaning in the usual case, such as below, where we add items after defining
			the properties.)
		</para>

        <programlisting><?pocket-size 65% ?><![CDATA[/* Create the table with a caption. */
Table table = new Table("This is my Table");

/* Define the names and data types of columns.
 * The "default value" parameter is meaningless here. */
table.addContainerProperty("First Name", String.class,  null);
table.addContainerProperty("Last Name",  String.class,  null);
table.addContainerProperty("Year",       Integer.class, null);

/* Add a few items in the table. */
table.addItem(new Object[] {
    "Nicolaus","Copernicus",new Integer(1473)}, new Integer(1));
table.addItem(new Object[] {
    "Tycho",   "Brahe",     new Integer(1546)}, new Integer(2));
table.addItem(new Object[] {
    "Giordano","Bruno",     new Integer(1548)}, new Integer(3));
table.addItem(new Object[] {
    "Galileo", "Galilei",   new Integer(1564)}, new Integer(4));
table.addItem(new Object[] {
    "Johannes","Kepler",    new Integer(1571)}, new Integer(5));
table.addItem(new Object[] {
    "Isaac",   "Newton",    new Integer(1643)}, new Integer(6));]]></programlisting>

		<para>
			In this example, we used an increasing <classname>Integer</classname> object
			as the Item Identifier, given as the second parameter to
			<methodname>addItem()</methodname>. The actual rows are given simply as object
			arrays, in the same order in which the properties were added. The objects must
			be of the correct class, as defined in the
			<methodname>addContainerProperty()</methodname> calls.
		</para>

		<figure>
			<title>Basic Table Example</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="120" align="center" fileref="img/components/table-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			Scalability of the <classname>Table</classname> is largely dictated by
			the container. The default <classname>IndexedContainer</classname> is
			relatively heavy and can cause scalability problems, for example, when
			updating the values. Use of an optimized application-specific
			container is recommended. Table does not have a limit for the number
			of items and is just as fast with hundreds of thousands of items as
			with just a few. With the current implementation of scrolling, there
			is a limit of around 500 000 rows, depending on the browser and the pixel
			height of rows.
		</para>

		<section xml:id="components.table.selecting">
			<title>Selecting Items in a Table</title>

			<para>
				The <classname>Table</classname> allows selecting one or more items by
				clicking them with the mouse. When the user selects an item, the IID of the
				item will be set as the property of the table and a
				<classname>ValueChangeEvent</classname> is triggered. To enable selection,
				you need to set the table <emphasis>selectable</emphasis>. You will also
				need to set it as <emphasis>immediate</emphasis> in most cases, as we do
				below, because without it, the change in the property will not be
				communicated immediately to the server.
			</para>

			<para>
				The following example shows how to enable the selection of items in a
				<classname>Table</classname> and how to handle
				<classname>ValueChangeEvent</classname> events that are caused by changes
				in selection. You need to handle the event with the
				<methodname>valueChange()</methodname> method of the
				<classname>Property.ValueChangeListener</classname> interface.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Allow selecting items from the table.
table.setSelectable(true);

// Send changes in selection immediately to server.
table.setImmediate(true);

// Shows feedback from selection.
final Label current = new Label("Selected: -");

// Handle selection change.
table.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        current.setValue("Selected: " + table.getValue());
    }
});]]></programlisting>

			<figure>
				<title>Table Selection Example</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/components/table-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				If the user clicks on an already selected item, the selection will
				deselected and the table property will have <parameter>null</parameter>
				value. You can disable this behaviour by setting
				<methodname>setNullSelectionAllowed(false)</methodname> for the table.
			</para>

            <para>
                The selection is the value of the table's property, so you can get it with
                <methodname>getValue()</methodname>. You can get it also from a reference
                to the table itself. In single selection mode, the value is the item
                identifier of the selected item or <parameter>null</parameter> if no item
                is selected. In multiple selection mode (see below), the value is a
                <classname>Set</classname> of item identifiers. Notice that the set is
                unmodifiable, so you can not simply change it to change the selection.
			</para>

            <simplesect>
                <title>Multiple Selection Mode</title>

                <para>
                    A table can also be in <emphasis>multiselect</emphasis> mode, where a
                    user can select multiple items by clicking them with left mouse button
                    while holding the <keycap>Ctrl</keycap> key (or <keycap>Meta</keycap>
                    key) pressed. If <keycap>Ctrl</keycap> is not held, clicking an item
                    will select it and other selected items are deselected. The user can
                    select a range by selecting an item, holding the
                    <keycap>Shift</keycap> key pressed, and clicking another item, in
                    which case all the items between the two are also selected. Multiple
                    ranges can be selected by first selecting a range, then selecting an
                    item while holding <keycap>Ctrl</keycap>, and then selecting another
                    item with both <keycap>Ctrl</keycap> and <keycap>Shift</keycap>
                    pressed.
                </para>

                <para>
                    The multiselect mode is enabled with the
                    <methodname>setMultiSelect()</methodname> method of the
                    <classname>Select</classname> interface of
                    <classname>Table</classname>. Setting table in multiselect mode does
                    not implicitly set it as <emphasis>selectable</emphasis>, so it must
                    be set separately.
                </para>

                <para>
                    The <methodname>setMultiSelectMode()</methodname> property affects the
                    control of multiple selection:
                    <parameter>MultiSelectMode.DEFAULT</parameter> is the default
                    behaviour, which requires holding the <keycap>Ctrl</keycap> (or
                    <keycap>Meta</keycap>) key pressed while selecting items, while in
                    <parameter>MultiSelectMode.SIMPLE</parameter> holding the
                    <keycap>Ctrl</keycap> key is not needed. In the simple mode, items can
                    only be deselected by clicking them.
                </para>
            </simplesect>
		</section>

		<section xml:id="components.table.features">
			<title>Table Features</title>
			
			<section>
				<title>Page Length and Scrollbar</title>

				<para>
					The default style for <classname>Table</classname> provides a table
					with a scrollbar. The scrollbar is located at the right side of the
					table and becomes visible when the number of items in the table
					exceeds the page length, that is, the number of visible items. You can
					set the page length with <methodname>setPageLength()</methodname>.
				</para>

				<para>
					Setting the page length to zero makes all the rows in a table visible,
					no matter how many rows there are. Notice that this also effectively
					disables buffering, as all the entire table is loaded to the browser
					at once. Using such tables to generate reports does not scale up very
					well, as there is some inevitable overhead in rendering a table with
					Ajax. For very large reports, generating HTML directly is a more
					scalable solution.
				</para>
			</section>

			<section>
				<title>Resizing Columns</title>

                <para>
                    You can set the width of a column programmatically from the
                    server-side with <methodname>setColumnWidth()</methodname>. The column
                    is identified by the property ID and the width is given in pixels.
                </para>

				<para>
					The user can resize table columns by dragging the resize handle
					between two columns. Resizing a table column causes a
					<classname>ColumnResizeEvent</classname>, which you can handle with a
					<classname>Table.ColumnResizeListener</classname>. The table must be
					set in immediate mode if you want to receive the resize events
					immediately, which is typical.
                </para>

<programlisting><?pocket-size 65% ?><![CDATA[table.addListener(new Table.ColumnResizeListener() {
    public void columnResize(ColumnResizeEvent event) {
        // Get the new width of the resized column
        int width = event.getCurrentWidth();
        
        // Get the property ID of the resized column
        String column = (String) event.getPropertyId();

        // Do something with the information
        table.setColumnFooter(column, String.valueOf(width) + "px");
    }
});
        
// Must be immediate to send the resize events immediately
table.setImmediate(true);]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columnresize"/> for a result
                    after the columns of a table has been resized.
                </para>

                <figure xml:id="figure.component.table.columnresize">
                    <title>Resizing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-resize.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
			</section>

			<section>
				<title>Reordering Columns</title>
			
				<para>
                    If <methodname>setColumnReorderingAllowed(true)</methodname> is set,
                    the user can reorder table columns by dragging them with the mouse
                    from the column header,
				</para>
			</section>

			<section xml:id="component.table.columncollapsing">
                <title>Collapsing Columns</title>

                <para>
                    When <methodname>setColumnCollapsingAllowed(true)</methodname> is set,
                    the right side of the table header shows a drop-down list that allows
                    selecting which columns are shown. Collapsing columns is different
                    than hiding columns with <methodname>setVisibleColumns()</methodname>,
                    which hides the columns completely so that they can not be made
                    visible (uncollapsed) from the user interface.
                </para>

                <para>
                    You can collapse columns programmatically with
                    <methodname>setColumnCollapsed()</methodname>. Collapsing must be
                    enabled before collapsing columns with the method or it will throw an
                    <classname>IllegalAccessException</classname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Allow the user to collapse and uncollapse columns
table.setColumnCollapsingAllowed(true);

// Collapse this column programmatically
try {
    table.setColumnCollapsed("born", true);
} catch (IllegalAccessException e) {
    // Can't occur - collapsing was allowed above
    System.err.println("Something horrible occurred");
}
        
// Give enough width for the table to accommodate the
// initially collapsed column later
table.setWidth("250px");]]></programlisting>

                <para>
                    See <xref linkend="figure.component.table.columncollapsing"/>.
                </para>

                <figure xml:id="figure.component.table.columncollapsing">
                    <title>Collapsing Columns</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata smallscale="100%" align="center" fileref="img/components/table-column-collapsing.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>

                <para>
                    If the table has undefined width, it minimizes its width to fit the
                    width of the visible columns. If some columns are initially collapsed,
                    the width of the table may not be enough to accomodate them later,
                    which will result in an ugly horizontal scrollbar. You should consider
                    giving the table enough width to accomodate columns uncollapsed by the
                    user.
                </para>
            </section>

			<section>
				<title>Components Inside a Table</title>

				<para>
					The cells of a <classname>Table</classname> can contain any user
					interface components, not just strings. If the rows are higher than
					the row height defined in the default theme, you have to define the
					proper row height in a custom theme.
				</para>

				<para>
					When handling events for components inside a
					<classname>Table</classname>, such as for the
					<classname>Button</classname> in the example below, you usually need
					to know the item the component belongs to. Components do not
					themselves know about the table or the specific item in which a
					component is contained.  Therefore, the handling method must use some
					other means for finding out the Item ID of the item. There are a few
					possibilities. Usually the easiest way is to use the
					<methodname>setData()</methodname> method to attach an arbitrary
					object to a component. You can subclass the component and include the
					identity information there. You can also simply search the entire
					table for the item with the component, although that solution may not
					be so scalable.
				</para>

				<para>
					The example below includes table rows with a
					<classname>Label</classname> in XHTML formatting mode, a multiline
					<classname>TextField</classname>, a <classname>CheckBox</classname>,
					and a <classname>Button</classname> that shows as a link.
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[// Create a table and add a style to allow setting the row height in theme.
final Table table = new Table();
table.addStyleName("components-inside");

/* Define the names and data types of columns.
 * The "default value" parameter is meaningless here. */
table.addContainerProperty("Sum",            Label.class,     null);
table.addContainerProperty("Is Transferred", CheckBox.class,  null);
table.addContainerProperty("Comments",       TextField.class, null);
table.addContainerProperty("Details",        Button.class,    null);

/* Add a few items in the table. */
for (int i=0; i<100; i++) {
    // Create the fields for the current table row
    Label sumField = new Label(String.format(
                   "Sum is <b>$%04.2f</b><br/><i>(VAT incl.)</i>",
                   new Object[] {new Double(Math.random()*1000)}),
                               Label.CONTENT_XHTML);
    CheckBox transferredField = new CheckBox("is transferred");
    
    // Multiline text field. This required modifying the 
    // height of the table row.
    TextField commentsField = new TextField();
    commentsField.setRows(3);
    
    // The Table item identifier for the row.
    Integer itemId = new Integer(i);
    
    // Create a button and handle its click. A Button does not
    // know the item it is contained in, so we have to store the
    // item ID as user-defined data.
    Button detailsField = new Button("show details");
    detailsField.setData(itemId);
    detailsField.addListener(new Button.ClickListener() {
        public void buttonClick(ClickEvent event) {
            // Get the item identifier from the user-defined data.
            Integer iid = (Integer)event.getButton().getData();
            Notification.show("Link " +
                              iid.intValue() + " clicked.");
        } 
    });
    detailsField.addStyleName("link");
    
    // Create the table row.
    table.addItem(new Object[] {sumField, transferredField,
                                commentsField, detailsField},
                  itemId);
}

// Show just three rows because they are so high.
table.setPageLength(3);]]></programlisting>

				<para>
					The row height has to be set higher than the default with a style rule
					such as the following:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Table rows contain three-row TextField components. */
.v-table-components-inside .v-table-cell-content {
	height: 54px;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.components-inside"/>.
				</para>

				<figure xml:id="figure.components.table.components-inside">
					<title>Components in a Table</title>
					<mediaobject>
						<imageobject>
							<imagedata smallscale="100%" align="center" fileref="img/components/table-components.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>

			<section>
				<title>Iterating Over a Table</title>

				<para>
					As the items in a <classname>Table</classname> are not indexed, iterating
					over the items has to be done using an iterator. The
					<methodname>getItemIds()</methodname> method of the
					<classname>Container</classname> interface of <classname>Table</classname>
					returns a <classname>Collection</classname> of item identifiers over which
					you can iterate using an <classname>Iterator</classname>. For an example
					about iterating over a <classname>Table</classname>, please see <xref
						linkend="datamodel.container"/>. Notice that you may not modify the
					<classname>Table</classname> during iteration, that is, add or remove
					items. Changing the data is allowed.
				</para>
			</section>

            <section>
                <title>Filtering Table Contents</title>

                <para>
                    A table can be filtered if its container data source implements the
                    <classname>Filterable</classname> interface, as the default
                    <classname>IndexedContainer</classname> does. See <xref
                    linkend="datamodel.container.filtered"/>.
                    
                    <indexterm><primary>Container</primary><secondary>Filterable</secondary></indexterm>
                </para>
            </section>
		</section>

        <section xml:id="components.table.editing">
            <title>Editing the Values in a Table</title>
            
            <para>
                Normally, a <classname>Table</classname> simply displays the items and
                their fields as text. If you want to allow the user to edit the values,
                you can either put them inside components as we did above, or you can
                simply call <methodname>setEditable(true)</methodname> and the cells are
                automatically turned into editable fields.
            </para>

            <para>
                Let us begin with a regular table with a some columns with usual Java
                types, namely a <classname>Date</classname>,
                <classname>Boolean</classname>, and a <classname>String</classname>.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table. It is by default not editable.
final Table table = new Table();

// Define the names and data types of columns.
table.addContainerProperty("Date",     Date.class,  null);
table.addContainerProperty("Work",     Boolean.class, null);
table.addContainerProperty("Comments", String.class,  null);

// Add a few items in the table.
for (int i=0; i<100; i++) {
    Calendar calendar = new GregorianCalendar(2008,0,1);
    calendar.add(Calendar.DAY_OF_YEAR, i);
    
    // Create the table row.
    table.addItem(new Object[] {calendar.getTime(),
                                new Boolean(false),
                                ""},
                  new Integer(i)); // Item identifier
}

table.setPageLength(8);
layout.addComponent(table);]]></programlisting>

            <para>
                You could put the table in editable mode right away if you need to. We'll
                continue the example by adding a mechanism to switch the
                <classname>Table</classname> from and to the editable mode.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[final CheckBox switchEditable = new CheckBox("Editable");
switchEditable.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        table.setEditable(((Boolean)event.getProperty()
                             .getValue()).booleanValue());
    }
});
switchEditable.setImmediate(true);
layout.addComponent(switchEditable);]]></programlisting>

            <para>
                Now, when you check to checkbox, the components in the table turn into
                editable fields, as shown in <xref
                linkend="figure.component.table.editable"/>.
            </para>

            <figure xml:id="figure.component.table.editable">
                <title>A Table in Normal and Editable Mode</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="45" smallscale="100%" align="center" fileref="img/components/table-editable3.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <section>
                <title>Field Factories</title>

                <para>
                    The field components that allow editing the values of particular types
                    in a table are defined in a field factory that implements the
                    <classname>TableFieldFactory</classname> interface. The default
                    implementation is <classname>DefaultFieldFactory</classname>, which
                    offers the following crude mappings:
                </para>
                
                <table>
                    <title>Type to Field Mappings in <classname>DefaultFieldFactory</classname></title>
                    <tgroup cols="2" align="left">
                        <thead>
                            <row valign="top">
                                <entry>Property Type</entry>
                                <entry>Mapped to Field Class</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row valign="top">
                                <entry><classname>Date</classname></entry>
                                <entry>A <classname>DateField</classname>. </entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Boolean</classname></entry>
                                <entry>A <classname>CheckBox</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><classname>Item</classname></entry>
                                
                                <entry>A <classname>Form</classname> (deprecated in Vaadin
                                7). The fields of the form are automatically created from
                                the item's properties using a
                                <classname>FormFieldFactory</classname>. The normal use
                                for this property type is inside a
                                <classname>Form</classname> and is less useful inside a
                                <classname>Table</classname>.</entry>
                            </row>
                            <row valign="top">
                                <entry><emphasis>other</emphasis></entry>
                                
                                <entry>A <classname>TextField</classname>. The text field
                                    manages conversions from the basic types, if
                                    possible.</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                
                <para>
                    Field factories are covered with more detail in <xref
                        linkend="datamodel.itembinding"/>. You could just implement the
                    <classname>TableFieldFactory</classname> interface, but we recommend that
                    you extend the <classname>DefaultFieldFactory</classname> according to
                    your needs. In the default implementation, the mappings are defined in the
                    <methodname>createFieldByPropertyType()</methodname> method (you might
                    want to look at the source code) both for tables and forms.
                </para>
            </section>

            <section>
                <title>Navigation in Editable Mode</title>

                <para>
                    In the editable mode, the editor fields can have focus. Pressing
                    <keycap>Tab</keycap> moves the focus to next column or, at the last
                    column, to the first column of the next item. Respectively, pressing
                    <keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves
                    the focus backward. If the focus is in the last column of the last
                    visible item, the pressing <keycap>Tab</keycap> moves the focus
                    outside the table. Moving backward from the first column of the first
                    item moves the focus to the table itself. Some updates to the table,
                    such as changing the headers or footers or regenerating a column, can
                    move the focus from an editor component to the table itself.
                </para>

                <para>
                    The default behaviour may be undesirable in many cases. For example,
                    the focus also goes through any read-only editor fields and can move
                    out of the table inappropriately. You can provide better navigation is
                    to use event handler for shortcut keys such as <keycap>Tab</keycap>,
                    <keycap>Arrow Up</keycap>, <keycap>Arrow Down</keycap>, and
                    <keycap>Enter</keycap>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Keyboard navigation
class KbdHandler implements Handler {
    Action tab_next = new ShortcutAction("Tab",
            ShortcutAction.KeyCode.TAB, null);
    Action tab_prev = new ShortcutAction("Shift+Tab",
            ShortcutAction.KeyCode.TAB,
            new int[] {ShortcutAction.ModifierKey.SHIFT});
    Action cur_down = new ShortcutAction("Down",
            ShortcutAction.KeyCode.ARROW_DOWN, null);
    Action cur_up   = new ShortcutAction("Up",
            ShortcutAction.KeyCode.ARROW_UP,   null);
    Action enter   = new ShortcutAction("Enter",
            ShortcutAction.KeyCode.ENTER,      null);
    public Action[] getActions(Object target, Object sender) {
        return new Action[] {tab_next, tab_prev, cur_down,
                             cur_up, enter};
    }

    public void handleAction(Action action, Object sender,
                             Object target) {
        if (target instanceof TextField) {
            // Move according to keypress
            int itemid = (Integer) ((TextField) target).getData();
            if (action == tab_next || action == cur_down)
                itemid++;
            else if (action == tab_prev || action == cur_up)
                itemid--;
            // On enter, just stay where you were. If we did
            // not catch the enter action, the focus would be
            // moved to wrong place.
            
            if (itemid >= 0 && itemid < table.size()) {
                TextField newTF = valueFields.get(itemid);
                if (newTF != null)
                    newTF.focus();
            }
        }
    }
}

// Panel that handles keyboard navigation
Panel navigator = new Panel();
navigator.addStyleName(Reindeer.PANEL_LIGHT);
navigator.addComponent(table);
navigator.addActionHandler(new KbdHandler());]]></programlisting>

                <para>
                    The main issue in implementing keyboard navigation in an editable
                    table is that the editor fields do not know the table they are in. To
                    find the parent table, you can either look up in the component
                    container hierarchy or simply store a reference to the table with
                    <methodname>setData()</methodname> in the field component. The other
                    issue is that you can not acquire a reference to an editor field from
                    the <classname>Table</classname> component. One solution is to use
                    some external collection, such as a <classname>HashMap</classname>, to
                    map item IDs to the editor fields.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Can't access the editable components from the table so
// must store the information
final HashMap<Integer,TextField> valueFields =
    new HashMap<Integer,TextField>();]]></programlisting>

                <para>
                    The map has to be filled in a
                    <classname>TableFieldFactory</classname>, such as in the
                    following. You also need to set the reference to the table there and
                    you can also set the initial focus there.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[table.setTableFieldFactory(new TableFieldFactory () {
    public Field createField(Container container, Object itemId,
            Object propertyId, Component uiContext) {
        TextField field = new TextField((String) propertyId);
        
        // User can only edit the numeric column
        if ("Source of Fear".equals(propertyId))
            field.setReadOnly(true);
        else { // The numeric column
            // The field needs to know the item it is in
            field.setData(itemId);
            
            // Remember the field
            valueFields.put((Integer) itemId, field);
            
            // Focus the first editable value
            if (((Integer)itemId) == 0)
                field.focus();
        }
        return field;
    }
});]]></programlisting>

                <para>
                    The issues are complicated by the fact that the editor fields are not
                    generated for the entire table, but only for a cache window that
                    includes the visible items and some items above and below it. For
                    example, if the beginning of a big scrollable table is visible, the
                    editor component for the last item does not exist. This issue is
                    relevant mostly if you want to have wrap-around navigation that jumps
                    from the last to first item and vice versa.
                </para>
            </section>

        </section>

        <section xml:id="components.table.headersfooters">
            <title>Column Headers and Footers</title>
            
            <para>
                <classname>Table</classname> supports both column headers and footers; the
                headers are enabled by default.
            </para>

            <section xml:id="components.table.headersfooters.headers">
                <title>Headers</title>

                <para>
                    The table header displays the column headers at the top of the
                    table. You can use the column headers to reorder or resize the
                    columns, as described earlier. By default, the header of a column is
                    the property ID of the column, unless given explicitly with
                    <methodname>setColumnHeader()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Define the properties
table.addContainerProperty("lastname", String.class, null);
table.addContainerProperty("born", Integer.class, null);
table.addContainerProperty("died", Integer.class, null);

// Set nicer header names
table.setColumnHeader("lastname", "Name");
table.setColumnHeader("born", "Born");
table.setColumnHeader("died", "Died");]]></programlisting>

                <para>
                    The text of the column headers and the visibility of the header
                    depends on the <emphasis>column header mode</emphasis>. The header is
                    visible by default, but you can disable it with
                    <methodname>setColumnHeaderMode(Table.COLUMN_HEADER_MODE_HIDDEN)</methodname>.
                </para>
            </section>

            <section xml:id="components.table.headersfooters.footers">
                <title>Footers</title>

                <para>
                    The table footer can be useful for displaying sums or averages of
                    values in a column, and so on. The footer is not visible by default;
                    you can enable it with
                    <methodname>setFooterVisible(true)</methodname>. Unlike in the header,
                    the column headers are empty by default. You can set their value with
                    <methodname>setColumnFooter()</methodname>. The columns are identified
                    by their property ID.
                </para>

                <para>
                    The following example shows how to calculate average of the values in
                    a column:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Have a table with a numeric column
Table table = new Table("Custom Table Footer");
table.addContainerProperty("Name", String.class, null);
table.addContainerProperty("Died At Age", Integer.class, null);
        
// Insert some data
Object people[][] = {{"Galileo",  77},
                     {"Monnier",  83},
                     {"Vaisala",  79},
                     {"Oterma",   86}};
for (int i=0; i<people.length; i++)
    table.addItem(people[i], new Integer(i));
        
// Calculate the average of the numeric column
double avgAge = 0;
for (int i=0; i<people.length; i++)
    avgAge += (Integer) people[i][1];
avgAge /= people.length;

// Set the footers
table.setFooterVisible(true);
table.setColumnFooter("Name", "Average");
table.setColumnFooter("Died At Age", String.valueOf(avgAge));

// Adjust the table height a bit
table.setPageLength(table.size());]]></programlisting>

                <para>
                    The resulting table is shown in <xref
                    linkend="figure.components.table.headersfooters.footer"/>.
                </para>

				<figure xml:id="figure.components.table.headersfooters.footer">
					<title>A Table with a Footer</title>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="120" smallscale="80%" align="center" fileref="img/components/table-footer.png"/>
						</imageobject>
					</mediaobject>
				</figure>
            </section>

            <section>
                <title>Handling Mouse Clicks on Headers and Footers</title>

                <para>
                    Normally, when the user clicks a column header, the table will be
                    sorted by the column, assuming that the data source is
                    <classname>Sortable</classname> and sorting is not disabled. In some
                    cases, you might want some other functionality when the user clicks
                    the column header, such as selecting the column in some way.
                </para>

                <para>
                    Clicks in the header cause a <classname>HeaderClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.HeaderClickListener</classname>. Click events on the
                    table header (and footer) are, like button clicks, sent immediately to
                    server, so there is no need to set
                    <methodname>setImmediate()</methodname>.
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[// Handle the header clicks
table.addListener(new Table.HeaderClickListener() {
    public void headerClick(HeaderClickEvent event) {
        String column = (String) event.getPropertyId();
        Notification.show("Clicked " + column +
                "with " + event.getButtonName());
    }
});
        
// Disable the default sorting behavior
table.setSortDisabled(true);]]></programlisting>

                <para>
                    Setting a click handler does not automatically disable the sorting
                    behavior of the header; you need to disable it explicitly with
                    <methodname>setSortDisabled(true)</methodname>. Header click events
                    are not sent when the user clicks the column resize handlers to drag
                    them.
                </para>


                <para>
                    The <classname>HeaderClickEvent</classname> object provides the
                    identity of the clicked column with
                    <methodname>getPropertyId()</methodname>. The
                    <methodname>getButton()</methodname> reports the mouse button with
                    which the click was made: <parameter>BUTTON_LEFT</parameter>,
                    <parameter>BUTTON_RIGHT</parameter>, or
                    <parameter>BUTTON_MIDDLE</parameter>. The
                    <methodname>getButtonName()</methodname> a human-readable button name
                    in English: "<parameter>left</parameter>",
                    "<parameter>right</parameter>", or
                    "<parameter>middle</parameter>". The
                    <methodname>isShiftKey()</methodname>,
                    <methodname>isCtrlKey()</methodname>, etc., methods indicate if the
                    <keycap>Shift</keycap>, <keycap>Ctrl</keycap>, <keycap>Alt</keycap> or
                    other modifier keys were pressed during the click.
                </para>

                <para>
                    Clicks in the footer cause a <classname>FooterClickEvent</classname>,
                    which you can handle with a
                    <classname>Table.FooterClickListener</classname>. Footers do not have
                    any default click behavior, like the sorting in the header. Otherwise,
                    handling clicks in the footer is equivalent to handling clicks in the
                    header.
                </para>
            </section>
        </section>

		<section xml:id="components.table.columngenerator">
			<title>Generated Table Columns</title>

			<para>
				You might want to have a column that has values calculated from other
				columns. Or you might want to format table columns in some way, for
				example if you have columns that display currencies. The
				<classname>ColumnGenerator</classname> interface allows defining custom
				generators for such columns.
			</para>

			<para>
				You add new generated columns to a <classname>Table</classname> with
				<methodname>addGeneratedColumn()</methodname>. It takes the column
				identifier as its parameters. Usually you want to have a more
				user-friendly and possibly internationalized column header. You can set
				the header and a possible icon by calling
				<methodname>addContainerProperty()</methodname>
				<emphasis>before</emphasis> adding the generated column.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Define table columns. 
table.addContainerProperty(
    "date",     Date.class,   null, "Date",         null, null);
table.addContainerProperty(
    "quantity", Double.class, null, "Quantity (l)", null, null);
table.addContainerProperty(
    "price",    Double.class, null, "Price (e/l)",  null, null);
table.addContainerProperty(
    "total",    Double.class, null, "Total (e)",    null, null);

// Define the generated columns and their generators.
table.addGeneratedColumn("date",
                         new DateColumnGenerator());
table.addGeneratedColumn("quantity",
                         new ValueColumnGenerator("%.2f l"));
table.addGeneratedColumn("price",
                         new PriceColumnGenerator());
table.addGeneratedColumn("total",
                         new ValueColumnGenerator("%.2f e"));]]></programlisting>

			<para>
				Notice that the <methodname>addGeneratedColumn()</methodname> always
				places the generated columns as the last column, even if you defined some
				other order previously. You will have to set the proper order with
				<methodname>setVisibleColumns()</methodname>.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[table.setVisibleColumns(new Object[] {"date", "quantity", "price", "total"});]]></programlisting>

			<para>
				The generators are objects that implement the
				<classname>Table.ColumnGenerator</classname> interface and its
				<methodname>generateCell()</methodname> method. The method gets the
				identity of the item and column as its parameters, in addition to the
				table object. It has to return a component object.
			</para>
				
			<para>
				The following example defines a generator for formatting
				<classname>Double</classname> valued fields according to a format string
				(as in <classname>java.util.Formatter</classname>).
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[/** Formats the value in a column containing Double objects. */
class ValueColumnGenerator implements Table.ColumnGenerator {
    String format; /* Format string for the Double values. */

    /**
     * Creates double value column formatter with the given
     * format string.
     */
    public ValueColumnGenerator(String format) {
        this.format = format;
    }

    /**
     * Generates the cell containing the Double value.
     * The column is irrelevant in this use case.
     */
    public Component generateCell(Table source, Object itemId,
                                  Object columnId) {
        // Get the object stored in the cell as a property
        Property prop =
            source.getItem(itemId).getItemProperty(columnId);
        if (prop.getType().equals(Double.class)) {
            Label label = new Label(String.format(format,
                    new Object[] { (Double) prop.getValue() }));
            
            // Set styles for the column: one indicating that it's
            // a value and a more specific one with the column
            // name in it. This assumes that the column name
            // is proper for CSS.
            label.addStyleName("column-type-value");
            label.addStyleName("column-" + (String) columnId);
            return label;
        }
        return null;
    }
}]]></programlisting>

            <!-- TODO: The following was removed because it's probably false (#3189). -->
			<!-- para>
				If you wish to have a custom style for the cells, you have to set it in
				the generator. A <classname>CellStyleGenerator</classname> defined for a
				table will not be called for the cells of generated columns.
			</para -->

			<para>
				The generator is called for all the visible (or more accurately cached)
				items in a table. If the user scrolls the table to another position in the
				table, the columns of the new visible rows are generated dynamically. The
				columns in the visible (cached) rows are also generated always when an
				item has a value change. It is therefore usually safe to calculate the
				value of generated cells from the values of different rows (items).
			</para>

			<para>
				When you set a table as <parameter>editable</parameter>, regular fields
				will change to editing fields. When the user changes the values in the
				fields, the generated columns will be updated automatically. Putting a
				table with generated columns in editable mode has a few quirks. The
				editable mode of <classname>Table</classname> does not affect generated
				columns. You have two alternatives: either you generate the editing fields
				in the generator or, in case of formatter generators, remove the generator
				in the editable mode. The example below uses the latter approach.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Have a check box that allows the user
// to make the quantity and total columns editable.
final CheckBox editable = new CheckBox(
    "Edit the input values - calculated columns are regenerated");

editable.setImmediate(true);
editable.addListener(new ClickListener() {
    public void buttonClick(ClickEvent event) {
        table.setEditable(editable.booleanValue());
        
        // The columns may not be generated when we want to
        // have them editable.
        if (editable.booleanValue()) {
            table.removeGeneratedColumn("quantity");
            table.removeGeneratedColumn("total");
        } else { // Not editable
            // Show the formatted values.
            table.addGeneratedColumn("quantity",
                new ValueColumnGenerator("%.2f l"));
            table.addGeneratedColumn("total",
                new ValueColumnGenerator("%.2f e"));
        }
        // The visible columns are affected by removal
        // and addition of generated columns so we have
        // to redefine them.
        table.setVisibleColumns(new Object[] {"date", "quantity",
                 "price", "total", "consumption", "dailycost"});
    }
});]]></programlisting>

            <para>
                You will also have to set the editing fields in
                <parameter>immediate</parameter> mode to have the update occur immediately
                when an edit field loses the focus. You can set the fields in
                <parameter>immediate</parameter> mode with the a custom
                <classname>TableFieldFactory</classname>, such as the one given below,
                that just extends the default implementation to set the mode:
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[public class ImmediateFieldFactory extends DefaultFieldFactory {
    public Field createField(Container container,
                             Object itemId,
                             Object propertyId,
                             Component uiContext) {
        // Let the DefaultFieldFactory create the fields...
        Field field = super.createField(container, itemId,
                                        propertyId, uiContext);
        
        // ...and just set them as immediate.
        ((AbstractField)field).setImmediate(true);
        
        return field;
    }
}
...
table.setTableFieldFactory(new ImmediateFieldFactory());]]></programlisting>

			<para>
				If you generate the editing fields with the column generator, you avoid
				having to use such a field factory, but of course have to generate the
				fields for both normal and editable modes.
			</para>

			<para>
				<xref linkend="figure.ui.table.generated"/> shows a table with
				columns calculated (blue) and simply formatted (black) with column
				generators.
			</para>

			<figure xml:id="figure.ui.table.generated">
				<title>Table with Generated Columns in Normal and Editable Mode</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns1.png"/>
					</imageobject>
				</mediaobject>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="100%" align="center" fileref="img/components/table-generatedcolumns2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>

        <section xml:id="components.table.columnformatting">
            <title>Formatting Table Columns</title>

            <para>
                The displayed values of properties shown in a table are normally formatted
                using the <methodname>toString()</methodname> method of each
                property. Customizing the format of a column can be done in several ways:
            </para>

            <itemizedlist>
                <listitem>Using <classname>ColumnGenerator</classname> to generate a
                second column that is formatted. The original column needs to be set
                invisible. See <xref
                linkend="components.table.columngenerator"/>.</listitem>

                <listitem>Using a <classname>PropertyFormatter</classname> as a proxy
                between the table and the data property. This also normally requires using
                an mediate container in the table.</listitem>

                <listitem>Overriding the default
                <methodname>formatPropertyValue()</methodname> in
                <classname>Table</classname>.</listitem>
            </itemizedlist>

            <para>
                As using a <classname>PropertyFormatter</classname> is generally much more
                awkward than overriding the
                <methodname>formatPropertyValue()</methodname>, its use is not described
                here.
            </para>

            <para>
                You can override <methodname>formatPropertyValue()</methodname> as is done
                in the following example:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a table that overrides the default
// property (column) format
final Table table = new Table("Formatted Table") {
    @Override
    protected String formatPropertyValue(Object rowId,
            Object colId, Property property) {
        // Format by property type
        if (property.getType() == Date.class) {
            SimpleDateFormat df =
                new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
            return df.format((Date)property.getValue());
        }

        return super.formatPropertyValue(rowId, colId, property);
    }
};
        
// The table has some columns
table.addContainerProperty("Time", Date.class, null);
        
... Fill the table with data ...]]></programlisting>

            <para>
                You can also distinguish between columns by the
                <parameter>colId</parameter> parameter, which is the property ID of the
                column. <classname>DecimalFormat</classname> is useful for formatting
                decimal values.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[... in formatPropertyValue() ...
} else if ("Value".equals(pid)) {
    // Format a decimal value for a specific locale
    DecimalFormat df = new DecimalFormat("#.00",
            new DecimalFormatSymbols(locale));
    return df.format((Double) property.getValue());
}
...
table.addContainerProperty("Value", Double.class, null);]]></programlisting>

            <para>
                A table with the formatted date and decimal value columns is shown in
                <xref linkend="figure.components.table.columnformatting"/>.
            </para>

            <figure xml:id="figure.components.table.columnformatting">
                <title>Formatted Table Columns</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata smallscale="100%" align="center" fileref="img/components/table-columnformatting.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                You can use CSS for further styling of table rows, columns, and individual
                cells by using a <classname>CellStyleGenerator</classname>. It is
                described in <xref linkend="components.table.css"/>.
            </para>
        </section>

		<section xml:id="components.table.css">
			<title>CSS Style Rules</title>

            <para>
                Styling the overall style of a <classname>Table</classname> can be done
                with the following CSS rules.
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[.v-table {}
  .v-table-header-wrap {}
    .v-table-header {}
      .v-table-header-cell {}
        .v-table-resizer {} /* Column resizer handle. */
        .v-table-caption-container {}
  .v-table-body {}
    .v-table-row-spacer {}
    .v-table-table {}
      .v-table-row {}
        .v-table-cell-content {}]]></programlisting>

			<para>
				Notice that some of the widths and heights in a table are calculated
				dynamically and can not be set in CSS.
			</para>

			<section>
				<title>Setting Individual Cell Styles</title>

				<para>
					The <classname>Table.CellStyleGenerator</classname> interface allows
					you to set the CSS style for each individual cell in a table. You need
					to implement the <methodname>getStyle()</methodname>, which gets the
					row (item) and column (property) identifiers as parameters and can
					return a style name for the cell. The returned style name will be
					concatenated to prefix "<literal>v-table-cell-content-</literal>".
				</para>

                <para>
                    The <methodname>getStyle()</methodname> is called also for each row,
                    so that the <parameter>propertyId</parameter> parameter is
                    <literal>null</literal>. This allows setting a row style.
                </para>

				<para>
					Alternatively, you
					can use a <classname>Table.ColumnGenerator</classname> (see <xref
					linkend="components.table.columngenerator"/>) to generate the actual UI
					components of the cells and add style names to them.
				</para>
			
				<programlisting><?pocket-size 65% ?><![CDATA[Table table = new Table("Table with Cell Styles");
table.addStyleName("checkerboard");

// Add some columns in the table. In this example, the property
// IDs of the container are integers so we can determine the
// column number easily.
table.addContainerProperty("0", String.class, null, "", null, null);
for (int i=0; i<8; i++)
    table.addContainerProperty(""+(i+1), String.class, null,
                         String.valueOf((char) (65+i)), null, null);

// Add some items in the table.
table.addItem(new Object[]{
    "1", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(0));
table.addItem(new Object[]{
    "2", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(1));
for (int i=2; i<6; i++)
    table.addItem(new Object[]{String.valueOf(i+1), 
                 "", "", "", "", "", "", "", ""}, new Integer(i));
table.addItem(new Object[]{
    "7", "P", "P", "P", "P", "P", "P", "P", "P"}, new Integer(6));
table.addItem(new Object[]{
    "8", "R", "N", "B", "Q", "K", "B", "N", "R"}, new Integer(7));
table.setPageLength(8);

// Set cell style generator
table.setCellStyleGenerator(new Table.CellStyleGenerator() {
    public String getStyle(Object itemId, Object propertyId) {
        // Row style setting, not relevant in this example.
        if (propertyId == null)
            return "green"; // Will not actually be visible

        int row = ((Integer)itemId).intValue();
        int col = Integer.parseInt((String)propertyId);
        
        // The first column.
        if (col == 0)
            return "rowheader";
        
        // Other cells.
        if ((row+col)%2 == 0)
            return "black";
        else
            return "white";
    }
});]]></programlisting>
				
				<para>
					You can then style the cells, for example, as follows:
				</para>

				<programlisting><?pocket-size 65% ?><![CDATA[/* Center the text in header. */
.v-table-header-cell {
    text-align: center;
}

/* Basic style for all cells. */
.v-table-checkerboard .v-table-cell-content {
    text-align: center;
    vertical-align: middle;
    padding-top: 12px;
    width: 20px;
    height: 28px;
}

/* Style specifically for the row header cells. */
.v-table-cell-content-rowheader {
	background: #E7EDF3
     url(../default/table/img/header-bg.png) repeat-x scroll 0 0;
}

/* Style specifically for the "white" cells. */
.v-table-cell-content-white {
    background: white;
    color: black;
}

/* Style specifically for the "black" cells. */
.v-table-cell-content-black {
    background: black;
    color: white;
}]]></programlisting>

				<para>
					The table will look as shown in <xref
					linkend="figure.components.table.cell-style"/>.
				</para>

				<figure xml:id="figure.components.table.cell-style">
					<title>Cell Style Generator for a Table</title>
					<mediaobject>
						<imageobject role="fo">
							<imagedata align="center" scale="75" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
						<imageobject role="html">
							<imagedata smallscale="125" align="center" fileref="img/components/table-cellstylegenerator1.png"/>
						</imageobject>
					</mediaobject>
				</figure>
			</section>
		</section>

		<!-- programlisting><![CDATA[]]></programlisting -->
        <indexterm startref="term.components.table" class="endofrange"/>
	</section>

	<section xml:id="components.tree">
		<title><classname>Tree</classname></title>

		<para>
			The <classname>Tree</classname> component allows a natural way to represent
			data that has hierarchical relationships, such as filesystems or message
			threads. The <classname>Tree</classname> component in Vaadin works
			much like the tree components of most modern desktop user interface toolkits,
			for example in directory browsing.
		</para>

		<para>
			The typical use of the <classname>Tree</classname> component is for displaying
			a hierachical menu, like a menu on the left side of the screen, as in <xref
			linkend="figure.components.tree"/>, or for displaying filesystems or
			other hierarchical datasets. The <parameter>menu</parameter> style makes the
			appearance of the tree more suitable for this purpose.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[final Object[][] planets = new Object[][]{
        new Object[]{"Mercury"}, 
        new Object[]{"Venus"},
        new Object[]{"Earth", "The Moon"},    
        new Object[]{"Mars", "Phobos", "Deimos"},
        new Object[]{"Jupiter", "Io", "Europa", "Ganymedes",
                                "Callisto"},
        new Object[]{"Saturn",  "Titan", "Tethys", "Dione",
                                "Rhea", "Iapetus"},
        new Object[]{"Uranus",  "Miranda", "Ariel", "Umbriel",
                                "Titania", "Oberon"},
        new Object[]{"Neptune", "Triton", "Proteus", "Nereid",
                                "Larissa"}};
        
Tree tree = new Tree("The Planets and Major Moons");

/* Add planets as root items in the tree. */
for (int i=0; i<planets.length; i++) {
    String planet = (String) (planets[i][0]);
    tree.addItem(planet);
    
    if (planets[i].length == 1) {
        // The planet has no moons so make it a leaf.
        tree.setChildrenAllowed(planet, false);
    } else {
        // Add children (moons) under the planets.
        for (int j=1; j<planets[i].length; j++) {
            String moon = (String) planets[i][j];
            
            // Add the item as a regular item.
            tree.addItem(moon);
            
            // Set it to be a child.
            tree.setParent(moon, planet);
            
            // Make the moons look like leaves.
            tree.setChildrenAllowed(moon, false);
        }

        // Expand the subtree.
        tree.expandItemsRecursively(planet);
    }
}

main.addComponent(tree);]]></programlisting>

		<para>
			<xref linkend="figure.components.tree"/> below shows the tree from the code
			example in a practical situation.
		</para>

		<figure xml:id="figure.components.tree" float="center" floatstyle="before">
			<title>A <classname>Tree</classname> Component as a Menu</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/components/tree-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can read or set the currently selected item by the value property of the
			<classname>Tree</classname> component, that is, with
			<methodname>getValue()</methodname> and
			<methodname>setValue()</methodname>. When the user clicks an item on a tree,
			the tree will receive an <classname>ValueChangeEvent</classname>, which you
			can catch with a <classname>ValueChangeListener</classname>. To receive the
			event immediately after the click, you need to set the tree as
			<classname>setImmediate(true)</classname>.
		</para>

		<para>
			The <classname>Tree</classname> component uses
			<classname>Container</classname> data sources much like the
			<classname>Table</classname> component, with the addition that it also
			utilizes hierarchy information maintained by a
			<classname>HierarchicalContainer</classname>. The contained items can be of
			any item type supported by the container. The default container and its
			<methodname>addItem()</methodname> assume that the items are strings and the
			string value is used as the item ID.
		</para>
	</section>

	<section xml:id="components.menubar">
		<title><classname>MenuBar</classname></title>

		<para>
			The <classname>MenuBar</classname> component allows creating horizontal
			dropdown menus, much like the main menu in desktop applications.
		</para>

		<programlisting><![CDATA[// Create a menu bar
final MenuBar menubar = new MenuBar();
main.addComponent(menubar);]]></programlisting>

		<para>
			You insert the top-level menu items to a <classname>MenuBar</classname> object
			with the <methodname>addItem()</methodname> method. It takes a string label,
			an icon resource, and a command as its parameters. The icon and command are
			not required and can be <parameter>null</parameter>.
		</para>

		<programlisting><![CDATA[MenuBar.MenuItem beverages =
      menubar.addItem("Beverages", null, null);]]></programlisting>

		<para>
			The command is called when the user clicks the item. A menu command is a class
			that implements the <classname>MenuBar.Command</classname> interface.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// A feedback component
final Label selection = new Label("-");
main.addComponent(selection);

// Define a common menu command for all the menu items.
MenuBar.Command mycommand = new MenuBar.Command() {
    public void menuSelected(MenuItem selectedItem) {
        selection.setValue("Ordered a " +
                           selectedItem.getText() +
                           " from menu.");
    }  
};]]></programlisting>

		<para>
			The <methodname>addItem()</methodname> method returns a
			<classname>MenuBar.MenuItem</classname> object, which you can use to add
			sub-menu items. The <classname>MenuItem</classname> has an identical
			<methodname>addItem()</methodname> method.
		</para>

		<programlisting><?pocket-size 75% ?><![CDATA[// Put some items in the menu hierarchically
MenuBar.MenuItem beverages =
    menubar.addItem("Beverages", null, null);
MenuBar.MenuItem hot_beverages =
    beverages.addItem("Hot", null, null);
hot_beverages.addItem("Tea", null, mycommand);
hot_beverages.addItem("Coffee", null, mycommand);
MenuBar.MenuItem cold_beverages =
    beverages.addItem("Cold", null, null);
cold_beverages.addItem("Milk", null, mycommand);

// Another top-level item
MenuBar.MenuItem snacks =
    menubar.addItem("Snacks", null, null);
snacks.addItem("Weisswurst", null, mycommand);
snacks.addItem("Salami", null, mycommand);

// Yet another top-level item
MenuBar.MenuItem services =
    menubar.addItem("Services", null, null);
services.addItem("Car Service", null, mycommand);]]></programlisting>

		<para>
			The menu will look as follows:
		</para>

		<figure>
			<title>Menu Bar</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="85" smallscale="130" align="center" fileref="img/components/menubar-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<simplesect>
			<title>CSS Style Rules</title>
			
			<programlisting><![CDATA[.v-menubar { }
.gwt-MenuItem {}
.gwt-MenuItem-selected {}]]></programlisting>
			
			<para>
				The menu bar has the overall style name
				<literal>.v-menubar</literal>. Each menu item has
				<literal>.gwt-MenuItem</literal> style normally and
				<literal>.gwt-MenuItem-selected</literal> when the item is selected.
			</para>
			
		</simplesect>
	</section>

	<section xml:id="components.embedded">
		<title><classname>Embedded</classname></title>

		<para>
			The <classname>Embedded</classname> component allows displaying embedded media
			objects, such as images, animations, or any embeddable media type supported by
			the browser. The contents of an <classname>Embedded</classname> component are
			managed as <emphasis>resources</emphasis>. For documentation on resources, see
			<xref linkend="application.resources"/>.
		</para>

		<para>
			The following example displays an image from the same Java package as the
			class itself using the class loader.
		</para>

		<programlisting><![CDATA[Embedded image = new Embedded("Yes, logo:",
    new ClassResource("vaadin-logo.png", this));
main.addComponent(image);]]></programlisting>

        <!-- TODO CRITICAL: Replace with Vaadin logo. -->
		<figure>
			<title>Embedded Image</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/components/embedded-example1.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/components/embedded-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The <classname>Embedded</classname> component supports several different
			content types, which are rendered differently in HTML. You can set the content
			type with <methodname>setType()</methodname>, although for images, as in the
			above example, the type is determined automatically.
		</para>
        
        <variablelist>
            <varlistentry>
                <term><parameter>Embedded.TYPE_OBJECT</parameter></term>
                <listitem>
                    The default embedded type, allows embedding certain file types inside
                    HTML <tag>&lt;object&gt;</tag> and <tag>&lt;embed&gt;</tag> elements.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>Embedded.TYPE_IMAGE</parameter></term>
                <listitem>
                    Embeds an image inside a HTML <tag>&lt;img&gt;</tag> element.
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>Embedded.TYPE_BROWSER</parameter></term>
                <listitem>
                    Embeds a browser frame inside a HTML <tag>&lt;iframe&gt;</tag>
                    element.
                </listitem>
            </varlistentry>
        </variablelist>

		<section>
			<title>Embedded Objects</title>

			<para>
				The <parameter>Embedded.TYPE_OBJECT</parameter> is the default and most
				generic embedded type, which allows embedding media objects inside HTML
				<tag>&lt;object&gt;</tag> and <tag>&lt;embed&gt;</tag> elements. You need
				define the MIME type for the object type.
			</para>

			<para>
				Currently, only Shockwave Flash animations are supported (MIME type
				<literal>application/x-shockwave-flash</literal>).
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create a Shockware Flash resource
final ClassResource flashResource =
    new ClassResource("itmill_spin.swf", getApplication());

// Display the resource in a Embedded compoant
final Embedded embedded =
    new Embedded("Embedded Caption", flashResource);

// This is the default type, but we set it anyway.
embedded.setType(Embedded.TYPE_OBJECT);

// This is recorgnized automatically, but set it anyway.
embedded.setMimeType("application/x-shockwave-flash");]]></programlisting>

			<para>
				You can set object parameters with
				<methodname>setParameter()</methodname>, which takes a parameter's name
				and value as strings. The object parameters are included in the HTML as
				<tag>&lt;param&gt;</tag> elements.
			</para>
		</section>
		
		<section>
			<title>Embedded Images</title>

			<para>
				Images are embedded with the type
				<parameter>Embedded.TYPE_IMAGE</parameter>, although you do not normally
				need to set the type explicitly, as it is recognized automatically from
				the MIME type of the resource, as in the example above.
			</para>

            <para>
                <classname>Embedded</classname> component has by default undefined size in
                both directions, so it will automatically fit the size of the embedded
                image.

                <indexterm><primary>scroll bars</primary></indexterm>

                If you want scrolling with scroll bars, you can put the
                <classname>Embedded</classname> inside a <classname>Panel</classname> that
                has a defined size to enable scrolling, as described in <xref
                linkend="layout.components.panel.scrolling"/>. You can also give it a
                defined size and set the <literal>overflow: auto</literal> CSS property
                for it in a theme.
                <indexterm>overflow CSS property</indexterm>
            </para>

			<para>
				You can find another example of displaying an image from
				<classname>FileResource</classname> in <xref
				linkend="components.upload"/>. Another example, in <xref
				linkend="application.resources.stream"/>, shows how you can generate the
				content of an <classname>Embedded</classname> component dynamically using
				a <classname>StreamResource</classname>.
			</para>
			
			<para>
				If you have a dynamically generated image, for example with a
				<classname>StreamResource</classname>, and the data changes, you need to
				reload the image in the browser. Because of how caching is handled in some
				browsers, you are best off by renaming the filename of the resource with a
				unique name, such as one including a timestamp. You should set cache time
				to zero with <methodname>setCacheTime()</methodname> for the resource
				object when you create it.

				<!-- BUG #2470. -->
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create the stream resource with some initial filename.
StreamResource imageResource =
    new StreamResource(imageSource, "initial-filename.png",
                       getApplication());

// Instruct browser not to cache the image.
imageResource.setCacheTime(0);

// Display the image in an Embedded component.
Embedded embedded = new Embedded("", imageResource);]]></programlisting>

			<para>
				When refreshing, you also need to call
				<methodname>requestRepaint()</methodname> for the
				<classname>Embedded</classname> object.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// This needs to be done, but is not sufficient.
embedded.requestRepaint();

// Generate a filename with a timestamp.
SimpleDateFormat df = new SimpleDateFormat("yyyyMMddHHmmssSSS");
String filename = "myfilename-" + df.format(new Date()) + ".png";

// Replace the filename in the resource.
imageResource.setFilename(makeImageFilename());]]></programlisting>

			<para>
				You can find more detailed information about the
				<classname>StreamResource</classname> in <xref
				linkend="application.resources.stream"/>.
			</para>
			
		</section>
		
		<section>
			<title>Browser Frames</title>

			<para>
				The browser frame type allows you to embed external content inside an HTML
				<tag>&lt;iframe&gt;</tag> element. You can refer to a URL with an
				<classname>ExternalResource</classname> object. URLs are given with the
				standard Java <classname>URL</classname> class.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[URL url = new URL("http://dev.vaadin.com/");
Embedded browser = new Embedded("", new ExternalResource(url));
browser.setType(Embedded.TYPE_BROWSER);
main.addComponent(browser);]]></programlisting>

		</section>
		
	</section>

	<section xml:id="components.upload">
		<title><classname>Upload</classname></title>
		
		<para>
			The <classname>Upload</classname> component allows a user to upload
			files to the server. It displays a file name entry box, a file
			selection button, and an upload submit button. The user can either
			write the filename in the text area or click the <guibutton>Browse</guibutton> button to
			select a file. After the file is selected, the user sends the file by
			pressing the upload submit button.
		</para>

		<programlisting><?pocket-size 65% ?><![CDATA[// Create the Upload component.
Upload upload = new Upload("Upload the file here", this);]]></programlisting>

		<figure xml:id="figure.ui.upload">
			<title>Upload Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="130" align="center" fileref="img/components/upload.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			You can set the text of the upload button with
			<methodname>setButtonCaption()</methodname>, as in the example above, but it
			is difficult to change the look of the <guibutton>Browse</guibutton>
			button. This is a security feature of web browsers. The language of the
			<guibutton>Browse</guibutton> button is determined by the browser, so if you
			wish to have the language of the <classname>Upload</classname> component
			consistent, you will have to use the same language in your application.
		</para>

		<programlisting><![CDATA[upload.setButtonCaption("Upload Now");]]></programlisting>

		<para>
			The uploaded files are typically stored as files in a file system, in
			a database, or as temporary objects in memory. The upload component
			writes the received data to an
			<classname>java.io.OutputStream</classname> so you have plenty of
			freedom in how you can process the upload content.
		</para>
		
		<para>
			To use the <classname>Upload</classname> component, you need to
			define a class that implements the
			<classname>Upload.Receiver</classname> interface. The
			<methodname>receiveUpload()</methodname> method is called when the
			user clicks the submit button. The method must return an
			<classname>OutputStream</classname>. To do this, it typically creates
			a <classname>File</classname> or a memory buffer where the stream is
			written. The method gets the file name and MIME type of the file, as
			reported by the browser.
		</para>

		<para>
			When an upload is finished, successfully or unsuccessfully, the
			<classname>Upload</classname> component will emit the
			<classname>Upload.FinishedEvent</classname> event. To receive it, you
			need to implement the <classname>Upload.FinishedListener</classname>
			interface, and register the listening object in the
			<classname>Upload</classname> component. The event object will also
			include the file name, MIME type, and length of the file. Notice that
			the more specific <classname>Upload.FailedEvent</classname> and
			<classname>Upload.SucceededEvent</classname> events will be called in
			the cases where the upload failed or succeeded, respectively.
		</para>

		<para>
			The following example allows uploading images to
			<filename>/tmp/uploads</filename> directory in (UNIX) filesystem (the
			directory must exist or the upload fails). The component displays the last
			uploaded image in an <classname>Embedded</classname> component.
		</para>

        <book-example id="component.upload.basic" style="float: right"/>
		<programlisting><?pocket-size 65% ?><![CDATA[// Create the upload with a caption and set receiver later
Upload upload = new Upload("Upload Image Here", null);
upload.setButtonCaption("Start Upload");
        
// Put the upload component in a panel
Panel panel = new Panel("Cool Image Storage");
panel.addComponent(upload);
        
// Show uploaded file in this placeholder
final Embedded image = new Embedded("Uploaded Image");
image.setVisible(false);
panel.addComponent(image);

// Implement both receiver that saves upload in a file and
// listener for successful upload
class ImageUploader implements Receiver, SucceededListener {
    public File file;
    
    public OutputStream receiveUpload(String filename,
                                      String mimeType) {
        // Create upload stream
        FileOutputStream fos = null; // Stream to write to
        try {
            // Open the file for writing.
            file = new File("/tmp/uploads/" + filename);
            fos = new FileOutputStream(file);
        } catch (final java.io.FileNotFoundException e) {
            Notification.show(
                    "Could not open file<br/>", e.getMessage(),
                    Notification.TYPE_ERROR_MESSAGE);
            return null;
        }
        return fos; // Return the output stream to write to
    }

    public void uploadSucceeded(SucceededEvent event) {
        // Show the uploaded file in the image viewer
        image.setVisible(true);
        image.setSource(new FileResource(file,
                                         getApplication()));
    }
};
final ImageUploader uploader = new ImageUploader(); 
upload.setReceiver(uploader);
upload.addListener(uploader);]]></programlisting>

		<para>
			The example does not check the type of the uploaded files in any way, which
			will cause an error if the content is anything else but an image. The program
			also assumes that the MIME type of the file is resolved correctly based on the
			file name extension. After uploading an image, the component will look as show
			in <xref linkend="figure.ui.upload.example"/> below.
		</para>

		<figure xml:id="figure.ui.upload.example">
			<title>Image Upload Example</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="100%" align="center" fileref="img/components/upload-example.png"/>
				</imageobject>
			</mediaobject>
		</figure>
	</section>

	<section xml:id="components.progressindicator">
		<title><classname>ProgressIndicator</classname></title>

		<para>
			The <classname>ProgressIndicator</classname> component allows displaying the
			progress of a task graphically. The progress is given as a floating-point
			value between 0.0 and 1.0.
		</para>

		<figure>
			<title>The Progress Indicator Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="140" align="center" fileref="img/components/progressindicator-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The progress indicator polls the server for updates for its value. If the
			value has changed, the progress is updated. Notice that the user application
			does not have to handle any polling event, but updating the component is done
			automatically.
		</para>

		<para>
			Creating a progress indicator is just like with any other component. You
			can give the initial progress value as a parameter for the constructor. The default
			polling frequency is 1000 milliseconds (one second), but you can set some
			other interval with the <methodname>setPollingInterval()</methodname> method.
		</para>

		<programlisting><![CDATA[// Create the indicator
final ProgressIndicator indicator =
        new ProgressIndicator(new Float(0.0));
main.addComponent(indicator);

// Set polling frequency to 0.5 seconds.
indicator.setPollingInterval(500);]]></programlisting>

		<simplesect>
			<title>CSS Style Rules</title>
				
			<programlisting><![CDATA[/* Base element. */
.v-progressindicator {}

/* Progress indication element on top of the base. */
.v-progressindicator div {}]]></programlisting>

			<para>
				The default style for the progress indicator uses an animated GIF image
				(<filename>img/base.gif</filename>) as the base background for the
				component. The progress is a <literal>&lt;div&gt;</literal> element inside
				the base. When the progress element grows, it covers more and more of the
				base background. By default, the graphic of the progress element is
				defined in <filename>img/progress.png</filename> under the default style
				directory. See
				<filename>com.vaadin.terminal.gwt/public/default/progressindicator/progressindicator.css</filename>.
			</para>
		</simplesect>

		<section>
			<title>Doing Heavy Computation</title>

			<para>
				The progress indicator is often used to display the progress of a heavy
				server-side computation task. In the following example, we create a thread
				in the server to do some "heavy work". All the thread needs to do is to
				set the value of the progress indicator with
				<methodname>setValue()</methodname> and the current progress is displayed
				automatically when the browser polls the server.
			</para>

			<programlisting><?pocket-size 65% ?><![CDATA[// Create an indicator that makes you look busy
final ProgressIndicator indicator =
        new ProgressIndicator(new Float(0.0));
main.addComponent(indicator);

// Set polling frequency to 0.5 seconds.
indicator.setPollingInterval(500);

// Add a button to start working
final Button button = new Button("Click to start");
main.addComponent(button);

// Another thread to do some work
class WorkThread extends Thread {
    public void run () {
        double current = 0.0;
        while (true) {
            // Do some "heavy work"
            try {
                sleep(50); // Sleep for 50 milliseconds
            } catch (InterruptedException) {}
            
            // Show that you have made some progress:
            // grow the progress value until it reaches 1.0.
            current += 0.01;
            if (current>1.0)
                indicator.setValue(new Float(1.0));
            else 
                indicator.setValue(new Float(current));
            
            // After all the "work" has been done for a while,
            // take a break.
            if (current > 1.2) {
                // Restore the state to initial.
                indicator.setValue(new Float(0.0));
                button.setVisible(true);
                break;
            }
        }
    }
}

// Clicking the button creates and runs a work thread
button.addListener(new Button.ClickListener() {
    public void buttonClick(ClickEvent event) {
        final WorkThread thread = new WorkThread();
        thread.start();
        
        // The button hides until the work is done.
        button.setVisible(false);
    }
});]]></programlisting>

			<figure>
				<title>Starting Heavy Work</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="140" align="center" fileref="img/components/progressindicator-example2.png"/>
					</imageobject>
				</mediaobject>
			</figure>
		</section>
	</section>

	<section xml:id="components.slider">
		<title><classname>Slider</classname></title>

        <para>
            The <classname>Slider</classname> is a vertical or horizontal bar that allows
            setting a numeric value within a defined range by dragging a bar handle with
            the mouse. The value is shown when dragging the handle.
        </para>

        <para>
            <classname>Slider</classname> has a number of different constructors that take
            a combination of the caption, <emphasis>minimum</emphasis> and
            <emphasis>maximum</emphasis> value, <emphasis>resolution</emphasis>, and the
            <emphasis>orientation</emphasis> of the slider.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Create a vertical slider
final Slider vertslider = new Slider(1, 100);
vertslider.setOrientation(Slider.ORIENTATION_VERTICAL);]]></programlisting>

        <variablelist>
            <title>Slider Properties</title>
            <varlistentry>
                <term><emphasis>min</emphasis></term>
                <listitem>
                    <para>
                        Minimum value of the slider range. The default is 0.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>max</emphasis></term>
                <listitem>
                    <para>
                        Maximum value of the slider range. The default is 100.0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>resolution</emphasis></term>
                <listitem>
                    <para>
                        The number of digits after the decimal point. The default is 0.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><emphasis>orientation</emphasis></term>
                <listitem>
                    <para>
                        The orientation can be either horizontal
                        (<parameter>Slider.ORIENTATION_HORIZONTAL</parameter>) or vertical
                        (<parameter>Slider.ORIENTATION_VERTICAL</parameter>). The default
                        is horizontal.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>

        <para>
            As the <classname>Slider</classname> is a field component, you can handle
            value changes with a <classname>ValueChangeListener</classname>. The value of
            the <classname>Slider</classname> field is a <classname>Double</classname>
            object.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Shows the value of the vertical slider
final Label vertvalue = new Label();
vertvalue.setSizeUndefined();

// Handle changes in slider value.
vertslider.addListener(new Property.ValueChangeListener() {
    public void valueChange(ValueChangeEvent event) {
        double value = (Double) vertslider.getValue();

        // Use the value
        box.setHeight((float) value, Sizeable.UNITS_PERCENTAGE);
        vertvalue.setValue(String.valueOf(value));
    }
});

// The slider has to be immediate to send the changes
// immediately after the user drags the handle.
vertslider.setImmediate(true);]]></programlisting>

        <para>
            You can set the value with the <methodname>setValue()</methodname> method
            defined in <classname>Slider</classname> that takes the value as a native
            double value. The setter can throw a
            <classname>ValueOutOfBoundsException</classname>, which you must handle.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// Set the initial value. This has to be set after the
// listener is added if we want the listener to handle
// also this value change.
try {
	vertslider.setValue(50.0);
} catch (ValueOutOfBoundsException e) {
}]]></programlisting>

        <para>
            Alternatively, you can use the regular
            <methodname>setValue(Object)</methodname>, which does not do bounds checking.
        </para>

        <para>
            <xref linkend="figure.components.slider.example1"/> shows both vertical (from
            the code examples) and horizontal sliders that control the size of a box. The
            slider values are displayed also in separate labels.
        </para>

        <figure xml:id="figure.components.slider.example1">
            <title>The <classname>Slider</classname> Component</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/slider-example1-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="100" smallscale="70%" align="center" fileref="img/components/slider-example1-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <simplesect>
            <title>CSS Style Rules</title>

            <programlisting><![CDATA[.v-slider {}
.v-slider-base {}
.v-slider-handle {}]]></programlisting>

            <para>
                The enclosing style for the <classname>Slider</classname> is
                <literal>v-slider</literal>. The slider bar has style
                <literal>v-slider-base</literal>. Even though the handle is higher (for
                horizontal slider) or wider (for vertical slider) than the bar, the handle
                element is nevertheless contained within the slider bar element. The
                appearance of the handle comes from a background image defined in the
                <emphasis>background</emphasis> CSS property.
            </para>
        </simplesect>  
    </section>

	<section xml:id="components.loginform">
		<title><classname>LoginForm</classname></title>

        <para>
            The <classname>LoginForm</classname> component is a login form that allows a
            password manager in the web browser to remember and later automatically fill
            in the username and password. This commonly used functionality does not work
            with regular Vaadin components and is a common problem with Ajax
            applications.
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[// A wrapper with a caption for the login form
Panel loginPanel = new Panel("Login");
loginPanel.setWidth("250px");
        
LoginForm login = new LoginForm();
loginPanel.addComponent(login);]]></programlisting>

        <para>
            The resulting form is shown in <xref linkend="figure.components.loginform.basic"/>.
        </para>

        <figure xml:id="figure.components.loginform.basic">
            <title>The <classname>LoginForm</classname> Component</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/components/loginform-basic.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="120" smallscale="80%" align="center" fileref="img/components/loginform-basic.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            The <classname>LoginForm</classname> uses static HTML inside an
            <literal>iframe</literal> element to enable the functionality. The component
            provides a default implementation of the static HTML; if you want to change
            the layout, you need to reimplement the
            <methodname>getLoginHtml()</methodname> method.
        </para>

        <para>
            The login form has by default 100%x100% relative size, taking all the space
            given by the containing layout. You may set the size to fixed values, but not
            undefined in either direction, because the contained <literal>iframe</literal>
            element takes all of this size (it also has 100%x100% size). How the actual
            form uses this space depends on the static HTML. Giving too little space for
            the form results in scroll bars.
        </para>

        <section>
            <title>Customizing <classname>LoginForm</classname></title>

            <para>
                Customization of the login form is necessary, for example, if you need to
                change the layout or internationalize the form. Customization is done by
                overriding the <methodname>getLoginHtml()</methodname> method, which
                returns the static HTML of the form. The customization layer is very
                "unvaadin"-like, and at best hack-ish, but dictated by the form management
                in browsers.
            </para>

            <para>
                Let us look at a custom login form that lets the user of the form to give
                the field captions:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[class MyLoginForm extends LoginForm {
    String usernameCaption;
    String passwordCaption;
    String submitCaption;
    
    public MyLoginForm(String usernameCaption,
            String passwordCaption, String submitCaption) {
        this.usernameCaption = usernameCaption;
        this.passwordCaption = passwordCaption;
        this.submitCaption  = submitCaption;
    }]]></programlisting>

            <para>
                Then we override the method that generates the static HTML for the form:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[@Override
protected byte[] getLoginHTML() {
    // Application URI needed for submitting form
    String appUri = getApplication().getURL().toString()
            + getWindow().getName() + "/";

    String x, h, b; // XML header, HTML head and body]]></programlisting>

            <para>
                The XML header is needed for the validity of the XHTML page:
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[    x = "<!DOCTYPE html PUBLIC \"-//W3C//DTD "
      + "XHTML 1.0 Transitional//EN\" "
      + "\"http://www.w3.org/TR/xhtml1/"
      + "DTD/xhtml1-transitional.dtd\">\n";]]></programlisting>

            <para>
                Notice that it is important to have a newline (<literal>\n</literal>) at
                the end of the XML header line.
            </para>

            <para>
                The HTML header part contains JavaScript definitions that handle
                submitting the form data. It also copies the style sheet references from
                the parent window.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[    h = "<head><script type='text/javascript'>"
      + "var setTarget = function() {"
      + "  var uri = '" + appUri + "loginHandler';"
      + "  var f = document.getElementById('loginf');"
      + "  document.forms[0].action = uri;"
      + "  document.forms[0].username.focus();"
      + "};"
      + ""
      + "var styles = window.parent.document.styleSheets;"
      + "for(var j = 0; j < styles.length; j++) {\n"
      + "  if(styles[j].href) {"
      + "    var stylesheet = document.createElement('link');\n"
      + "    stylesheet.setAttribute('rel', 'stylesheet');\n"
      + "    stylesheet.setAttribute('type', 'text/css');\n"
      + "    stylesheet.setAttribute('href', styles[j].href);\n"
      + "    document.getElementsByTagName('head')[0]"
      + "                .appendChild(stylesheet);\n"
      + "  }"
      + "}\n"
      + "function submitOnEnter(e) {"
      + "  var keycode = e.keyCode || e.which;"
      + "  if (keycode == 13) {document.forms[0].submit();}"
      + "}\n"
      + "</script>"
      + "</head>";]]></programlisting>

            <para>
                The HTML body element contains the actual form. Notice that it is contained
                within an inner <literal>iframe</literal>. The form and the button must
                have JavaScript calls to submit the form content.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[    b = "<body onload='setTarget();'"
      + "  style='margin:0;padding:0; background:transparent;'"
      + "  class='"
      + ApplicationConnection.GENERATED_BODY_CLASSNAME + "'>"
      + "<div class='v-app v-app-loginpage'"
      + "     style='background:transparent;'>"
      + "<iframe name='logintarget' style='width:0;height:0;"
      + "border:0;margin:0;padding:0;'></iframe>"
      + "<form id='loginf' target='logintarget'"
      + "      onkeypress='submitOnEnter(event)'"
      + "      method='post'>"
      + "<table>"
      + "<tr><td>" + usernameCaption + "</td>"
      + "<td><input class='v-textfield' style='display:block;'"
      + "           type='text' name='username'></td></tr>"
      + "<tr><td>" + passwordCaption + "</td>"
      + "    <td><input class='v-textfield'"
      + "          style='display:block;' type='password'"
      + "          name='password'></td></tr>"
      + "</table>"
      + "<div>"
      + "<div onclick='document.forms[0].submit();'"
      + "     tabindex='0' class='v-button' role='button'>"
      + "<span class='v-button-wrap'>"
      + "<span class='v-button-caption'>"
      + submitCaption + "</span>"
      + "</span></div></div></form></div></body>";]]></programlisting>

            <para>
                Then combine and return the page as a byte array.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[    return (x + "<html>" + h + b + "</html>").getBytes();
}]]></programlisting>

            <para>
                We can use the custom login form as follows:
            </para>
        
            <programlisting><?pocket-size 65% ?><![CDATA[MyLoginForm loginForm = new MyLoginForm("Name of the User",
        "A passing word", "Login Me Now");]]></programlisting>

            <para>
                The customized <classname>LoginForm</classname> is shown in <xref linkend="figure.components.loginform.customization"/>.
            </para>

            <figure xml:id="figure.components.loginform.customization">
                <title>Customizing the <classname>LoginForm</classname></title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/components/loginform-customization.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="120" smallscale="80%" align="center" fileref="img/components/loginform-customization.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>

        <simplesect>
            <title>Styling with CSS</title>

            <programlisting><?pocket-size 65% ?><![CDATA[.v-customcomponent {}
.v-customcomponent .v-embedded {}
.v-app-loginpage {}
.v-app-loginpage .v-textfield {}
.v-app-loginpage .v-button  {}]]></programlisting>

            <para>
                The <classname>LoginForm</classname> component is a purely server-side
                component that extends <classname>CustomComponent</classname> and
                therefore has a <literal>v-customcomponent</literal> base style. If you
                wish to do any styling for the component, you should give it a custom
                style name to distinguish it from the regular
                <classname>CustomComponent</classname>.
            </para>

            <para>
                The component contains an <literal>iframe</literal> in an element with
                <literal>v-embedded</literal> style. The other styles are defined in the
                static HTML code returned by the <methodname>getLoginHTML()</methodname>
                method. The default implementation reuses the styles of the
                <classname>TextField</classname> and <classname>Button</classname>
                components for the input fields and the button, that is,
                <literal>v-textfield</literal> and <literal>v-button</literal>. The root
                element has the same <literal>v-app</literal> style as a regular Vaadin
                application would have, and an additional
                <literal>v-app-loginpage</literal> style.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[...
+ "<div class='v-app v-app-loginpage'
        style=\"background:transparent;\">"
...
+ "<input class='v-textfield' ...
...
+ "<div><input class='v-textfield' ...
...
<div ... class='v-button' role='button'>]]></programlisting>
        </simplesect>
    </section>

	<section xml:id="components.customcomponent">
		<title>Component Composition with <classname>CustomComponent</classname></title>

		<!-- UNFINISHED: Check that this is up-to-date. Probably is. -->

		<para>
			The ease of making new user interface components is one of the core features
			of Vaadin. Typically, you simply combine existing built-in components to
			produce composite components. In many applications, such composite components
			make up the majority of the user interface.
		</para>

        <para>
            To create a composite component, you need to inherit the
            <classname>CustomComponent</classname> and call the
            <methodname>setCompositionRoot()</methodname> in the constructor to set the
            <emphasis>composition root</emphasis> component. The root component is
            typically a layout component that contains multiple components.
        </para>

        <para>
            For example:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[class MyComposite extends CustomComponent {
    public MyComposite(String message) {
        // A layout structure used for composition
        Panel panel = new Panel("My Custom Component");
        panel.setContent(new VerticalLayout());
        
        // Compose from multiple components
        Label label = new Label(message);
        label.setSizeUndefined(); // Shrink
        panel.addComponent(label);
        panel.addComponent(new Button("Ok"));

        // Set the size as undefined at all levels
        panel.getContent().setSizeUndefined();
        panel.setSizeUndefined();
        setSizeUndefined();

        // The composition root MUST be set
        setCompositionRoot(panel);
    }
}]]></programlisting>

        <para>
            Take note of the sizing when trying to make a customcomponent that shrinks to
            fit the contained components. You have to set the size as undefined at all
            levels; the sizing of the composite component and the composition root are
            separate.
        </para>

        <para>
            You can use the component as follows:
        </para>

        <programlisting><?pocket-size 65% ?><![CDATA[MyComposite mycomposite = new MyComposite("Hello");]]></programlisting>

        <para>
            The rendered component is shown in <xref
            linkend="figure.components.customcomponent"/>.
        </para>

		<figure xml:id="figure.components.customcomponent">
			<title>A Custom Composite Component</title>
			<mediaobject>
				<imageobject>
					<imagedata smallscale="140" align="center" fileref="img/components/customcomponent-example1.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
            You can also inherit any other components, such as layouts, to attain similar
            composition.

            <indexterm><primary>Google Web Toolkit</primary></indexterm>

            Even further, you can create entirely new low-level components, by integrating
            pure client-side components or by extending the client-side functionality of
            built-in components. Development of new components is covered in <xref
            linkend="gwt"/>.
		</para>
	</section>

</chapter>
	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
