<?xml version="1.0" encoding="UTF-8"?>
<!-- ====================================================================== -->
<!-- Copyright 2000-2012 Vaadin Ltd                                         -->
<!-- All Rights Reserved                                                    -->
<!-- This work is licensed under a Creative Commons Attribution-NoDerivs    -->
<!-- License (CC-BY-ND) Version 3.0. Full license text is available at:     -->
<!-- http://creativecommons.org/licenses/by-nd/3.0/legalcode                -->
<!-- ====================================================================== -->

<chapter xml:id="themes">
	<title>Themes</title>

    <indexterm xml:id="term.themes" class="startofrange">
        <primary>theme</primary>
    </indexterm>
    <indexterm xml:id="term.themes-css" class="startofrange">
        <primary>CSS</primary>
    </indexterm>

	<para>
		This chapter provides details about using and creating <emphasis>themes</emphasis>
		that control the visual look of web applications. Themes consist of Cascading
		Style Sheets (CSS) and other theme resources such as images. We provide an
		introduction to CSS, especially concerning the styling of HTML by element classes.
	</para>

    <para>
        <emphasis>This chapter is a draft. Many new features that will be included in the
        final version of Vaadin 7 are not yet covered in the draft and some of the content
        may be outdated. For the most current version, please see the on-line edition
        available at <uri>http://vaadin.com/book</uri>.</emphasis>
    </para>

	<section xml:id="themes.overview">
		<title>Overview</title>

		<para>
			Vaadin separates the appearance of the user interface from its logic using
			<emphasis>themes</emphasis>. Themes can include CSS style sheets, custom HTML
			layouts, and any necessary graphics. Theme resources can also be accessed from
			an application as <classname>ThemeResource</classname> objects.
		</para>

		<para>
			Custom themes are placed under the
			<filename>WebContent/VAADIN/themes/</filename> folder of the web application.
			This location is fixed -- the <filename>VAADIN</filename> folder specifies
			that these are static resources specific to Vaadin. The folder should normally
			contain also the built-in themes, although you can let them be loaded
			dynamically from the Vaadin JAR (even though that is somewhat inefficient).
			<xref linkend="figure.themes.theme-contents"/> illustrates the contents of a
			theme.
		</para>

		<figure xml:id="figure.themes.theme-contents">
			<title>Contents of a Theme</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/themes/theme-contents-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="60" smallscale="100%" align="center" fileref="img/themes/theme-contents-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The name of a theme folder defines the name of the theme. The name is used in
			the <literal>@Theme</literal> annotation that sets the theme. A theme must
			contain the <filename>styles.css</filename> stylesheet, but other contents
			have free naming. We suggest a convention for naming the folders as
			<filename>img</filename> for images, <filename>layouts</filename> for custom
			layouts, and <filename>css</filename> for additional stylesheets.
		</para>

		<para>
			Custom themes that use an existing complete theme need to inherit the
			theme. See <xref linkend="themes.creating.default"/> and <xref
			linkend="themes.creating.inheritance"/> for details on inheriting a
			theme. Copying and modifying a complete theme is also possible, but it may
			need more work to maintain if the modifications are small.
		</para>

		<para>
			You use a theme with by specifying it with the <literal>@Theme</literal>
			annotation for the &ui; class of the application as follows:
		</para>

		<programlisting><![CDATA[@Theme("mytheme")
public class MyRoot extends Root {
    @Override
    protected void init(WrappedRequest request) {
        ...
    }
}]]></programlisting>

		<para>
			A theme can contain alternate styles for user interface components, which can
			be changed as needed.
		</para>

		<para>
			In addition to style sheets, a theme can contain HTML templates for custom
			layouts used with <classname>CustomLayout</classname>. See <xref
			linkend="layout.customlayout"/> for details.
		</para>

		<para>
			Resources provided in a theme can also be accessed using the
			<classname>ThemeResource</classname> class, as described in <xref
			linkend="application.resources.theme"/>. This allows using theme resources, such
			as images, for example in <classname>Embedded</classname> objects and other
			objects that allow inclusion of images using resources.
		</para>
	</section>

	<section xml:id="themes.css">
		<title>Introduction to Cascading Style Sheets</title>
		
        <indexterm xml:id="term.themes.css" class="startofrange">
            <primary>CSS</primary>
            <secondary>introduction</secondary>
        </indexterm>

		<para>
			Cascading Style Sheets or CSS is a technique to separate the appearance of a
			web page from the content represented in HTML or XHTML. Let us give a short
			introduction to Cascading Style Sheets and look how they are relevant to
			software development with Vaadin.
		</para>

		<section>
			<title>Basic CSS Rules</title>

			<para>
				A style sheet is a file that contains a set of
				<emphasis>rules</emphasis>. Each rule consists of one or more
				<emphasis>selectors</emphasis>, separated with commas, and a
				<emphasis>declaration block</emphasis> enclosed in curly braces. A
				declaration block contains a list of <emphasis>property</emphasis>
				statements. Each property has a label and a value, separated with a
				colon. A property statement ends with a semicolon.
			</para>

			<para>
				Let us look at an example:
			</para>

			<programlisting><![CDATA[p, td { 
  color: blue;
}

td { 
  background: yellow;
  font-weight: bold;
}]]></programlisting>

			<para>
				In the example above, <literal>p</literal> and <literal>td</literal> are
				element type selectors that match with <literal>&lt;p&gt;</literal> and
				<literal>&lt;td&gt;</literal> elements in HTML, respectively. The first
				rule matches with both elements, while the second matches only with
				<literal>&lt;td&gt;</literal> elements. Let us assume that you have saved
				the above style sheet with the name <filename>mystylesheet.css</filename> and
				consider the following HTML file located in the same folder.
			</para>

			<programlisting>&lt;html&gt;
    &lt;head&gt;
        &lt;link rel="stylesheet" type="text/css"
              href="mystylesheet.css"/&gt;
    &lt;/head&gt;
    &lt;body&gt;
        <emphasis role="strong">&lt;p&gt;</emphasis>This is a paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>
        <emphasis role="strong">&lt;p&gt;</emphasis>This is another paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>
        &lt;table&gt;
            &lt;tr&gt;
                <emphasis role="strong">&lt;td&gt;</emphasis>This is a table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
                <emphasis role="strong">&lt;td&gt;</emphasis>This is another table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
            &lt;/tr&gt;
        &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>

			<para>
				The <literal>&lt;link&gt;</literal> element defines the style sheet to
				use. The HTML elements that match the above rules are emphasized. When the
				page is displayed in the browser, it will look as shown in the figure
				below.
			</para>

			<figure xml:id="figure.themes.basic.1">
				<title>Simple Styling by Element Type</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/themes/themes-css-match-1.png"/>
					</imageobject>
				</mediaobject>
			</figure>
				
			<para>
				CSS has an <emphasis>inheritance</emphasis> mechanism where contained
				elements inherit the properties of their parent elements. For example, let
				us change the above example and define it instead as follows:
			</para>

			<programlisting><![CDATA[table {
    color: blue;
    background: yellow;
}]]></programlisting>

			<para>
				All elements contained in the <literal>&lt;table&gt;</literal> element
				would have the same properties. For example, the text in the contained
				<literal>&lt;td&gt;</literal> elements would be in blue color.
			</para>

			<para>
				Each HTML element type accepts a certain set of properties. The
				<literal>&lt;div&gt;</literal> elements are generic elements that can be
				used to create almost any layout and formatting that can be created with a
				specific HTML element type. Vaadin uses
				<literal>&lt;div&gt;</literal> elements extensively, especially for
				layouts.
			</para>

			<para>
                <indexterm><primary>Google Web Toolkit</primary><secondary>themeing</secondary></indexterm>

				Matching elements by their type is, however, rarely if ever used in style
				sheets for Vaadin components or Google Web Toolkit widgets.
			</para>
		</section>

		<section>
			<title>Matching by Element Class</title>

			<para>
				Matching HTML elements by the <emphasis>class</emphasis> attribute of the
				elements is the most relevant form of matching with Vaadin. It is
				also possible to match with the <emphasis>identifier</emphasis> of a HTML
				element.
			</para>

			<para>
				The class of an HTML element is defined with the
				<parameter>class</parameter> attribute as follows:
			</para>

<programlisting><?pocket-size 70% ?>&lt;html&gt;
  &lt;body&gt;
    <emphasis role="strong">&lt;p class="normal"&gt;</emphasis>This is the first paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>

    <emphasis role="strong">&lt;p class="another"&gt;</emphasis>This is the second paragraph<emphasis role="strong">&lt;/p&gt;</emphasis>

    &lt;table&gt;
      &lt;tr&gt;
        <emphasis role="strong">&lt;td class="normal"&gt;</emphasis>This is a table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
        <emphasis role="strong">&lt;td class="another"&gt;</emphasis>This is another table cell<emphasis role="strong">&lt;/td&gt;</emphasis>
      &lt;/tr&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</programlisting>

			<para>
				The class attributes of HTML elements can be matched in CSS rules with a
				selector notation where the class name is written after a period following
				the element name. This gives us full control of matching elements by their
				type and class.
			</para>

			<programlisting><![CDATA[p.normal   {color: red;}
p.another  {color: blue;}
td.normal  {background: pink;}
td.another {background: yellow;}]]></programlisting>

			<para>
				The page would look as shown below:
			</para>

			<figure>
				<title>Matching HTML Element Type and Class</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/themes/themes-css-match-class-2.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="75" smallscale="100%" align="center" fileref="img/themes/themes-css-match-class-2.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				We can also match solely by the class by using the universal selector
				<literal>*</literal> for the element name, for example
				<literal>*.normal</literal>. The universal selector can also be left out
				altogether so that we use just the class name following the period, for
				example <literal>.normal</literal>.
			</para>

			<programlisting><![CDATA[.normal {
    color: red;
}

.another {
    blackground: yellow;
}]]></programlisting>

			<para>
				In this case, the rule will match with all elements of the same class
				regardless of the element type. The result is shown in <xref
				linkend="figure.themes.match.class"/>.  This example illustrates a
				technique to make style sheets compatible regardless of the exact HTML
				element used in drawing a component.
			</para>

			<figure xml:id="figure.themes.match.class">
				<title>Matching Only HTML Element Class</title>
				<mediaobject>
					<imageobject role="html">
						<imagedata align="center" fileref="img/themes/themes-css-match-class-3.png"/>
					</imageobject>
					<imageobject role="fo">
						<imagedata scale="65" smallscale="100%" align="center" fileref="img/themes/themes-css-match-class-3.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
				To assure compatibility, we recommend that you use only matching based on
				the element classes and <emphasis>do not</emphasis> match for specific
				HTML element types in CSS rules, because either Vaadin or GWT
				may use different HTML elements to render some components in the
				future. For example, IT Mill Toolkit Release 4 used
				<literal>&lt;div&gt;</literal> elements extensively for layout
				components. However, IT Mill Toolkit Release 5 and Vaadin use GWT to render the components, and GWT
				uses the <literal>&lt;table&gt;</literal> element to implement most
				layouts. Similarly, IT Mill Toolkit Release 4 used <literal>&lt;div&gt;</literal> element
				also for buttons, but in Release 5, GWT uses the
				<literal>&lt;button&gt;</literal> element. Vaadin has little control over
				how GWT renders its components, so we can not guarantee compatibility in
				different versions of GWT. However, both <literal>&lt;div&gt;</literal>
				and <literal>&lt;table&gt;</literal> as well as
				<literal>&lt;tr&gt;</literal> and <literal>&lt;td&gt;</literal> elements
				accept most of the same properties, so matching only the class hierarchy
				of the elements should be compatible in most cases.
			</para>
		</section>

		<section>
			<title>Matching by Descendant Relationship</title>

			<para>
				CSS allows matching HTML by their containment relationship. For example,
				consider the following HTML fragment:
			</para>

			<programlisting><?pocket-size 70% ?>&lt;body&gt;
  &lt;p class="mytext"&gt;Here is some text inside a
                    paragraph element&lt;/p&gt;
  &lt;table class="<emphasis role="strong">mytable</emphasis>"&gt;
    &lt;tr&gt;
      &lt;td class="<emphasis role="strong">mytext</emphasis>"&gt;Here is text inside
                      a table and inside a td element.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
&lt;/body&gt;</programlisting>

			<para>
				Matching by the class name <literal>.mytext</literal> alone would match
				both the <literal>&lt;p&gt;</literal> and <literal>&lt;td&gt;</literal>
				elements. If we want to match only the table cell, we could use the following selector:
			</para>

			<programlisting><![CDATA[.mytable .mytext {color: blue;}]]></programlisting>

			<para>
				To match, a class listed in a rule does not have to be an immediate
				descendant of the previous class, but just a descendant. For example, the
				selector "<literal>.v-panel .v-button</literal>" would match all elements
				with class <literal>.v-button</literal> somewhere inside an element with
				class <literal>.v-panel</literal>.
			</para>

			<para>
				Let us give an example with a real case. Consider the following Vaadin
				component.
			</para>

			<programlisting><?pocket-size 75% ?><![CDATA[public class LoginBox extends CustomComponent {
    Panel         panel  = new Panel("Log In");

    public LoginBox () {
        setCompositionRoot(panel);
        
        panel.addComponent(new TextField("Username:"));
        panel.addComponent(new TextField("Password:"));
        panel.addComponent(new Button("Login"));
    }
}]]></programlisting>
			
			<para>
				The component will look by default as shown in the following figure.
			</para>

			<figure xml:id="figure.themes.example.login.1">
				<title>Themeing Login Box Example with 'runo' theme.</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/themes/example-login-default.png"/>
					</imageobject>
				</mediaobject>
			</figure>

			<para>
					Now, let us look at the HTML structure of the component. The following
					listing assumes that the application contains only the above component
					in the main window of the application.
				</para>

			<programlisting><?pocket-size 70% ?>&lt;body&gt;
   &lt;div id="v-app"&gt;
    &lt;div&gt;
       &lt;div class="<emphasis role="strong">v-orderedlayout</emphasis>"&gt;
        &lt;div&gt;
           &lt;div class="<emphasis role="strong">v-panel</emphasis>"&gt;
            &lt;div class="<emphasis role="strong">v-panel-caption</emphasis>"&gt;<emphasis>Log In</emphasis>&lt;/div&gt;
            &lt;div class="<emphasis role="strong">v-panel-content</emphasis>"&gt;
               &lt;div class="<emphasis role="strong">v-orderedlayout</emphasis>"&gt;
                &lt;div&gt;
                   &lt;div&gt;
                    &lt;div class="<emphasis role="strong">v-caption</emphasis>"&gt;
                      &lt;span&gt;<emphasis>Username:</emphasis>&lt;/span&gt;
                    &lt;/div&gt;
                   &lt;/div&gt;
                   &lt;input type="text" <emphasis role="strong">class="v-textfield</emphasis>"/&gt;
                &lt;/div&gt;
                &lt;div&gt;
                   &lt;div&gt;
                    &lt;div class="<emphasis role="strong">v-caption</emphasis>"&gt;
                      &lt;span&gt;<emphasis>Password:</emphasis>&lt;/span&gt;
                    &lt;/div&gt;
                   &lt;/div&gt;
                   &lt;input type="password"
                          class="v-textfield"/&gt;
                &lt;/div&gt;
                &lt;div&gt;
                  &lt;button type="button"
                          class="<emphasis role="strong">v-button</emphasis>"&gt;<emphasis>Login</emphasis>&lt;/button&gt;
                  &lt;/div&gt;
               &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class="<emphasis role="strong">v-panel-deco</emphasis>"/&gt;
            &lt;/div&gt;
           &lt;/div&gt;
        &lt;/div&gt;
       &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;</programlisting>

				<para>
					Now, consider the following theme where we set the backgrounds of
					various elements.
				</para>

		<programlisting><![CDATA[.v-panel .v-panel-caption {
	background: #80ff80; /* pale green */
}

.v-panel .v-panel-content {
	background: yellow;
}

.v-panel .v-textfield {
	background: #e0e0ff; /* pale blue */
}

.v-panel .v-button {
	background: pink;
}]]></programlisting>

			<para>
				The coloring has changed as shown in the following figure.
			</para>
			
			<figure xml:id="figure.themes.example.mytheme.1">
				<title>Themeing Login Box Example with Custom Theme</title>
				<mediaobject>
					<imageobject>
						<imagedata smallscale="120" align="center" fileref="img/themes/example-login-mytheme.png"/>
					</imageobject>
				</mediaobject>
			</figure>
			
			<para>
				An element can have multiple classes separated with a space. With multiple
				classes, a CSS rule matches an element if any of the classes match. This
				feature is used in many Vaadin components to allow matching based
				on the state of the component. For example, when the mouse is over a
				<classname>Link</classname> component, <literal>over</literal> class is
				added to the component. Most of such styling is a feature of Google Web
				Toolkit.
				</para>
		</section>
			
		<section>
			<title>Notes on Compatibility</title>

            <indexterm><primary>CSS</primary><secondary>compatibility</secondary></indexterm>
            <indexterm><primary>compatibility</primary></indexterm>

			<para>
				CSS was first proposed in 1994. The specification of CSS is maintained by
				the CSS Working Group of World Wide Web Consortium (W3C). Its versions are
				specified as <emphasis>levels</emphasis> that build upon the earlier
				version. CSS Level 1 was published in 1996, Level 2 in 1998. Development
				of CSS Level 3 was started in 1998 and is still under way.
			</para>

			<para>
				While the support for CSS has been universal in all graphical web browsers
				since at least 1995, the support has been very incomplete at times and
				there still exists an unfortunate number of incompatibilities between
				browsers. While we have tried to take these incompatibilities into account
				in the built-in themes in Vaadin, you need to consider them while
				developing custom themes.
			</para>

			<para>
				Compatibility issues are detailed in various CSS handbooks.
			</para>
		</section>
		
        <indexterm startref="term.themes.css" class="endofrange"/>
	</section>
	
	<section xml:id="themes.creating">
		<title>Creating and Using Themes</title>

		<para>
			Custom themes are placed in <filename>VAADIN/themes</filename> folder of the
			web application (in the <filename>WebContent</filename> directory) as
			illustrated in <xref linkend="figure.themes.theme-contents"/>. This location
			is fixed. You need to have a theme folder for each theme you use in your
			application, although applications rarely need more than a single theme. For
			example, if you want to define a theme with the name <varname>mytheme</varname>,
			you will place it in folder <filename>VAADIN/themes/mytheme</filename>.
		</para>

		<para>
			A custom theme must also inherit a built-in theme, as shown in the example
			below:
		</para>

		<programlisting><![CDATA[@import "../reindeer/styles.css";

.v-app {
    background: yellow;
}]]></programlisting>

        <para>
            Vaadin 6.0 includes two built-in themes: <literal>reindeer</literal> and
            <literal>runo</literal>. The latter is a compatibility theme for IT Mill
            Toolkit 5; there is no longer a "default" theme. See <xref
            linkend="themes.creating.default"/> and <xref
            linkend="themes.creating.inheritance"/> below for details on inheriting
            themes.
		</para>

		<section>
			<title>Styling Standard Components</title>

			<para>
				Each user interface component in Vaadin has a CSS style class that you can
				use to control the appearance of the component. Some components have
				additional sub-elements that also allow styling.
			</para>

			<para>
				<xref linkend="themes.creating.component-styles"/> lists the style classes
				of all Vaadin components, together with their client-side widgets. Notice
				that a single server-side component can have multiple client-side
				implementations. For example, a <classname>Button</classname> can be
				rendered on the client side either as a regular button or a check box,
				depending on the <parameter>switchMode</parameter> attribute of the
				button. For details regarding the mapping to client-side components, see
				<xref linkend="clientside.module.stylesheet"/>. Each client-side component
				type has its own style class and a number of additional classes that
				depend on the client-side state of the component. For example, a text
				field will have <literal>v-textfield-focus</literal> class when mouse
				pointer hovers over the component. This state is purely on the client-side
				and is not passed to the server.
			</para>

            <!-- TODO: Update. -->
				<table xml:id="themes.creating.component-styles">
					<title>Default CSS Style Names of Vaadin Components</title>
				    <!-- ?dbfo table-width="7cm" ? -->

					<tgroup cols="3" align="left">
						<thead>
							<row valign="top">
								<entry>Server-Side Component</entry>
								<entry>Client-Side Widget</entry>
								<entry>CSS Class Name</entry>
							</row>
						</thead>
						<tbody>
							<row valign="top">
								<entry>AbsoluteLayout</entry>
								<entry>VAbsoluteLayout</entry>
								<entry>v-absolutelayout</entry>
							</row>
							<row valign="top">
								<entry>Accordion</entry>
								<entry>VAccordion</entry>
								<entry>v-accordion</entry>
							</row>
							<row valign="top">
								<entry>Button</entry>
								<entry>VButton</entry>
								<entry>v-button</entry>
							</row>
							<row valign="top">
								<entry>CheckBox</entry>
								<entry>VCheckBox</entry>
								<entry>v-checkbox</entry>
							</row>
							<row valign="top">
								<entry>CssLayout</entry>
								<entry>VCssLayout</entry>
								<entry>v-csslayout</entry>
							</row>
							<row valign="top">
								<entry>CustomComponent</entry>
								<entry>VCustomComponent</entry>
								<entry>v-customcomponent</entry>
							</row>
							<row valign="top">
								<entry>CustomLayout</entry>
								<entry>VCustomLayout</entry>
								<entry>v-customlayout</entry>
							</row>
							<row valign="top">
								<entry morerows="4">DateField</entry>
								<entry>VDateField</entry>
								<entry>v-datefield</entry>
							</row>
                            <!-- TODO: Check -->
							<row valign="top">
								<entry>VCalendar</entry>
								<entry>v-datefield-entrycalendar</entry>
							</row>
                            <!-- TODO: Check -->
							<row valign="top">
								<entry>VDateFieldCalendar</entry>
								<entry>v-datefield-calendar</entry>
							</row>
                            <!-- TODO: Check -->
							<row valign="top">
								<entry>VPopupCalendar</entry>
								<entry>v-datefield-calendar</entry>
							</row>
							<row valign="top">
								<entry>VTextualDate</entry>
								<entry></entry>
							</row>
							<row valign="top">
								<entry>Embedded</entry>
								<entry>VEmbedded</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>Form</entry>
								<entry>VForm</entry>
								<entry>v-form</entry>
							</row>
							<row valign="top">
								<entry>FormLayout</entry>
								<entry>VFormLayout</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>GridLayout</entry>
								<entry>VGridLayout</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>Label</entry>
								<entry>VLabel</entry>
								<entry>v-label</entry>
							</row>
							<row valign="top">
								<entry>Link</entry>
								<entry>VLink</entry>
								<entry>v-link</entry>
							</row>
							<row valign="top">
								<entry>OptionGroup</entry>
								<entry>VOptionGroup</entry>
								<entry>v-select-optiongroup</entry>
							</row>
							<row valign="top">
								<entry>HorizontalLayout</entry>
								<entry>VHorizontalLayout</entry>
								<entry>v-horizontallayout</entry>
							</row>
							<row valign="top">
								<entry>VerticalLayout</entry>
								<entry>VVerticalLayout</entry>
								<entry>v-verticallayout</entry>
							</row>
							<row valign="top">
								<entry>Panel</entry>
								<entry>VPanel</entry>
								<entry>v-panel</entry>
							</row>
							<row valign="top">
								<entry morerows="2">Select</entry>
								<entry></entry>
								<entry></entry>
							</row>
							<row valign="top">
								<entry>VListSelect</entry>
								<entry>v-listselect</entry>
							</row>
							<row valign="top">
								<entry>VFilterSelect</entry>
								<entry>v-filterselect</entry>
							</row>
							<row valign="top">
								<entry>Slider</entry>
								<entry>VSlider</entry>
								<entry>v-slider</entry>
							</row>
							<row valign="top">
								<entry morerows="2">SplitPanel</entry>
								<entry>VSplitPanel</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>VSplitPanelHorizontal</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>VSplitPanelVertical</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry morerows="1">Table</entry>
								<entry>VScrollTable</entry>
								<entry>v-table</entry>
							</row>
							<row valign="top">
								<entry>VTablePaging</entry>
								<entry>v-table</entry>
							</row>
							<row valign="top">
								<entry>TabSheet</entry>
								<entry>VTabSheet</entry>
								<entry>v-tabsheet</entry>
							</row>
							<row valign="top">
								<entry morerows="2">TextField</entry>
								<entry>VTextField</entry>
								<entry>v-textfield</entry>
							</row>
							<row valign="top">
								<entry>VTextArea</entry>
								<entry></entry>
							</row>
							<row valign="top">
								<entry>VPasswordField</entry>
								<entry></entry>
							</row>
							<row valign="top">
								<entry>Tree</entry>
								<entry>VTree</entry>
								<entry>v-tree</entry>
							</row>
							<row valign="top">
								<entry>TwinColSelect</entry>
								<entry>VTwinColSelect</entry>
								<entry>v-select-twincol</entry>
							</row>
							<row valign="top">
								<entry>Upload</entry>
								<entry>VUpload</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>Window</entry>
								<entry>VWindow</entry>
								<entry>v-window</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>CalendarEntry</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>CalendarPanel</entry>
								<entry>v-datefield-calendarpanel</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>ContextMenu</entry>
								<entry>v-contextmenu</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>VUnknownComponent</entry>
								<entry>vaadin-unknown</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>VView</entry>
								<entry>-</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>Menubar</entry>
								<entry>gwt-MenuBar</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>MenuItem</entry>
								<entry>gwt-MenuItem</entry>
							</row>
							<row valign="top">
								<entry>-</entry>
								<entry>Time</entry>
								<entry>v-datefield-time</entry>
							</row>
						</tbody>
				</tgroup>
			</table>
			
			<para>
				Please see the documentation of the particular components for a listing of possible sub-component styles.
			</para>

			<para>
				Some client-side components can be shared by different server-side
				components. There is also the
				<classname>VUnknownComponent</classname>, which is a component that
				indicates an internal error in a situation where the server asked to
				render a component which is not available on the client-side.
			</para>
		</section>

		<section xml:id="themes.creating.default">
			<title>Built-in Themes</title>

			<para>
				Vaadin currently includes two built-in themes: <literal>reindeer</literal>
				and <literal>runo</literal>. The default theme in Vaadin 6 and 7 is
				<literal>reindeer</literal>. The <literal>runo</literal> was the default
				theme for IT Mill Toolkit 5 (where its name was "default").
			</para>
					
			<para>
				The built-in themes are provided in the respective
				<filename>VAADIN/themes/reindeer/styles.css</filename> and
				<filename>VAADIN/themes/runo/styles.css</filename> stylesheets in the
				Vaadin library JAR. These stylesheets are compilations of the separate
				stylesheets for each component in the corresponding subdirectory. The
				stylesheets are compiled to a single file for efficiency: the browser
				needs to load just a single file.
			</para>

            <para>
                Various constants related to the built-in themes are defined in the theme
                classes in <package>com.vaadin.ui.themes</package> package. These are
                mostly special style names for specific components.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[@Theme("runo")
public class MyRoot extends Root {
    @Override
    protected void init(WrappedRequest request) {
        ...      
        Panel panel = new Panel("Regular Panel in the Runo Theme");
        panel.addComponent(new Button("Regular Runo Button"));
        
        // A button with the "small" style
        Button smallButton = new Button("Small Runo Button");
        smallButton.addStyleName(Runo.BUTTON_SMALL);

        Panel lightPanel = new Panel("Light Panel");
        lightPanel.addStyleName(Runo.PANEL_LIGHT);
        lightPanel.addComponent(new Label("With addStyleName(\"light\")"));
        ...]]></programlisting>

            <para>
                The example with the Runo theme is shown in <xref linkend="figure.themes.creating.default.runo"/>.
            </para>
					
            <figure xml:id="figure.themes.creating.default.runo">
                <title>Runo Theme</title>
                <mediaobject>
                    <imageobject>
                        <imagedata smallscale="100%" align="center" fileref="img/themes/builtin-runo.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

			<note>
				<title>Serving Built-In Themes Statically</title>

				<para>
					The built-in themes included in the Vaadin library JAR are served
					dynamically from the JAR by the servlet. Serving themes and widget
					sets statically by the web server is more efficient. You only need to
					extract the <filename>VAADIN/</filename> directory from the JAR under
					your <filename>WebContent</filename> directory. Just make sure to
					update it if you upgrade to a newer version of Vaadin.
				</para>
			</note>

			<para>
				Creation of a default theme for custom GWT widgets is described in <xref
				linkend="gwt.styling"/>.
			</para>
		</section>

		<section xml:id="themes.creating.using">
			<title>Using Themes</title>

			<para>
				Using a theme is simple, you just set it for a
				<classname>&uiclass;</classname> class with the
				<literal>@Theme</literal> annotation.
			</para>
		</section>

		<section xml:id="themes.creating.inheritance">
			<title>Theme Inheritance</title>

			<para>
				When you define your own theme, you will need to inherit a built-in theme
				(unless you just copy the built-in theme, which is not recommended).
			</para>

			<para>
				Inheritance in CSS is done with the <literal>@import</literal>
				statement. In the typical case, when you define your own theme, you
				inherit a built-in theme as follows:
			</para>

			<programlisting><![CDATA[@import "../reindeer/styles.css";

.v-app {
    background: yellow;
}]]></programlisting>

			<para>
				You can even create a deep hierarchy of themes by inheritance.
			</para>
		</section>
	</section>

	<section xml:id="themes.sass">
		<title>Themeing with Sass</title>

        <para>
            In addition to plain CSS, you can write Vaadin themes with Sass. Sass adds
            nested rules, variables, mixins, selector inheritance, and other features to
            CSS3. Sass can be used in two basic ways, either by compiling SCSS files to
            CSS or by doing the compilation on the fly.
        </para>

        <section xml:id="themes.sass.basic">
            <title>Sass Basics with Vaadin</title>

            <para>
                We are not going to give in-depth documentation of Sass and refer you to
                its excellent documentation at <link
                xlink:href="http://sass-lang.com/">http://sass-lang.com/</link>. In the
                following, we give just basic introduction to using it with Vaadin.
            </para>

            <para>
                You can create a new Sass-based theme with the Eclipse plugin, as
                described in <xref linkend="themes.eclipse"/>.
            </para>
        </section>

        <section xml:id="themes.sass.servlet">
            <title>Compiling On the Fly</title>

            <para>
                The easiest way to use Sass themes is to let the Vaadin servlet compile
                them on the run. In this case, the SCSS source files are placed in the
                theme folder.
            </para>
        </section>

        <section xml:id="themes.sass.compiling">
            <title>Compiling SASS to CSS</title>

            <para>
                Sass style sheets can be compiled to CSS, with the
                <filename>styles.css</filename> of a custom theme as the compilation
                target. When compiled before deployment, the source files do not need to
                be in the theme folder.
            </para>
        </section>
    </section>

	<section xml:id="themes.eclipse">
		<title>Creating a Theme in Eclipse</title>

		<para>
			The Eclipse plugin provides a wizard for creating custom themes. Do the
			following steps to create a new theme.
		</para>

		<orderedlist>
			<listitem>
				<para>
					Select
					<menuchoice><guimenu>File</guimenu><guisubmenu>New</guisubmenu><guimenuitem>Other...</guimenuitem></menuchoice>
					in the main menu or right-click the <guilabel>Project
					Explorer</guilabel> and select
					<menuchoice><guimenu>New</guimenu><guimenuitem>Other...</guimenuitem></menuchoice>. A
					window will open.
				</para>
			</listitem>

			<listitem>
				<para>
					In the <guilabel>Select a wizard</guilabel> step, select the
					<menuchoice><guimenu>Vaadin</guimenu><guimenuitem>Vaadin
					Theme</guimenuitem></menuchoice> wizard.
				</para>

				<screenshot>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/themes/eclipse-theme-new.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-new.png"/>
						</imageobject>
					</mediaobject>
				</screenshot>
				
				<para>
					Click <guibutton>Next</guibutton> to proceed to the next step.
				</para>
			</listitem>

			<listitem>
				<para>
					In the <guilabel>Create a new Vaadin theme</guilabel> step, you have
					the following settings:
				</para>

				<variablelist>
					<varlistentry>
						<term><guilabel>Project</guilabel> (mandatory)</term>
						<listitem>
							<para>
								The project in which the theme should be created.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><guilabel>Theme name</guilabel> (mandatory)</term>
						<listitem>
							<para>
								The theme name is used as the name of the theme folder and
								in a CSS tag (prefixed with
								"<literal>v-theme-</literal>"), so it must be a proper
								identifier. Only latin alphanumerics, underscore, and
								minus sign are allowed.
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><guilabel>Modify application classes to use theme</guilabel> (optional)</term>
						<listitem>
							<para>
								The setting allows the wizard to write a code statement
								that enables the theme in the constructor of the selected
								application class(es). If you need to control the theme
								with dynamic logic, you can leave the setting unchecked or
								change the generated line later.
							</para>
						</listitem>
					</varlistentry>
				</variablelist>

				<screenshot>
					<mediaobject>
						<imageobject role="html">
							<imagedata align="center" fileref="img/themes/eclipse-theme-settings.png"/>
						</imageobject>
						<imageobject role="fo">
							<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-settings.png"/>
						</imageobject>
					</mediaobject>
				</screenshot>

				<para>
					Click <guibutton>Finish</guibutton> to create the theme.
				</para>

			</listitem>
		</orderedlist>

		<para>
			The wizard creates the theme folder under the
			<filename>WebContent/VAADIN/themes</filename> folder and the actual style
			sheet as <filename>styles.css</filename>, as illustrated in <xref
			linkend="figure.eclipse.theme.created"/>.
		</para>

		<figure xml:id="figure.eclipse.theme.created">
			<title>Newly Created Theme</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/themes/eclipse-theme-created-annotated-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="50" smallscale="100%" align="center" fileref="img/themes/eclipse-theme-created-annotated-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

		<para>
			The created theme inherits a built-in base theme with an
			<literal>@import</literal> statement. See the explanation of theme inheritance
			in <xref linkend="themes.creating"/>. Notice that the
			<filename>reindeer</filename> theme is not located in the
			<filename>widgetsets</filename> folder, but in the Vaadin JAR. See <xref
			linkend="themes.creating.default"/> for information for serving the built-in
			themes.
		</para>

		<para>
			If you selected an application class or classes in the <guilabel>Modify
			application classes to use theme</guilabel> in the theme wizard, the wizard
			will add the <literal>@Theme</literal> annotation to the application &ui;
			class.
        </para>

		<para>
			If you later rename the theme in Eclipse, notice that changing the name of the
			folder will not automatically change the <literal>@Theme</literal>
			annotation. You need to change such references to theme names in the calls
			manually.
		</para>
	</section>

<!--
	<section>
		<title>Theme structure</title>
		<para></para>
	</section>
	<section>
		<title>Custom layouts</title>
		<para></para>
	</section>
	<section>
		<title>Variable handling</title>
		<para></para>
	</section>
	<section>
		<title>AJAX Themes</title>
		<para></para>
	</section>
	<section>
		<title>AJAX Adapter</title>
		<para></para>
	</section>
-->

    <indexterm startref="term.themes" class="endofrange"/>
    <indexterm startref="term.themes-css" class="endofrange"/>
</chapter>

	
<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

