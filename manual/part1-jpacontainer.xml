<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="jpacontainer">
    <title>Vaadin JPAContainer</title>

    <indexterm xml:id="term.jpacontainer" class="startofrange">
        <primary>JPAContainer</primary>
    </indexterm>

    <para>
        This chapter describes the use of the Vaadin JPAContainer add-on.
    </para>

    <para>
        <emphasis></emphasis>
    </para>

    <section xml:id="jpacontainer.overview">
        <title>Overview</title>

        <para>
            Vaadin JPAContainer add-on makes it possible to bind user interface components
            to a database easily using the Java Persistence API (JPA). It is an
            implementation of the <interfacename>Container</interfacename> interface
            described in <xref linkend="datamodel.container"/>.

            It supports a typical three-layer application
            architecture with an intermediate <emphasis>domain model</emphasis> between
            the user interface and the data access layer.
        </para>

		<figure xml:id="figure.jpacontainer.overview.architecture">
			<title>Three-Layer Architecture Using JPAContainer And JPA</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/three-layer-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/three-layer-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            The role of Java Persistence API is to handle persisting the domain model in
            the database. The database is typically a relational database. Vaadin
            JPAContainer binds the user interface components to the domain model and
            handles database access with JPA transparently.
        </para>

        <para>
            JPA is really just an API definition and has many alternative
            implementations. Vaadin JPAContainer supports especially EclipseLink, which is
            the reference implementation of JPA, and Hibernate. Any other compliant
            implementation should work just as well. The architecture of an application
            using JPAContainer is shown in <xref
            linkend="figure.jpacontainer.overview.detailed-architecture"/>.
        </para>

		<figure xml:id="figure.jpacontainer.overview.detailed-architecture">
			<title>JPAContainer Architecture</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/detailed-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/detailed-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Vaadin JPAContainer also plays together with the Vaadin Bean Validation
            add-on, which brings Java Bean Validation (JSR 303) to Vaadin applications.
        </para>

        <simplesect xml:id="jpacontainer.overview.jpa">
            <title>Java Persistence API</title>

            <para>
                Java Persistence API (JPA) is an API for object-relational mapping (ORM)
                of Java objects to a relational database. In JPA and entity-relationship
                modeling in general, a Java class is considered an
                <emphasis>entity</emphasis>. Class (or entity) instances correspond with a
                row in a database table and member variables of a class with
                columns. Entities can also have relationships with other entities.
            </para>

            <para>
                The object-relational mapping is illustrated in <xref
                linkend="figure.jpacontainer.overview.jpa.orm"/> with two entities with a
                one-to-many relationship.
            </para>

            <figure xml:id="figure.jpacontainer.overview.jpa.orm">
                <title>Object-Relational Mapping</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/jpacontainer/jpa-mapping-graphic-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/jpa-mapping-graphic-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The entity relationships are declared with metadata. With Vaadin
                JPAContainer, you provide the metadata with annotations in the entity
                classes. The JPA implementation uses reflection to read the annotations
                and defines a database model automatically from the class
                definitions. Definition of the domain model and the annotations are
                described in <xref linkend="jpacontainer.domain-model.annotation"/>.
            </para>

            <para>
                Vaadin JPAContainer supports JPA 2.0 (JSR 317). 
            </para>
        </simplesect>

        <simplesect xml:id="jpacontainer.overview.documentation">
            <title>Documentation and Support</title>

            <para>
                In addition to this chapter in the book, the installation package includes
                the following documentation about JPAContainer:
            </para>

            <itemizedlist>
                <listitem><para>API Documentation</para></listitem>
                <listitem><para>JPAContainer Tutorial</para></listitem>
                <listitem><para>JPAContainer AddressBook Demo</para></listitem>
                <listitem><para>JPAContainer Demo</para></listitem>
            </itemizedlist>
        </simplesect>
    </section>

    <section xml:id="jpacontainer.installation">
        <title>Installing</title>

        <para>
            Vaadin JPAContainer can be installed either as an installation package,
            downloaded from the Vaadin Directory, or as a Maven dependency. You can also
            create a new JPAContainer-enabled Vaadin project using a Maven archetype.
        </para>

        <section xml:id="jpacontainer.installation.download">
            <title>Downloading the Package</title>

            <para>
                Vaadin JPAContainer is available for download from the <link
                xlink:href="http://vaadin.com/directory">Vaadin Directory</link>.  Please
                see <xref linkend="addons.downloading"/> for basic instructions for
                downloading from Directory. The download page also gives the dependency
                declaration needed for retrieving the library with Maven.
            </para>

            <para>
                JPAContainer is a purely server-side component, so it does not include a
                widget set that you would need to compile.
            </para>

            <simplesect xml:id="jpacontainer.installation.download.license">
                <title>Choosing the License</title>

                <para>
                    Vaadin JPAContainer is available under two licenses: Affero General
                    Public License (AGPL) and Commercial Vaadin Add-on License (CVAL). If
                    your project is compatible with the open-source AGPL, you can use the
                    add-on for free. Otherwise you must acquire a sufficient number of
                    CVAL licenses before the 30-day trial period ends. Vaadin JPAContainer
                    is distributed as a separate installation package for each license.
                </para>

                <para>
                    Use of Vaadin JPAContainer with the CVAL license is included in the
                    Vaadin PRO subscription.
                </para>
            </simplesect>
        </section>

        <section xml:id="jpacontainer.installation.package">
            <title>Installation Package Content</title>

            <para>
                Once extracted to a local folder, the contents of the installation
                directory are illustrated in Figure 4.
            </para>

Figure 4: Installation Package Contents

            <para>
                The files in the installation package are as follows:
            </para>

            <variablelist>
                <varlistentry>
                    <term><filename>README</filename></term>
                    <listitem>
                        <para>
                            A readme file describing the package contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>licensing.txt</filename></term>
                    <listitem>
                        <para>
                            General information about licensing of JPAContainer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>license-xxxx-y.y.txt</filename></term>
                    <listitem>
                        <para>
                            The full license text for the library.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>vaadin-jpacontainer-xxxx-y.y-z.z.z.jar</filename></term>
                    <listitem>
                        <para>
                            The actual Vaadin JPAContainer library. The xxxx is the
                            license name and y.y its version number. The final z.z.z is
                            the version number of the Vaadin JPAContainer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>vaadin-jpacontainer-xxxx-y.y-z.z.z-javadoc.jar</filename></term>
                    <listitem>
                        <para>
                            JavaDoc documentation JAR for the library. You can use it for
                            example in Eclipse by associating the JavaDoc JAR with the
                            JPAContainer JAR in the build path settings of your project.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>apidocs</filename></term>
                    <listitem>
                        <para>
                            A folder containing the JavaDoc API documentation in plain
                            HTML.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-tutorial.pdf</filename></term>
                    <listitem>
                        <para>
                            The tutorial in PDF format.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-tutorial</filename></term>
                    <listitem>
                        <para>
                            The tutorial in HTML format. The online version of the
                            tutorial is always available at <link
                            xlink:href="http://vaadin.com/download/jpacontainer-tutorial/">vaadin.com/download/jpacontainer-tutorial/</link>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-addressbook-demo</filename></term>
                    <listitem>
                        <para>
                            The JPAContainer AddressBook Demo project covered in this
                            tutorial. You can compile and package the application as a WAR
                            with <command>mvn</command> <parameter>package</parameter> or
                            launch it in the Jetty web browser with <command>mvn</command>
                            <parameter>jetty:run</parameter>. <!-- TODO LINK You can also
                            import the demo project in Eclipse as described in Section
                            3.1.2: Importing from Existing Installation Folder. -->
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-demo-z.z.z.war</filename></term>
                    <listitem>
                        <para>
                            The basic JPAContainer demo. It is somewhat more extensive
                            than the AddressBook Demo.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>

        <section xml:id="jpacontainer.installation.maven">
            <title>Downloading with Maven</title>

            <para>
                The <link xlink:href="http://vaadin.com/directory">download page in Vaadin
                Directory</link> gives the dependency declaration needed for retrieving
                the Vaadin JPAContainer library with Maven. A separate dependency
                declaration is given for both available licenses for Vaadin JPAContainer.
            </para>

            <para>
                For the CVAL License:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[<dependency>
   <groupId>com.vaadin.addon</groupId>
   <artifactId>jpacontainer-addon-cval-2.0</artifactId>
   <version>2.0.0</version>
</dependency>]]></programlisting>

            <para>
                For the AGPL License:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[<dependency>
   <groupId>com.vaadin.addon</groupId>
   <artifactId>jpacontainer-addon-agpl-3.0</artifactId>
   <version>2.0.0</version>
</dependency>]]></programlisting>

            <para>
                Use the <literal>LATEST</literal> version tag to automatically download
                the latest stable release or use a specific version number as done above.
            </para>

            <para>
                See <xref linkend="addons.maven"/> for detailed instructions for using a
                Vaadin add-on with Maven.
            </para>

            <section xml:id="jpacontainer.installation.maven.archetype">
                <title>Using the Maven Archetype</title>

                <para>
                    If you wish to create a new JPAContainer-enabled Vaadin project with
                    Maven, you can use the
                    <literal>vaadin-archetype-jpacontainer</literal> archetype. Please see
                    <xref linkend="getting-started.maven"/> for details on creating a
                    Vaadin project with a Maven archetype.
                </para>
            </section>
        </section>

        <section xml:id="jpacontainer.installation.libraries">
            <title>Including Libraries in Your Project</title>

            <para>
                The Vaadin JPAContainer JAR must be included in the library folder of the
                web application. It is located in <filename>WEB-INF/lib</filename> path in
                a web application. In a normal Eclipse web projects the path is
                <filename>WebContent/WEB-INF/lib</filename>. In Maven projects the JARs
                are automatically included in the folder, as long as the dependencies are
                defined correctly.
            </para>

            <para>
                You will need the following JARs:
            </para>

            <itemizedlist>
                <listitem><para>Vaadin Framework Library</para></listitem>
                <listitem><para>Vaadin JPAContainer</para></listitem>
                <listitem><para>Java Persistence API 2.0 (javax.persistence package)</para></listitem>
                <listitem><para>JPA implementation (EclipseLink, Hibernate, ...)</para></listitem>
                <listitem><para>Database driver or embedded engine (H2, HSQLDB, MySQL, PostgreSQL, ...)</para></listitem>
            </itemizedlist>

            <para>
                If you use Eclipse, the Vaadin Framework library is automatically
                downloaded and updated by the Vaadin Plugin for Eclipse.
            </para>

            <para>
                Optionally, you may need to also install the Vaadin BeanValidation
                add-on. If you do so, you also need an implementation of the Bean
                Validation, such as Hibernate Validator.
            </para>
        </section>
    </section>

    <section xml:id="jpacontainer.domain-model">
        <title>Defining a Domain Model</title>

        <para>
            Developing a persistent application starts by defining a domain model. A
            domain model consists of a number of entities (classes) and relationships
            between them.
        </para>

        <para>
            <xref linkend="figure.jpacontainer.domain-model"/> illustrates a simple domain
            model as a UML class diagram. It has two entities:
            <classname>Department</classname> and <classname>Person</classname>. They have
            a "department has persons" relationship. This is a <emphasis>one-to-many
            relationship</emphasis> with one department having many persons, each of which
            belongs to just one department. In addition, the departments have a hierarchy:
            "department is part of another department". This is represented with a parent
            relationship.
        </para>

        <figure xml:id="figure.jpacontainer.domain-model">
            <title>A Domain Model</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/jpacontainer/domain-model-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/domain-model-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <para>
            Realized in Java, the classes are as follows:
        </para>

        <programlisting><![CDATA[public class Department {
    private Long id;
    private String name;
    private Set<Person> persons;
    private Department parent;

    ... setters and getters ...
}

public class Person {
    private Long id;
    private String firstName;
    private String lastName;
    private Department department;

    ... setters and getters ...
}]]></programlisting>

        <para>
            After you have a basic domain model, you need to define the entity
            relationship metadata by annotating the entity classes.
        </para>

        <section xml:id="jpacontainer.domain-model.metadata">
            <title>Persistence Metadata</title>

            <para>
                The entity relationships are defined with metadata. The metadata can be
                defined in an XML metadata file or with Java annotations defined in the
                <package>javax.persistence</package> package. With Vaadin JPAContainer,
                you need to provide the metadata as annotations.
            </para>

            <para>
                For example, if we look at the Person class in the JPAContainer
                AddressBook Demo, we define various database-related metadata for the
                member variables of a class:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[@Entity
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    @NotNull
    @Size(min = 2, max = 24)
    private String firstName;

    @Size(min = 2, max = 24)
    private String lastName;

    @NotNull
    private Department department;]]></programlisting>

            <para>
                The JPA implementation uses reflection to read the annotations and defines
                a database model automatically from the class definitions.
            </para>

            <para>
                Let us look at the basic JPA metadata annotations as they are used in the
                <classname>Department</classname> class of the JPAContainer AddressBook
                Demo. The annotations are defined in the
                <package>javax.persistence</package> package. Please refer to JPA
                reference documentation for the complete list of possible annotations.
            </para>

            <section xml:id="jpacontainer.domain-model.metadata.entity">
                <title>Annotation: <literal>@Entity</literal></title>
                
                <para>
                    Each class that is enabled as a persistent entity must have the
                    <literal>@Entity</literal> annotation.
                </para>

                <programlisting><![CDATA[@Entity
public class Department {]]></programlisting>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.id">
                <title>Annotation: <literal>@Id</literal></title>
                
                <para>
                    Entities must have an identifier that is used as the primary key for
                    the table. It is used for various purposes in database queries, most
                    commonly for joining tables.
                </para>

                <programlisting><![CDATA[@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;]]></programlisting>

                <para>
                    The identifier is generated automatically in the database.  The
                    strategy for generating the identifier is defined with the
                    <literal>@GeneratedValue</literal> annotation.
                </para>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.onetomany">
                <title>Annotation: <literal>@OneToMany</literal></title>
                
                <para>
                    As noted earlier, entities can have relationships. The Department
                    entity of the domain model has one-to-many relationship with the
                    <classname>Person</classname> entity (<classname>Department has
                    persons</classname>). This relationship is represented with the
                    <literal>@OneToMany</literal> annotation.
                </para>

                <programlisting><![CDATA[@OneToMany(mappedBy = "department")
private Set<Person> persons;]]></programlisting>

                <para>
                    When using the JPAContainer <classname>FieldFactory</classname> to
                    automatically create fields for a form, the
                    <literal>@OneToMany</literal> relationship  See <xref
                    linkend="jpacontainer.fieldfactory"/> for more details.
                </para>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.manytoone">
                <title>Annotation: <literal>@ManyToOne</literal></title>
                
                <para>
                    Many departments can belong to the same higher-level department,
                    represented with the <literal>@ManyToOne</literal> annotation.
                </para>

                <programlisting><![CDATA[@ManyToOne
private Department parent;]]></programlisting>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.transient">
                <title>Annotation: <literal>@Transient</literal></title>
                
                <para>
                    JPA assumes that all entity properties are persisted. Properties that
                    should not be persisted are marked as transient with the
                    <literal>@Transient</literal> annotation.
                </para>

                <programlisting><![CDATA[@Transient
private Boolean superDepartment;
...
@Transient
public String getHierarchicalName() {
...]]></programlisting>
            </section>
        </section>
    </section>
    <section xml:id="jpacontainer.usage">
        <title>Basic Use of JPAContainer</title>

        <para>
            Vaadin JPAContainer offers a highly flexible API that makes things easy in
            simple cases while allowing extensive flexibility in demanding cases.
        </para>
        
        <para>
            We assume that you have defined a domain model with JPA annotations, as
            described in the previous section.
        </para>

        <section xml:id="jpacontainer.usage.jpacontainerfactory">
            <title>Using JPAContainerFactory</title>

            <para>
                The <classname>JPAContainerFactory</classname> provides the easy way to
                create a <classname>JPAContainer</classname>, as a set of builder methods
                for most cases you will likely meet.
            </para>
        </section>

        <section xml:id="jpacontainer.usage.configuration">
            <title>Persistence Configuration</title>

            <para>
                Persistence configuration is done in a persistence.xml file. In the demo
                project, it is located in src/main/resources/META-INF folder. The
                configuration includes defining the following:
            </para>

            <itemizedlist>
                <listitem><para>The persistence unit</para></listitem>
                <listitem><para>The persistence provider</para></listitem>
                <listitem><para>The database driver and connection</para></listitem>
                <listitem><para>Logging</para></listitem>
            </itemizedlist>

            <para>
                The <filename>persistence.xml</filename> file is packaged as
                <filename>WEB-INF/classes/META-INF/persistence.xml</filename> in the
                WAR. This is done automatically in a Maven build at the package phase.
            </para>

            <section xml:id="jpacontainer.usage.configuration.schema">
                <title>Persistence XML Schema</title>

                <para>
                    The beginning of the <filename>persistence.xml</filename> file defines
                    the used schema and namespaces:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<persistence
    xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://java.sun.com/xml/ns/persistence
      http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
    version="2.0">]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.unit">
                <title>Defining the Persistence Unit</title>

                <para>
                    The root element of the persistence definition is
                    persistence-unit. Its name attribute is used in the application when
                    referring to the persistence unit. In Section 5.2: Application Class
                    we define a global PERSISTENCE_UNIT identifier for referring to the
                    unit.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[    <persistence-unit name="addressbook">]]></programlisting>

                <para>
                    Persistence Provider: the provider is the JPA provider implementation
                    used. We use the EclipseLink JPA, so we define its provider class
                    here.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[        <provider>
            org.eclipse.persistence.jpa.PersistenceProvider
        </provider>]]></programlisting>

                <para>
                    Listing the Persistent Classes - In this example, we allow including
                    unlisted classes for persistence. The alternative is to specify each
                    persistent class with a <literal>&lt;class&gt;</literal> element.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[        <exclude-unlisted-classes>
            false
        </exclude-unlisted-classes>]]></programlisting>

                <para>
                    JPA provider specific parameters are specified under the properties
                    element. As we use EclipseLink JPA, the parameters are specific to
                    that. If you use another provider, please refer to its documentation
                    for the parameters.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[        <properties>
           ...]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.database">
                <title>Database Connection</title>

                <para>
                    EclipseLink allows using JDBC for database connection. We use the
                    H2 database, so we need to define its driver here.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[	<property name="eclipselink.jdbc.platform"
value="org.eclipse.persistence.platform.database.H2Platform" />
	<property name="eclipselink.jdbc.driver"
          value="org.h2.Driver" />]]></programlisting>

                <para>
                    We use an in-memory database for the demo with the following
                    connection URL definition:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[	<property name="eclipselink.jdbc.url"
          value="jdbc:h2:~/jpacontaineraddressbookh2db" />]]></programlisting>

                <para>
                    We can just use the default user name and password for the H2 database.
                </para>
                    
                <programlisting><?pocket-size 75% ?><![CDATA[	<property name="eclipselink.jdbc.user"
          value="sa" />
	<property name="eclipselink.jdbc.password" 
          value="sa" />]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.logging">
                <title>Logging Configuation</title>

                <para>
                    We set the logging level for EclipseLink JPA:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[	<property name="eclipselink.logging.level" 
          value="FINE" />]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.other">
                <title>Other Settings</title>

                <para>
                    The rest is some Data Definition Language settings for
                    EclipseLink. During development, when we use generated example data,
                    we want EclipseLink to drop tables before trying to create them. In
                    production environments, you should use
                    <literal>create-tables</literal>.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[   <property name="eclipselink.ddl-generation" 
             value="drop-and-create-tables" />]]></programlisting>

                <para>
                    And there is no need to generate SQL files, just execute them directly
                    to the database.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[	   <property name="eclipselink.ddl-generation.output-mode"
             value="database" />
	  </properties>
 </persistence-unit>
</persistence>]]></programlisting>
            </section>
        </section>
    </section>

    <section xml:id="jpacontainer.fieldfactory">
        <title>Automatic Form Generation</title>

        <para>
            The JPAContainer <classname>FieldFactory</classname> is an implementation of
            the <interfacename>FormFieldFactory</interfacename> and
            <interfacename>TableFieldFactory</interfacename> interfaces that can generate
            fields based on the JPA annotations in a POJO. It goes further than the
            <classname>DefaultFieldFactory</classname>, which only creates simple fields
            for the basic data types. This way you can create CRUD views easily, in a
            fashion similar to what the Vaadin Plugin for Spring Roo allows.
        </para>

        <para>
            The generated defaults are as follows:
        </para>

        <informaltable>
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry><para>Annotation</para></entry>
                        <entry><para>Class Mapping</para></entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><para><literal>@ManyToOne</literal></para></entry>
                        <entry><para><classname>NativeSelect</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToOne</literal></para></entry>
                        <entry><para>Nested <classname>Form</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToMany</literal></para></entry>
                        <entry><para><classname>MasterDetailEditor</classname> (see below)</para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@ManyToMany</literal></para></entry>
                        <entry><para>Selectable <classname>Table</classname></para></entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <!-- TODO: Stuff added in [22470] -->

        <para>
            The field factory is recusive, so that you can edit a complex object tree with
            one form.
        </para>

        <section xml:id="jpacontainer.fieldfactory.masterdetaileditor">
            <title>Master-Detail Editor</title>

            <para>
                The <classname>MasterDetailEditor</classname> is a complete implementation
                of the Master-Detail pattern where you can add and remove items or select
                an item to edit it.

                <!-- Removal of entities (actually relationships between entities depending on the cascade rule) -->
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.configuring">
            <title>Configuring the Field Factory</title>

            <para>
                The <classname>FieldFactory</classname> is highly configurable with
                various configuration settings and by extending. You need to make the
                configuration before 
            </para>

            <para>
                The <methodname>setMultiSelectType()</methodname> and
                <methodname>setSingleSelectType()</methodname> allow you to specify a
                selection component that is used instead of the default for a field with
                <literal>@ManyToMany</literal> and <literal>@ManyToOne</literal>
                annotation, respectively. The first parameter is the class type of the
                field, and the second parameter is the class type of a selection
                component. It must be a sub-class of
                <classname>AbstractSelect</classname>.
            </para>

            <para>
                The <methodname>setVisibleProperties()</methodname> controls which
                properties (fields) are visible in generated forms, subforms, and
                tables. The first paramater is the class type for which the setting should
                be made, followed by the IDs of the visible properties.
            </para>

            <para>
                Further configuration must be done by extending the many protected
                methods. Please see the API documentation for the complete list.
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.using">
            <title>Using the Field Factory</title>

            <para>
                The basic use of the <classname>FieldFactory</classname> goes as follows:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[// Create a form
customerForm = new Form();
customerForm.setCaption("EditCustomer groups");

// Create a field factory for the form
FieldFactory jpaContainerFieldFactory = new FieldFactory();

// Optional configuration:
jpaContainerFieldFactory.setVisibleProperties(InvoiceRow.class,
        "product", "description", "unit", "unitPrice");
jpaContainerFieldFactory.setVisibleProperties(BillingAddress.class, "street", "city", "postalCode");
jpaContainerFieldFactory.setSingleSelectType(Customer.class, ListSelect.class);

customerForm.setFormFieldFactory(jpaContainerFieldFactory);
addComponent(customerForm);]]></programlisting>
        </section>

        <para>
            Notice that the configuration should be done before actually binding the form.
        </para>

        <para>
            If you use Hibernate, you also need to pass an
            <classname>EntityManagerPerRequestHelper</classname>, either for the
            constructor or with
            <methodname>setEntityManagerPerRequestHelper()</methodname>.
        </para>
    </section>

    <indexterm startref="term.jpacontainer" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
