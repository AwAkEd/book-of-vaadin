<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="jpacontainer">
    <title>Vaadin JPAContainer</title>

    <indexterm xml:id="term.jpacontainer" class="startofrange">
        <primary>JPAContainer</primary>
    </indexterm>

    <para>
        This chapter describes the use of the Vaadin JPAContainer add-on.
    </para>

    <para>
        <emphasis></emphasis>
    </para>

    <section xml:id="jpacontainer.overview">
        <title>Overview</title>

        <para>
            Vaadin JPAContainer add-on makes it possible to bind user interface components
            to a database easily using the Java Persistence API (JPA). It is an
            implementation of the <interfacename>Container</interfacename> interface
            described in <xref linkend="datamodel.container"/>.

            It supports a typical three-layer application
            architecture with an intermediate <emphasis>domain model</emphasis> between
            the user interface and the data access layer.
        </para>

		<figure xml:id="figure.jpacontainer.overview.architecture">
			<title>Three-Layer Architecture Using JPAContainer And JPA</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/three-layer-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/three-layer-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            The role of Java Persistence API is to handle persisting the domain model in
            the database. The database is typically a relational database. Vaadin
            JPAContainer binds the user interface components to the domain model and
            handles database access with JPA transparently.
        </para>

        <para>
            JPA is really just an API definition and has many alternative
            implementations. Vaadin JPAContainer supports especially EclipseLink, which is
            the reference implementation of JPA, and Hibernate. Any other compliant
            implementation should work just as well. The architecture of an application
            using JPAContainer is shown in <xref
            linkend="figure.jpacontainer.overview.detailed-architecture"/>.
        </para>

		<figure xml:id="figure.jpacontainer.overview.detailed-architecture">
			<title>JPAContainer Architecture</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/detailed-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/detailed-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Vaadin JPAContainer also plays together with the Vaadin Bean Validation
            add-on, which brings Java Bean Validation (JSR 303) to Vaadin applications.
        </para>

        <simplesect xml:id="jpacontainer.overview.jpa">
            <title>Java Persistence API</title>

            <para>
                Java Persistence API (JPA) is an API for object-relational mapping (ORM)
                of Java objects to a relational database. In JPA and entity-relationship
                modeling in general, a Java class is considered an
                <emphasis>entity</emphasis>. Class (or entity) instances correspond with a
                row in a database table and member variables of a class with
                columns. Entities can also have relationships with other entities.
            </para>

            <para>
                The object-relational mapping is illustrated in <xref
                linkend="figure.jpacontainer.overview.jpa.orm"/> with two entities with a
                one-to-many relationship.
            </para>

            <figure xml:id="figure.jpacontainer.overview.jpa.orm">
                <title>Object-Relational Mapping</title>
                <mediaobject>
                    <imageobject role="html">
                        <imagedata align="center" fileref="img/jpacontainer/jpa-mapping-graphic-lo.png"/>
                    </imageobject>
                    <imageobject role="fo">
                        <imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/jpa-mapping-graphic-hi.png"/>
                    </imageobject>
                </mediaobject>
            </figure>

            <para>
                The entity relationships are declared with metadata. With Vaadin
                JPAContainer, you provide the metadata with annotations in the entity
                classes. The JPA implementation uses reflection to read the annotations
                and defines a database model automatically from the class
                definitions. Definition of the domain model and the annotations are
                described in <xref linkend="jpacontainer.domain-model.annotation"/>.
            </para>

            <para>
                Vaadin JPAContainer supports JPA 2.0 (JSR 317). 
            </para>
        </simplesect>

        <simplesect xml:id="jpacontainer.overview.documentation">
            <title>Documentation and Support</title>

            <para>
                In addition to this chapter in the book, the installation package includes
                the following documentation about JPAContainer:
            </para>

            <itemizedlist>
                <listitem><para>API Documentation</para></listitem>
                <listitem><para>JPAContainer Tutorial</para></listitem>
                <listitem><para>JPAContainer AddressBook Demo</para></listitem>
                <listitem><para>JPAContainer Demo</para></listitem>
            </itemizedlist>
        </simplesect>
    </section>

    <section xml:id="jpacontainer.installation">
        <title>Installing</title>

        <para>
            Vaadin JPAContainer can be installed either as an installation package,
            downloaded from the Vaadin Directory, or as a Maven dependency. You can also
            create a new JPAContainer-enabled Vaadin project using a Maven archetype.
        </para>

        <section xml:id="jpacontainer.installation.download">
            <title>Downloading the Package</title>

            <para>
                Vaadin JPAContainer is available for download from the <link
                xlink:href="http://vaadin.com/directory">Vaadin Directory</link>.  Please
                see <xref linkend="addons.downloading"/> for basic instructions for
                downloading from Directory. The download page also gives the dependency
                declaration needed for retrieving the library with Maven.
            </para>

            <para>
                JPAContainer is a purely server-side component, so it does not include a
                widget set that you would need to compile.
            </para>

            <simplesect xml:id="jpacontainer.installation.download.license">
                <title>Choosing the License</title>

                <para>
                    Vaadin JPAContainer is available under two licenses: Affero General
                    Public License (AGPL) and Commercial Vaadin Add-on License (CVAL). If
                    your project is compatible with the open-source AGPL, you can use the
                    add-on for free. Otherwise you must acquire a sufficient number of
                    CVAL licenses before the 30-day trial period ends. Vaadin JPAContainer
                    is distributed as a separate installation package for each license.
                </para>

                <para>
                    Use of Vaadin JPAContainer with the CVAL license is included in the
                    Vaadin PRO subscription.
                </para>
            </simplesect>
        </section>

        <section xml:id="jpacontainer.installation.package">
            <title>Installation Package Content</title>

            <para>
                Once extracted to a local folder, the contents of the installation
                directory are illustrated in Figure 4.
            </para>

Figure 4: Installation Package Contents

            <para>
                The files in the installation package are as follows:
            </para>

            <variablelist>
                <varlistentry>
                    <term><filename>README</filename></term>
                    <listitem>
                        <para>
                            A readme file describing the package contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>licensing.txt</filename></term>
                    <listitem>
                        <para>
                            General information about licensing of JPAContainer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>license-xxxx-y.y.txt</filename></term>
                    <listitem>
                        <para>
                            The full license text for the library.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>vaadin-jpacontainer-xxxx-y.y-z.z.z.jar</filename></term>
                    <listitem>
                        <para>
                            The actual Vaadin JPAContainer library. The xxxx is the
                            license name and y.y its version number. The final z.z.z is
                            the version number of the Vaadin JPAContainer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>vaadin-jpacontainer-xxxx-y.y-z.z.z-javadoc.jar</filename></term>
                    <listitem>
                        <para>
                            JavaDoc documentation JAR for the library. You can use it for
                            example in Eclipse by associating the JavaDoc JAR with the
                            JPAContainer JAR in the build path settings of your project.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>apidocs</filename></term>
                    <listitem>
                        <para>
                            A folder containing the JavaDoc API documentation in plain
                            HTML.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-tutorial.pdf</filename></term>
                    <listitem>
                        <para>
                            The tutorial in PDF format.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-tutorial</filename></term>
                    <listitem>
                        <para>
                            The tutorial in HTML format. The online version of the
                            tutorial is always available at <link
                            xlink:href="http://vaadin.com/download/jpacontainer-tutorial/">vaadin.com/download/jpacontainer-tutorial/</link>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-addressbook-demo</filename></term>
                    <listitem>
                        <para>
                            The JPAContainer AddressBook Demo project covered in this
                            tutorial. You can compile and package the application as a WAR
                            with "<command>mvn</command> <parameter>package</parameter>"
                            or launch it in the Jetty web browser with
                            "<command>mvn</command> <parameter>jetty:run</parameter>". You
                            can also import the demo project in Eclipse as described in
                            the tutorial.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>jpacontainer-demo-z.z.z.war</filename></term>
                    <listitem>
                        <para>
                            The basic JPAContainer demo. It is somewhat more extensive
                            than the AddressBook Demo.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>

        <section xml:id="jpacontainer.installation.maven">
            <title>Downloading with Maven</title>

            <para>
                The <link xlink:href="http://vaadin.com/directory">download page in Vaadin
                Directory</link> gives the dependency declaration needed for retrieving
                the Vaadin JPAContainer library with Maven. A separate dependency
                declaration is given for both available licenses for Vaadin JPAContainer.
            </para>

            <para>
                For the CVAL License:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[<dependency>
   <groupId>com.vaadin.addon</groupId>
   <artifactId>jpacontainer-addon-cval-2.0</artifactId>
   <version>2.0.0</version>
</dependency>]]></programlisting>

            <para>
                For the AGPL License:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[<dependency>
   <groupId>com.vaadin.addon</groupId>
   <artifactId>jpacontainer-addon-agpl-3.0</artifactId>
   <version>2.0.0</version>
</dependency>]]></programlisting>

            <para>
                Use the <literal>LATEST</literal> version tag to automatically download
                the latest stable release or use a specific version number as done above.
            </para>

            <para>
                See <xref linkend="addons.maven"/> for detailed instructions for using a
                Vaadin add-on with Maven.
            </para>

            <section xml:id="jpacontainer.installation.maven.archetype">
                <title>Using the Maven Archetype</title>

                <para>
                    If you wish to create a new JPAContainer-enabled Vaadin project with
                    Maven, you can use the
                    <literal>vaadin-archetype-jpacontainer</literal> archetype. Please see
                    <xref linkend="getting-started.maven"/> for details on creating a
                    Vaadin project with a Maven archetype.
                </para>
            </section>
        </section>

        <section xml:id="jpacontainer.installation.libraries">
            <title>Including Libraries in Your Project</title>

            <para>
                The Vaadin JPAContainer JAR must be included in the library folder of the
                web application. It is located in <filename>WEB-INF/lib</filename> path in
                a web application. In a normal Eclipse web projects the path is
                <filename>WebContent/WEB-INF/lib</filename>. In Maven projects the JARs
                are automatically included in the folder, as long as the dependencies are
                defined correctly.
            </para>


            <?dbfo-need height="2cm" ?>
            <para>
                You will need the following JARs:
            </para>

            <itemizedlist>
                <listitem><para>Vaadin Framework Library</para></listitem>
                <listitem><para>Vaadin JPAContainer</para></listitem>
                <listitem><para>Java Persistence API 2.0 (javax.persistence package)</para></listitem>
                <listitem><para>JPA implementation (EclipseLink, Hibernate, ...)</para></listitem>
                <listitem><para>Database driver or embedded engine (H2, HSQLDB, MySQL, PostgreSQL, ...)</para></listitem>
            </itemizedlist>

            <para>
                If you use Eclipse, the Vaadin Framework library is automatically
                downloaded and updated by the Vaadin Plugin for Eclipse.
            </para>

            <para>
                Optionally, you may need to also install the Vaadin BeanValidation
                add-on. If you do so, you also need an implementation of the Bean
                Validation, such as Hibernate Validator.
            </para>
        </section>
    </section>

    <section xml:id="jpacontainer.domain-model">
        <title>Defining a Domain Model</title>

        <para>
            Developing a persistent application starts with defining a domain model. A
            domain model consists of a number of entities (classes) and relationships
            between them.
        </para>

        <para>
            <xref linkend="figure.jpacontainer.domain-model"/> illustrates a simple domain
            model as a UML class diagram. It has two entities:
            <classname>Country</classname> and <classname>Person</classname>. They have a
            "country has persons" relationship. This is a <emphasis>one-to-many
            relationship</emphasis> with one country having many persons, each of which
            belongs to just one country.
        </para>

        <figure xml:id="figure.jpacontainer.domain-model">
            <title>A Domain Model</title>
            <mediaobject>
                <imageobject role="html">
                    <imagedata align="center" fileref="img/jpacontainer/domain-model-lo.png"/>
                </imageobject>
                <imageobject role="fo">
                    <imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/domain-model-hi.png"/>
                </imageobject>
            </mediaobject>
        </figure>

        <?dbfo-need height="2cm" ?>
        <para>
            Realized in Java, the classes are as follows:
        </para>

        <programlisting><![CDATA[public class Country {
    private Long   id;
    private String name;
    private Set<Person> persons;

    ... setters and getters ...
}

public class Person {
    private Long    id;
    private String  name;
    private Integer age;
    private Country country;

    ... setters and getters ...
}]]></programlisting>

        <para>
            You should make the classes proper beans by defining a default constructor and
            implementing the <interfacename>Serializable</interfacename> interface. A
            default constructor is required by the JPA entity manager for instantiating
            entities. Having the classes serializable is not required but often useful for
            other reasons.
        </para>

        <para>
            After you have a basic domain model, you need to define the entity
            relationship metadata by annotating the classes.
        </para>

        <section xml:id="jpacontainer.domain-model.metadata">
            <title>Persistence Metadata</title>

            <para>
                The entity relationships are defined with metadata. The metadata can be
                defined in an XML metadata file or with Java annotations defined in the
                <package>javax.persistence</package> package. With Vaadin JPAContainer,
                you need to provide the metadata as annotations.
            </para>

            <para>
                For example, if we look at the Person class in the JPAContainer
                AddressBook Demo, we define various database-related metadata for the
                member variables of a class:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[@Entity
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long    id;

    private String  name;
    private Integer age;
    private Country country;]]></programlisting>

            <para>
                The JPA implementation uses reflection to read the annotations and defines
                a database model automatically from the class definitions.
            </para>

            <para>
                Let us look at the basic JPA metadata annotations as they are used in the
                <classname>Department</classname> class of the JPAContainer AddressBook
                Demo. The annotations are defined in the
                <package>javax.persistence</package> package. Please refer to JPA
                reference documentation for the complete list of possible annotations.
            </para>

            <section xml:id="jpacontainer.domain-model.metadata.entity">
                <title>Annotation: <literal>@Entity</literal></title>
                
                <para>
                    Each class that is enabled as a persistent entity must have the
                    <literal>@Entity</literal> annotation.
                </para>

                <programlisting><![CDATA[@Entity
public class Department {]]></programlisting>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.id">
                <title>Annotation: <literal>@Id</literal></title>
                
                <para>
                    Entities must have an identifier that is used as the primary key for
                    the table. It is used for various purposes in database queries, most
                    commonly for joining tables.
                </para>

                <programlisting><![CDATA[@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;]]></programlisting>

                <para>
                    The identifier is generated automatically in the database.  The
                    strategy for generating the identifier is defined with the
                    <literal>@GeneratedValue</literal> annotation.
                </para>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.onetomany">
                <title>Annotation: <literal>@OneToMany</literal></title>
                
                <para>
                    As noted earlier, entities can have relationships. The Department
                    entity of the domain model has one-to-many relationship with the
                    <classname>Person</classname> entity (<classname>Department has
                    persons</classname>). This relationship is represented with the
                    <literal>@OneToMany</literal> annotation.
                </para>

                <programlisting><![CDATA[@OneToMany(mappedBy = "country")
private Set<Person> persons;]]></programlisting>

                <para>
                    When using the JPAContainer <classname>FieldFactory</classname> to
                    automatically create fields for a form, the
                    <literal>@OneToMany</literal> relationship  See <xref
                    linkend="jpacontainer.fieldfactory"/> for more details.
                </para>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.manytoone">
                <title>Annotation: <literal>@ManyToOne</literal></title>
                
                <para>
                    Many departments can belong to the same higher-level department,
                    represented with the <literal>@ManyToOne</literal> annotation.
                </para>

                <programlisting><![CDATA[@ManyToOne
private Country parent;]]></programlisting>
            </section>

            <section xml:id="jpacontainer.domain-model.annotation.transient">
                <title>Annotation: <literal>@Transient</literal></title>
                
                <para>
                    JPA assumes that all entity properties are persisted. Properties that
                    should not be persisted are marked as transient with the
                    <literal>@Transient</literal> annotation.
                </para>

                <programlisting><![CDATA[@Transient
private Boolean superDepartment;
...
@Transient
public String getHierarchicalName() {
...]]></programlisting>
            </section>
        </section>
    </section>

    <section xml:id="jpacontainer.usage">
        <title>Basic Use of JPAContainer</title>

        <para>
            Vaadin JPAContainer offers a highly flexible API that makes things easy in
            simple cases while allowing extensive flexibility in demanding cases.
        </para>
        
        <para>
            We assume that you have defined a domain model with JPA annotations, as
            described in the previous section.
        </para>

        <section xml:id="jpacontainer.usage.jpacontainerfactory">
            <title>Using JPAContainerFactory</title>

            <para>
                The <classname>JPAContainerFactory</classname> is the easy way to create
                <classname>JPAContainer</classname>s. It provides a set of
                <emphasis>make...()</emphasis> factory methods for most cases you will
                likely meet. Each factory method uses a different type of entity provider,
                as described in <xref linkend="jpacontainer.entityprovider"/>.
            </para>

            <para>
                The factory methods take the class type of the entity class as the first
                parameter. The second parameter is either a persistence unit name
                (persistence context) or an <classname>EntityManager</classname> instance.
            </para>

            <programlisting><?pocket-size 65% ?><![CDATA[// Create a persistent person container
JPAContainer<Person> persons =
    JPAContainerFactory.make(Person.class, "book-examples");

// Add some items to it
persons.addEntity(new Person("Jeanne Calment", 122));
persons.addEntity(new Person("Sarah Knauss", 119));
persons.addEntity(new Person("Lucy Hannah", 117));
persons.addEntity(new Person("Marie-Louise Meilleur", 117));

// Bind it to a component
Table personTable = new Table("The Persistent People", persons);]]></programlisting>

            <para>
                It's that easy. In fact, if you run the above code multiple times, you'll
                be annoyed by getting a new set of persons for each run - that's how
                persistent the container is.  The basic <methodname>make()</methodname>
                uses a <classname>CachedMutableLocalEntityProvider</classname>, which
                allows modifying the container and its entities, as we do above by adding
                new entities.
            </para>

            <para>
                When using just the persistence unit name, the factory creates an instance
                of <classname>EntityManagerFactory</classname> for the persistence unit
                and uses it to build entity managers. You can also create the entity
                managers yourself. This behind-the-doors-stuff is explained in <xref
                linkend="jpacontainer.usage.thehardway"/>.
            </para>

            <?dbfo-need height="2cm" ?>
            <para>
                The entity providers associated with the different factory methods are as
                follows:
            </para>

			<table xml:id="table.jpacontainer.usage.jpacontainerfactory">
				<title><classname>JPAContainerFactory</classname> Methods</title>
				<tgroup cols="2" align="left">
					<tbody>
						<row valign="top">
							<entry><methodname>make()</methodname></entry>
                            <entry><classname>CachedMutableLocalEntityProvider</classname></entry>
                        </row>
						<row valign="top">
							<entry><methodname>makeReadOnly()</methodname></entry>
                            <entry><classname>CachedLocalEntityProvider</classname></entry>
                        </row>
						<row valign="top">
							<entry><methodname>makeBatchable()</methodname></entry>
                            <entry><classname>BatchableLocalEntityProvider</classname></entry>
                        </row>
						<row valign="top">
							<entry><methodname>makeNonCached()</methodname></entry>
                            <entry><classname>MutableLocalEntityProvider</classname></entry>
                        </row>
						<row valign="top">
							<entry><methodname>makeNonCachedReadOnly</methodname></entry>
                            <entry><classname>LocalEntityProvider</classname></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>

            <para>
                <classname>JPAContainerFactory</classname> holds a cache of entity manager
                factories for the different persistence units, making sure that any entity
                manager factory is created only once, as it is a heavy operation.  You can
                access the cache to get a new entity manager with the
                <methodname>createEntityManagerForPersistenceUnit()</methodname> method.
            </para>
        </section>

        <section xml:id="jpacontainer.usage.thehardway">
            <title>The Hard Way</title>

            <para>
                Let us now consider the hard way of creating a
                <classname>JPAContainer</classname>.
            </para>

            <para>
                First, we need to have an entity manager. TODO: define.
            </para>

			<programlisting><?pocket-size 65% ?><![CDATA[
EntityManagerFactory emf =
   Persistence.createEntityManagerFactory("my-unit-name");

EntityManager entityManager = emf.createEntityManager();

CachingMutableLocalEntityProvider<Person> entityProvider =
  new CachingMutableLocalEntityProvider<Person>(Person.class,
                                                entityManager);

JPAContainer<Person> container =
    new JPAContainer<Person>(Person.class);
container.setEntityProvider(cachingEntityProvider);]]></programlisting>
        </section>

        <section xml:id="jpacontainer.usage.configuration">
            <title>Persistence Configuration</title>

            <para>
                Persistence configuration is done in a
                <filename>persistence.xml</filename> file. In a regular Eclipse project,
                it should be located in
                <filename>WebContent/WEB-INF/classes/META-INF</filename>. In a Maven
                project, it should be in
                <filename>src/main/resources/META-INF</filename>. The configuration
                includes the following:
            </para>

            <itemizedlist>
                <listitem><para>The persistence unit</para></listitem>
                <listitem><para>The persistence provider</para></listitem>
                <listitem><para>The database driver and connection</para></listitem>
                <listitem><para>Logging</para></listitem>
            </itemizedlist>

            <para>
                The <filename>persistence.xml</filename> file is packaged as
                <filename>WEB-INF/classes/META-INF/persistence.xml</filename> in the
                WAR. This is done automatically in a Maven build at the package phase.
            </para>

            <section xml:id="jpacontainer.usage.configuration.schema">
                <title>Persistence XML Schema</title>

                <para>
                    The beginning of a <filename>persistence.xml</filename> file defines
                    the used schema and namespaces:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<persistence
    xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="
      http://java.sun.com/xml/ns/persistence
      http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"
    version="2.0">]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.unit">
                <title>Defining the Persistence Unit</title>

                <para>
                    The root element of the persistence definition is
                    persistence-unit. The name of the persistence unit is needed for
                    creating <classname>JPAContainer</classname> instances from a
                    <classname>JPAContainerFactory</classname>, as described in <xref
                    linkend="jpacontainer.usage.jpacontainerfactory"/> or when creating a
                    JPA entity manager.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<persistence-unit name="addressbook">]]></programlisting>

                <?dbfo-need height="2cm" ?>
                <para>
                    Persistence provider is the JPA provider implementation used. For
                    example, the JPAContainer AddressBook demo uses the EclipseLink JPA,
                    which is defined as follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<provider>
    org.eclipse.persistence.jpa.PersistenceProvider
</provider>]]></programlisting>

                <?dbfo-need height="2cm" ?>
                <para>
                    The persistent classes need to be listed with a
                    <literal>&lt;class&gt;</literal> element. Alternatively, you can allow
                    including unlisted classes for persistence by overriding the
                    <literal>exclude-unlisted-classes</literal> default as follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<exclude-unlisted-classes>false</exclude-unlisted-classes>]]></programlisting>

                <?dbfo-need height="2cm" ?>
                <para>
                    JPA provider specific parameters are given under the
                    <literal>properties</literal> element.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<properties>
   ...]]></programlisting>

                <para>
                    In the following section we give parameters for the EclipseLink JPA
                    and H2 database used in the JPAContainer AddressBook Demo. Please
                    refer to the documentation of the JPA provider you use for a complete
                    reference of parameters.
                </para>
            </section>

            <section xml:id="jpacontainer.usage.configuration.database">
                <title>Database Connection</title>

                <?dbfo-need height="2cm" ?>
                <para>
                    EclipseLink allows using JDBC for database connection. For example, if
                    we use the the H2 database, we define its driver here as follows:
                </para>

                <programlisting><?pocket-size 65% ?><![CDATA[<property name="eclipselink.jdbc.platform"
 value="org.eclipse.persistence.platform.database.H2Platform"/>
<property name="eclipselink.jdbc.driver"
          value="org.h2.Driver" />]]></programlisting>

                <?dbfo-need height="2cm" ?>
                <para>
                    Database connection is specified with a URL. For example, using an
                    embedded H2 database stored in the home directory it would be as
                    follows:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<property name="eclipselink.jdbc.url"
          value="jdbc:h2:~/my-app-h2db"/>]]></programlisting>

                <para>
                    A hint: when using an embedded H2 database while developing a Vaadin
                    application in Eclipse, you may want to add
                    <literal>;FILE_LOCK=NO</literal> to the URL to avoid locking issues
                    when redeploying.
                </para>

                <?dbfo-need height="2cm" ?>
                <para>
                    We can just use the default user name and password for the H2
                    database:
                </para>
                    
                <programlisting><?pocket-size 75% ?><![CDATA[<property name="eclipselink.jdbc.user" value="sa"/>
<property name="eclipselink.jdbc.password" value="sa"/>]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.logging">
                <title>Logging Configuration</title>

                <?dbfo-need height="2cm" ?>
                <para>
                    JPA implementations as well as database engines like to produce logs
                    and they should be configured in the persistence configuration. For
                    example, if using EclipseLink JPA, you can get log that includes all
                    SQL statements with the <literal>FINE</literal> logging level:
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<property name="eclipselink.logging.level" 
          value="FINE" />]]></programlisting>
            </section>

            <section xml:id="jpacontainer.usage.configuration.other">
                <title>Other Settings</title>

                <para>
                    The rest is some Data Definition Language settings for
                    EclipseLink. During development, when we use generated example data,
                    we want EclipseLink to drop tables before trying to create them. In
                    production environments, you should use
                    <literal>create-tables</literal>.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<property name="eclipselink.ddl-generation" 
          value="drop-and-create-tables" />]]></programlisting>

                <para>
                    And there is no need to generate SQL files, just execute them directly
                    to the database.
                </para>

                <programlisting><?pocket-size 75% ?><![CDATA[<property name="eclipselink.ddl-generation.output-mode"
          value="database"/>
	  </properties>
 </persistence-unit>
</persistence>]]></programlisting>
            </section>
        </section>

        <section xml:id="jpacontainer.usage.troubleshooting">
            <title>Troubleshooting</title>

            <para>
                Below are some typical errors that you might get.
            </para>

            <variablelist>
                <varlistentry>
                    <term><classname>javax.persistence.PersistenceException</classname>: No Persistence provider for EntityManager</term>
                    <listitem>
                        <para>
                            The most typical cases for this error are that the persistence
                            unit name is wrong in the source code or in the
                            <filename>persistence.xml</filename> file, or that the
                            <filename>persistence.xml</filename> is at a wrong place or
                            has some other problem. Make sure that the persistence unit
                            name matches and the <filename>persistence.xml</filename> is
                            in <filename>WEB-INF/classes/META-INF</filename> folder in the
                            deployment.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><classname>java.lang.IllegalArgumentException</classname>: The class is not an entity</term>
                    <listitem>
                        <para>
                            The class is missing from the set of persistent entities. If
                            the <filename>persistence.xml</filename> does not have
                            <parameter>exclude-unlisted-classes</parameter> defined as
                            <literal>false</literal>, the persistent entity classes should
                            be listed with <literal>&lt;class&gt;</literal> elements.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </section>
    </section>

    <section xml:id="jpacontainer.entityprovider">
        <title>Entity Providers</title>

        <para>
            Entity providers provide access to entities persisted in a data store. They
            are essentially wrappers over a JPA entity manager with optimizations and
            other features. The most important features are caching, buffering, and
            batching. Using a read-only provider instead of a mutable one can help with
            performance.
        </para>

        <section xml:id="jpacontainer.entityprovider.features">
            <title>Entity Provider Features and Types</title>
                
            <para>
                JPAContainer includes two kinds of built-in entity providers:
                <emphasis>local</emphasis> and <emphasis>caching local</emphasis>
                providers.
            </para>

            <section xml:id="jpacontainer.entityprovider.local">
                <title>Local Providers</title>
                
                <para>
                    The local providers are the simplest, as they read data directly from
                    a JPA entity manager.
                </para>
            </section>

            <section xml:id="jpacontainer.entityprovider.caching">
                <title>Caching</title>
                
                <para>
                </para>
            </section>

            <section xml:id="jpacontainer.entityprovider.buffered">
                <title>Buffered Mode</title>
                
                <para>
                </para>
            </section>
            
            <section xml:id="jpacontainer.entityprovider.mutable">
                <title>Mutable</title>
                
                <para>
            </para>
            </section>

            <section xml:id="jpacontainer.entityprovider.batching">
                <title>Batching</title>
                
                <para>
                </para>
            </section>
        </section>
    </section>

    <section xml:id="jpacontainer.filtering">
        <title>Filtering</title>

        <para>
            Normally, a <classname>JPAContainer</classname> contains all instances of a
            particular entity type in the persistence context. Hence, it is equivalent to
            a database table or query. Just like with database queries, you often want to
            narrow the results down. <classname>JPAContainer</classname> implements the
            <interfacename>Filterable</interfacename> interface in Vaadin containers,
            described in <xref linkend="datamodel.container.filtered"/>. The filtering
            implementation uses the JPA 2.0 Criteria API transparently.
        </para>

        <para>
            For example, let us filter all the people older than 117:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[Filter filter = new Compare.Greater("age", 117);
persons.addContainerFilter(filter);]]></programlisting>

        <para>
            If you have enabled detailed database logging, you should see a JPQL query
            somewhat as follows:
        </para>

        <programlisting><?pocket-size 75% ?><![CDATA[SELECT id FROM Person WHERE (AGE > 117)]]></programlisting>
    </section>

    <section xml:id="jpacontainer.fieldfactory">
        <title>Automatic Form Generation</title>

        <para>
            The JPAContainer <classname>FieldFactory</classname> is an implementation of
            the <interfacename>FormFieldFactory</interfacename> and
            <interfacename>TableFieldFactory</interfacename> interfaces that can generate
            fields based on the JPA annotations in a POJO. It goes further than the
            <classname>DefaultFieldFactory</classname>, which only creates simple fields
            for the basic data types. This way you can create CRUD views easily, in a
            fashion similar to what the Vaadin Plugin for Spring Roo allows.
        </para>

        <para>
            The generated defaults are as follows:
        </para>

        <informaltable>
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry><para>Annotation</para></entry>
                        <entry><para>Class Mapping</para></entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><para><literal>@ManyToOne</literal></para></entry>
                        <entry><para><classname>NativeSelect</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToOne</literal></para></entry>
                        <entry><para>Nested <classname>Form</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToMany</literal></para></entry>
                        <entry><para><classname>MasterDetailEditor</classname> (see below)</para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@ManyToMany</literal></para></entry>
                        <entry><para>Selectable <classname>Table</classname></para></entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <!-- TODO: Stuff added in [22470] -->

        <para>
            The field factory is recusive, so that you can edit a complex object tree with
            one form.
        </para>

        <section xml:id="jpacontainer.fieldfactory.masterdetaileditor">
            <title>Master-Detail Editor</title>

            <para>
                The <classname>MasterDetailEditor</classname> is a complete implementation
                of the Master-Detail pattern where you can add and remove items or select
                an item to edit it.

                <!-- Removal of entities (actually relationships between entities depending on the cascade rule) -->
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.configuring">
            <title>Configuring the Field Factory</title>

            <para>
                The <classname>FieldFactory</classname> is highly configurable with
                various configuration settings and by extending. You need to make the
                configuration before 
            </para>

            <para>
                The <methodname>setMultiSelectType()</methodname> and
                <methodname>setSingleSelectType()</methodname> allow you to specify a
                selection component that is used instead of the default for a field with
                <literal>@ManyToMany</literal> and <literal>@ManyToOne</literal>
                annotation, respectively. The first parameter is the class type of the
                field, and the second parameter is the class type of a selection
                component. It must be a sub-class of
                <classname>AbstractSelect</classname>.
            </para>

            <para>
                The <methodname>setVisibleProperties()</methodname> controls which
                properties (fields) are visible in generated forms, subforms, and
                tables. The first paramater is the class type for which the setting should
                be made, followed by the IDs of the visible properties.
            </para>

            <para>
                Further configuration must be done by extending the many protected
                methods. Please see the API documentation for the complete list.
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.using">
            <title>Using the Field Factory</title>

            <para>
                The basic use of the <classname>FieldFactory</classname> goes as follows:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[// Create a form
customerForm = new Form();
customerForm.setCaption("EditCustomer groups");

// Create a field factory for the form
FieldFactory jpaContainerFieldFactory = new FieldFactory();

// Optional configuration:
jpaContainerFieldFactory.setVisibleProperties(InvoiceRow.class,
        "product", "description", "unit", "unitPrice");
jpaContainerFieldFactory.setVisibleProperties(BillingAddress.class, "street", "city", "postalCode");
jpaContainerFieldFactory.setSingleSelectType(Customer.class, ListSelect.class);

customerForm.setFormFieldFactory(jpaContainerFieldFactory);
addComponent(customerForm);]]></programlisting>
        </section>

        <para>
            Notice that the configuration should be done before actually binding the form.
        </para>

        <para>
            If you use Hibernate, you also need to pass an
            <classname>EntityManagerPerRequestHelper</classname>, either for the
            constructor or with
            <methodname>setEntityManagerPerRequestHelper()</methodname>.
        </para>
    </section>

    <indexterm startref="term.jpacontainer" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
