<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="jpacontainer">
    <title>Vaadin JPAContainer</title>

    <indexterm xml:id="term.jpacontainer" class="startofrange">
        <primary>JPAContainer</primary>
    </indexterm>

    <para>
        This chapter describes the use of the Vaadin JPAContainer add-on.
    </para>

    <para>
        <emphasis></emphasis>
    </para>

    <section xml:id="jpacontainer.overview">
        <title>Overview</title>

        <para>
            Vaadin JPAContainer add-on makes it possible to bind user interface components
            to a database easily using the Java Persistence API (JPA). It is an
            implementation of the <interfacename>Container</interfacename> interface
            described in <xref linkend="datamodel.container"/>.

            It supports a typical three-layer application
            architecture with an intermediate <emphasis>domain model</emphasis> between
            the user interface and the data access layer.
        </para>

		<figure xml:id="figure.jpacontainer.overview.architecture">
			<title>Three-Layer Architecture Using JPAContainer And JPA</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/three-layer-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/three-layer-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            The domain model is mapped to the database using JPA. The database is
            typically a relational database. Vaadin JPAContainer binds the user interface
            components to the JPA.
        </para>

        <para>
            JPA is really just an API definition and has many alternative
            implementations. Vaadin JPAContainer supports especially EclipseLink, which is
            the reference implementation of JPA, and Hibernate. Any other compliant
            implementation should work just as well. The architecture of an application
            using JPAContainer is shown in <xref
            lienkend="figure.jpacontainer.overview.detailed-architecture"/>.
        </para>

		<figure xml:id="figure.jpacontainer.overview.detailed-architecture">
			<title>JPAContainer Architecture</title>
			<mediaobject>
				<imageobject role="html">
					<imagedata align="center" fileref="img/jpacontainer/detailed-architecture-lo.png"/>
				</imageobject>
				<imageobject role="fo">
					<imagedata scale="75" smallscale="100%" align="center" fileref="img/jpacontainer/detailed-architecture-hi.png"/>
				</imageobject>
			</mediaobject>
		</figure>

        <para>
            Vaadin JPAContainer also plays together with the Vaadin Bean Validation
            add-on, which brings Java Bean Validation (JSR 303) to Vaadin applications.
        </para>

        <simplesect xml:id="jpacontainer.overview.jpa">
            <title>Java Persistence API</title>

            <para>
                Java Persistence API (JPA) is an API for object-relational mapping (ORM) of
                Java objects to a relational database. In JPA and entity-relationship modeling
                in general, a Java class is considered an entity. Class (or entity) instances
                correspond with a row in a database table and member variables of a class with
                columns. Entities can also have relationships with other entities.
            </para>

            <para>
                Vaadin JPAContainer supports JPA 2.0 (JSR 317). 
            </para>
        </simplesect>

        <simplesect xml:id="jpacontainer.overview.documentation">
            <title>Documentation and Support</title>

            <para>
                The installation package includes the following documentation about
                JPAContainer:
            </para>

            <itemizedlist>
                <listitem>
                    <para>
                        API Documentation
                    </para>
                </listitem>
                <listitem>
                    <para>
                        AddressBook Demo
                    </para>
                </listitem>
                <listitem>
                    <para>
                        JPAContainer Tutorial
                    </para>
                </listitem>
            </itemizedlist>
        </simplesect>
    </section>

    <section xml:id="jpacontainer.installation">
        <title>Installing</title>

        <section xml:id="jpacontainer.installation.download">
            <title>Downloading the Package</title>

            <simplesect xml:id="jpacontainer.installation.download.license">
                <title>Choosing the License</title>

                <para>
                    Vaadin JPAContainer is a commercial product licensed under a
                    dual-licensing scheme. The AGPL license allows open-source development,
                    while the CVAL license needs to be purchased for closed-source use,
                    including web deployments and internal use. Commercial licenses can be
                    purchased from the Vaadin Directory, where you can also find the license
                    details and download Vaadin JPAContainer.
                </para>
            </simplesect>
        </section>
    </section>

    <section xml:id="jpacontainer.usage">
        <title>Basic Use</title>
    </section>

    <section xml:id="jpacontainer.fieldfactory">
        <title>Automatic Form Generation</title>

        <para>
            The JPAContainer <classname>FieldFactory</classname> is an implementation of
            the <interfacename>FormFieldFactory</interfacename> and
            <interfacename>TableFieldFactory</interfacename> interfaces that can generate
            fields based on the JPA annotations in a POJO. It goes further than the
            <classname>DefaultFieldFactory</classname>, which only creates simple fields
            for the basic data types. This way you can create CRUD views easily, in a
            fashion similar to what the Vaadin Plugin for Spring Roo allows.
        </para>

        <para>
            The generated defaults are as follows:
        </para>

        <informaltable>
            <tgroup cols="2">
                <thead>
                    <row>
                        <entry><para>Annotation</para></entry>
                        <entry><para>Class Mapping</para></entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry><para><literal>@ManyToOne</literal></para></entry>
                        <entry><para><classname>NativeSelect</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToOne</literal></para></entry>
                        <entry><para>Nested <classname>Form</classname></para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@OneToMany</literal></para></entry>
                        <entry><para><classname>MasterDetailEditor</classname> (see below)</para></entry>
                    </row>
                    <row>
                        <entry><para><literal>@ManyToMany</literal></para></entry>
                        <entry><para>Selectable <classname>Table</classname></para></entry>
                    </row>
                </tbody>
            </tgroup>
        </informaltable>

        <!-- TODO: Stuff added in [22470] -->

        <para>
            The field factory is recusive, so that you can edit a complex object tree with
            one form.
        </para>

        <section xml:id="jpacontainer.fieldfactory.masterdetaileditor">
            <title>Master-Detail Editor</title>

            <para>
                The <classname>MasterDetailEditor</classname> is a complete implementation
                of the Master-Detail pattern where you can add and remove items or select
                an item to edit it.

                <!-- Removal of entities (actually relationships between entities depending on the cascade rule) -->
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.configuring">
            <title>Configuring the Field Factory</title>

            <para>
                The <classname>FieldFactory</classname> is highly configurable with
                various configuration settings and by extending. You need to make the
                configuration before 
            </para>

            <para>
                The <methodname>setMultiSelectType()</methodname> and
                <methodname>setSingleSelectType()</methodname> allow you to specify a
                selection component that is used instead of the default for a field with
                <literal>@ManyToMany</literal> and <literal>@ManyToOne</literal>
                annotation, respectively. The first parameter is the class type of the
                field, and the second parameter is the class type of a selection
                component. It must be a sub-class of
                <classname>AbstractSelect</classname>.
            </para>

            <para>
                The <methodname>setVisibleProperties()</methodname> controls which
                properties (fields) are visible in generated forms, subforms, and
                tables. The first paramater is the class type for which the setting should
                be made, followed by the IDs of the visible properties.
            </para>

            <para>
                Further configuration must be done by extending the many protected
                methods. Please see the API documentation for the complete list.
            </para>
        </section>

        <section xml:id="jpacontainer.fieldfactory.using">
            <title>Using the Field Factory</title>

            <para>
                The basic use of the <classname>FieldFactory</classname> goes as follows:
            </para>

			<programlisting><?pocket-size 75% ?><![CDATA[// Create a form
customerForm = new Form();
customerForm.setCaption("EditCustomer groups");

// Create a field factory for the form
FieldFactory jpaContainerFieldFactory = new FieldFactory();

// Optional configuration:
jpaContainerFieldFactory.setVisibleProperties(InvoiceRow.class,
        "product", "description", "unit", "unitPrice");
jpaContainerFieldFactory.setVisibleProperties(BillingAddress.class, "street", "city", "postalCode");
jpaContainerFieldFactory.setSingleSelectType(Customer.class, ListSelect.class);

customerForm.setFormFieldFactory(jpaContainerFieldFactory);
addComponent(customerForm);]]></programlisting>
        </section>

        <para>
            Notice that the configuration should be done before actually binding the form.
        </para>

        <para>
            If you use Hibernate, you also need to pass an
            <classname>EntityManagerPerRequestHelper</classname>, either for the
            constructor or with
            <methodname>setEntityManagerPerRequestHelper()</methodname>.
        </para>
    </section>

    <indexterm startref="term.jpacontainer" class="endofrange"/>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->
