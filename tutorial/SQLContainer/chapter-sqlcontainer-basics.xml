<?xml version="1.0" encoding="UTF-8"?>

<chapter xml:id="sqlcontainer-basics">
	<title>SQLContainer basics</title>

	<para>
		SQLContainer is an add-on to Vaadin, implementing the Container interface for standard SQL
		database servers. SQLContainer allows you to easily display data stored in an SQL database
		in Tables and Select components, as well as edit the data using Forms.
	</para>
	
	<para>
	  SQLContainer has two modes of operation, enabled by which <classname>QueryDelegate</classname>
	  implementation is given at construction time. The TableQuery implementation reads all contents
	  from a normal database table and automatically supports writing, filtering, sorting and lazy
	  loading for a variety of database engines (See the SQLContainer manual for a list). The second
	  provided implementation is the <classname>FreeformQuery</classname> implementation, which
	  allows any complex SQL query (e.g. joining many tables, etc) to be contained in the SQLContainer.
	  <classname>FreeformQuery</classname> requires the developer to implement the
	  <classname>FreeformQueryDelegate</classname> interface in order to support writing, filtering,
	  sorting and/or lazy loading. This tutorial will only use <classname>TableQuery</classname>. For
	  more information on <classname>FreeformQuery</classname>, see the SQLContainer manual.
  </para>
  
  <para>
    For those interested in more information, such as the architecture of the SQLContainer, see
    the SQLContainer manual included in the add-on distribution package.
  </para>

  <section xml:id="sqlcontainer-basics.replacing-indexedcontainer">
    <title>
      Replacing <classname>IndexedContainer</classname> with <classname>SQLContainer</classname>
    </title>

    <para>
      We will walk through the procedure of switching out the <classname>IndexedContainer</classname>s
      used in the Address book tutorial to <classname>SQLContainer</classname>s.
    </para>
    
    <section>
      <title>Connecting to and initializing the database</title>
      <para>
        In the scope of the address book application we will create a database connection helper
        class called DatabaseHelper. The purpose of this class is to handle database connections,
        dummy data generation, container creation and other datasource-related tasks.
      </para>
      
      <para>
        We begin by creating the helper class and by adding a method that creates a connection pool,
        which will be used to connect to the database of your choice. Note that the driver name,
        connection url, username and password will vary depending on your choice of database and
        the database settings. In this example we will be connecting to an in-memory HSQLDB database
        using a <classname>SimpleJDBCConnectionPool</classname> with between two and five open
        connections.
      </para>
      
      <programlisting>
<![CDATA[public class DatabaseHelper {
    private JDBCConnectionPool connectionPool = null;

    public DatabaseHelper() {
  	  initConnectionPool();
    }

    private void initConnectionPool() {
      	try {
          	connectionPool = new SimpleJDBCConnectionPool(
                  	"org.hsqldb.jdbc.JDBCDriver",
                  	"jdbc:hsqldb:mem:sqlcontainer", "SA", "", 2, 5);
      	} catch (SQLException e) {
        	  e.printStackTrace();
        }
    }
}]]>
      </programlisting>
      
      <para>
        We want to base our table data on two interrelated tables in a database. We will call
        these tables <classname>PersonAddress</classname> and <classname>City</classname> (note
        that the case-sensitivity of the table identifiers depends on the database used).
      </para>
      
      <para>
        The PersonAddress table will hold the most important data of the address book application.
        Each row corresponds to an entry in the address book and contains the following columns:
        <literal>firstname</literal>, <literal>lastname</literal>, <literal>email</literal>,
        <literal>phonenumber</literal>, <literal>streetaddress</literal> and <literal>postalcode</literal>.
        In addition to these, the table will also contain an <literal>ID</literal> column, a
        <literal>version</literal> column for optimistic locking and a <literal>cityid</literal>
        column which contains a foreign key reference to the <classname>City</classname> table.
      </para>
      
      <para>
        The <classname>City</classname> table contains only three columns: an <literal>ID</literal>
        column, a <literal>version</literal> column and a <literal>name</literal> column that will
        hold the name of the city.
      </para>
      
      <para>
        With HSQLDB we can use the following SQL queries to create these tables. The complete Java
        method for this can be found in <classname>DatabaseHelper</classname>
        <methodname>.initDatabase()</methodname>, but the code is omitted here for clarity.
      </para>
      
      <programlisting>
<![CDATA[create table city (id integer generated always as identity, name varchar(64), version integer default 0 not null, primary key (id));

create table personaddress (id integer generated always as identity, firstname varchar(64), lastname varchar(64), email varchar(64), phonenumber varchar(64), streetaddress varchar(128), postalcode integer, cityId integer not null, version integer default 0 not null , FOREIGN KEY (cityId) REFERENCES city(id), primary key(id));]]>
      </programlisting>
    </section>

    <section xml:id="sqlcontainer-basics.replacing-indexedcontainer.initializing">
      <title>Initializing the containers</title>
      <para>
        When the database connection is functional and the two tables are created successfully, we
        can create two <classname>SQLContainers</classname>; one connected to each table. The
        container initialization is really simple, we only need to create a
        <classname>QueryDelegate</classname> that the container will use. In this application, one
        instance of <classname>TableQuery</classname> will be created for each container. The
        <classname>TableQuery</classname> constructor requires the name of the table to fetch the
        data from, and a connection pool that it will use to get the database connections it needs.
      </para>
      
      <para>
        Next we'll set the version column for the <classname>TableQuery</classname>. The version
        column in this application is not actually functional, but <classname>TableQuery</classname>
        is designed in a way that requires a version column to be defined in order to support writing
        (see optimistic locking in the SQLContainer manual).
      </para>
      
      <para>
        Finally the <classname>SQLContainer</classname> is instantiated, given the
        <classname>TableQuery</classname> as its only parameter. The following method of
        <classname>DatabaseHelper</classname> contains all the code required to create the two
        containers:
      </para>

      <programlisting>
<![CDATA[private SQLContainer personContainer = null;
private SQLContainer cityContainer = null;

private void initContainers() {
    try {
        /* TableQuery and SQLContainer for personaddress -table */
        TableQuery q1 = new TableQuery("personaddress", connectionPool);
        q1.setVersionColumn("VERSION");
        personContainer = new SQLContainer(q1);

        /* TableQuery and SQLContainer for city -table */
        TableQuery q2 = new TableQuery("city", connectionPool);
        q2.setVersionColumn("VERSION");
        cityContainer = new SQLContainer(q2);
    } catch (SQLException e) {
        e.printStackTrace();
    }
}]]>
      </programlisting>

      <para>
        After the containers are created, the <classname>DatabaseHelper</classname> constructor
        will call the <methodname>fillContainers()</methodname> -method, which will add some
        generated data to the database for demonstration purposes.
      </para>
      
      <para>
        Finally, we create a few simple helper methods in the <classname>DatabaseHelper</classname>
        class to assist us later when we are processing data from the two containers. These methods
        are listed below and their operation should be quite self-explanatory by their signatures.
        Full definitions for these methods can be found in the AddressBook - SQLContainer demo
        application.
      </para>
      
      <programlisting>
<![CDATA[public String getCityName(int cityId)
public boolean addCity(String cityName)
public SQLContainer getPersonContainer()
public SQLContainer getCityContainer()]]>
      </programlisting>
      
    </section>
    
    <section>
      <title>Basics of the Data Model with respect to SQLContainer</title>
      
      <para>
        In this case we are using an <classname>SQLContainer</classname> as the container for
        the data shown in the table. The <classname>SQLContainer</classname> can maintain a
        list of our database contents and supply the table with information fetched directly
        from the database table when needed.
      </para>
      
      <para>The nice thing with this container is that we can simply</para>
      
      <itemizedlist>
    		<listitem>
    		  Instantiate the <classname>SQLContainer</classname> with a proper 
    		  <classname>QueryDelegate</classname>
    		</listitem>
    		<listitem>Assign the container to a table as a data source</listitem>
    		<listitem>VOILA, the information is displayed in the table</listitem>
    	</itemizedlist>
    	
    </section>
    
    <section>
      <title>Binding <classname>Table</classname> to an <classname>SQLContainer</classname></title>
      <para>
        To access the database helper class and our newly created containers in our application
        we add a new field to our <classname>AddressBookApplication</classname> together with a getter:
      </para>
      <programlisting>
<![CDATA[private DatabaseHelper dbHelp = new DatabaseHelper();
public DatabaseHelper getDbHelp() {
    return dbHelp;
}]]>
      </programlisting>
      
      <para>
        In addition to this we need to change the <classname>PersonList</classname> constructor
        so that we pass the application instance to it. This allows the
        <classname>PersonList</classname> to acquire its data source. Remember to modify the
        call to the constructor in <classname>AddressBookApplication</classname> as well. We can
        also remove the dummy test data creation from the previous step, leaving the
        <classname>PersonList</classname> class as:
      </para>
      
      <programlisting>
<![CDATA[public class PersonList extends Table {
    public PersonList(final AddressBookApplication app) {
        setSizeFull();
        setContainerDataSource(app.getDbHelp().getPersonContainer());
    }
}]]>
      </programlisting>

      <para>
        The <methodname>setContainerDataSource()</methodname> sets the
        <classname>SQLContainer</classname> which we created in
        <xref linkend="sqlcontainer-basics.replacing-indexedcontainer.initializing"/> to be the
        data source for the <classname>PersonList</classname> table.
      </para>
      
      <para>
        We now have a data source connected to the table and running the application will show
        that the <classname>PersonList</classname> contains 100 rows of data, based on 100 rows
        of generated dummy data in the database.
      </para>
      
      <!-- TODO: CONNECTED TABLE FIGURE -->
      
      <para>
        The order of the columns is still wrong, we at least want the name to come first.
        Additionally the field names extracted from the <classname>PersonAddress</classname>
        -table aren't all that human-friendly. We can handle this by first adding two static
        arrays to the <classname>DatabaseHelper</classname> class. Note that the order of the
        column headers must correspond to the specified column order.
      </para>

      <programlisting>
<![CDATA[public static final Object[] NATURAL_COL_ORDER = new Object[] {
        "FIRSTNAME", "LASTNAME", "EMAIL", "PHONENUMBER", "STREETADDRESS",
        "POSTALCODE", "CITYID" };
public static final String[] COL_HEADERS_ENGLISH = new String[] {
        "First name", "Last name", "Email", "Phone number",
        "Street Address", "Postal Code", "City" };]]>
      </programlisting>

      <para>
        Next we'll add the following two rows to the constructor of the
        <classname>PersonList</classname> class to sort the columns and make the headers nicer.
      </para>
      <programlisting>
<![CDATA[setVisibleColumns(DatabaseHelper.NATURAL_COL_ORDER);
setColumnHeaders(DatabaseHelper.COL_HEADERS_ENGLISH);]]>
      </programlisting>
      
      <para>The table will now look nicer:</para>
      
      <!-- TODO: TABLE COLUMN NAMES FIGURE -->

          <section>
            <title>Replacing the CityID with the name of the city</title>
            <para>
              As you have probably noticed, the <literal>City</literal> column of the table currently
              shows only the <literal>CityID</literal> (actually the foreign key reference) and not
              the name of the city. This happens because the city data is stored in another database
              table and so far we have not even touched it. Therefore we need to modify the
              <literal>City</literal> column of the <classname>PersonList</classname> table to fetch
              the human-readable name of the city from the <classname>City</classname> table and display
              it to the user.
            </para>

            <para>
              The easiest way to do this is to add a generated column to the table. When the column
              is generated we will fetch the city name using the <classname>DatabaseHelper</classname>
              and create a <classname>Label</classname> that will be rendered to the column. The code
              to do this can be seen below; add the code to the constructor of the
              <classname>PersonList</classname> class.
            </para>

            <programlisting>
<![CDATA[addGeneratedColumn("CITYID", new ColumnGenerator() {
    public Component generateCell(Table source, Object itemId,
              Object columnId) {
        if (getItem(itemId).getItemProperty("CITYID").getValue() != null) {
            Label l = new Label();
            int cityId = (Integer) getItem(itemId).getItemProperty(
                  "CITYID").getValue();
            l.setValue(app.getDbHelp().getCityName(cityId));
            l.setSizeUndefined();
            return l;
        }
        return null;
    }
});]]>
            </programlisting>

            <para>
              Note that we are using the same column name for this column that is actually a property
              id in the person container. This way the generated column will override the column that
              only contained the <literal>CityID</literal>s.
            </para>

          </section>

    </section>

    <section>
      <title>Changing the PersonForm to accomodate SQLContainer</title>
      
      <para>
        In order to reflect the changes to the transaction aware SQLContainer, the
        <methodname>commit()</methodname> and <methodname>discard()</methodname> methods need to
        be overridden in the <classname>PersonForm</classname>. At the very least the
        <methodname>commit()</methodname> or <methodname>rollback()</methodname> method of the
        SQLContainer needs to be called so that the changes will be either properly written to
        the database, or discarded from the container alltogether.
      </para>
      
      <para>
        Our overridden <methodname>commit()</methodname> and <methodname>discard()</methodname>
        methods look like the following:
      </para>
      <programlisting>
<![CDATA[@Override
public void commit() throws Buffered.SourceException {
    /* Commit the data entered to the person form to the actual item. */
    super.commit();

    /* Commit changes to the database. */
    try {
        app.getDbHelp().getPersonContainer().commit();
    } catch (UnsupportedOperationException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    setReadOnly(true);
}

@Override
public void discard() throws Buffered.SourceException {
    super.discard();
    /* On discard roll back the changes. */
    try {
        app.getDbHelp().getPersonContainer().rollback();
    } catch (UnsupportedOperationException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    }
    /* Clear the form */
    setItemDataSource(null);
    setReadOnly(true);
}]]>
      </programlisting>
      
    </section>
    
    <section>
      <title>Adding a new contact</title>
      <para>
        The Address book tutorial creates a new instance of <classname>Person</classname>,
        wraps it in a <para>BeanItem</para> and adds the item to the
        <classname>PersonForm</classname>. When using an SQLContainer, we should add a new
        item to the container and then edit that item. When done in this way we get automatic
        persistence of the new item when running
        <classname>SQLContainer</classname><methodname>.commit()</methodname>. The updated
        <classname>PersonForm</classname><methodname>.addContact()</methodname> looks like this:
      </para>

      <programlisting>
<![CDATA[public void addContact() {
    /* Roll back changes just in case */
    try {
        app.getDbHelp().getPersonContainer().rollback();
    } catch (SQLException ignored) {
    }
    Object tempItemId = app.getDbHelp().getPersonContainer().addItem();
    setItemDataSource(app.getDbHelp().getPersonContainer().getItem(
            tempItemId));
    setReadOnly(false);
}]]>
      </programlisting>
      
    </section>
    
    <section>
      <title>Map the <classname>City</classname> table to the contacts</title>
      
      <para>
        Adding and editing contacts should now work but you will notice that the city of a contact
        is shown only by its ID, not by the actual city name. Since this is not very usable, we need
        to create a mapping from the city ID to the name of the city and display that instead.
      </para>
      
      <para>
        For this purpose we will constuct a <classname>ComboBox</classname> which will contain the
        existing cities as well as allow the user to enter new ones. This way selecting an existing
        city becomes much easier.
      </para>
      
      <para>
        Replacing the normal text field with a combo box will introduce you to the system used
        in Vaadin for populating a form. The same mechanism can be used in tables if you put the
        table into editable mode. Fields are generated using the factory pattern by a class
        implementing the FieldFactory interface.
      </para>
      
      <para>
        By default the <classname>BaseFieldFactory</classname> class is used and is generally a
        good base for customizations. The <classname>FieldFactory</classname> interface has several
        methods which we do not want to implement and <classname>BaseFieldFactory</classname> has
        good default implementations of these. Later we'll use the same field factory to tune the
        form fields even more.
      </para> 
      
      <para>
        We start by adding a <classname>ComboBox</classname> field to our
        <classname>PersonForm</classname>:
      </para>

      <programlisting>
<![CDATA[private final ComboBox cities = new ComboBox("City");]]>
      </programlisting>
      
      <para>
        We make adding new items possible and populate the <classname>ComboBox</classname> with
        existing cities from our data source. We will also set the <classname>ComboBox</classname>
        into immediate mode. Add the following code to the <classname>PersonForm</classname>
        constructor:
      </para>

      <programlisting>
<![CDATA[/* Allow the user to enter new cities */
cities.setNewItemsAllowed(true);
/* We do not want to use null values */
cities.setNullSelectionAllowed(false);
/* Cities selection */
cities.setContainerDataSource(app.getDbHelp().getCityContainer());
cities.setItemCaptionPropertyId("NAME");
cities.setImmediate(true);]]>
      </programlisting>

      <para>
        Finally we'll make a field factory extending <classname>BaseFieldFactory</classname>. Using
        the field factory we can choose what kind of field to use for each property. For the
        <literal>city</literal> property we'll return the cities <classname>ComboBox</classname>,
        for all other properties we'll let the <classname>BaseFieldFactory</classname> take care of
        creating the field.
      </para>

      <programlisting>
<![CDATA[setFormFieldFactory(new DefaultFieldFactory() {
   @Override
   public Field createField(Item item, Object propertyId,
      Component uiContext) {
       Field field;
       if (propertyId.equals("CITYID")) {
           field = cities;
       } else {
           field = super.createField(item, propertyId, uiContext);
       }
       return field;
   }
});]]>
      </programlisting>
      
      <para>
        Now that we have the cities nicely listed in a <classname>ComboBox</classname>, we need to
        allow the user to add cities that are not yet present in the <classname>City</classname>
        database table. This is easy to implement using a <classname>NewItemHandler</classname>
        from the <classname>AbstractSelect</classname> class. In this case, our
        <classname>NewItemHandler</classname> will call the <methodname>addCity()</methodname>
        method of the <classname>DatabaseHelper</classname> class. Due to the temporary row IDs
        used in the SQLContainer, we will also need add a listener to the <classname>City</classname>
        container to receive notifications about the automatically generated IDs of added items.
        Add the following code to the end of the <classname>PersonForm</classname> constructor:
      </para>
      
      <programlisting>
<![CDATA[/* NewItemHandler to add new cities */
cities.setNewItemHandler(new AbstractSelect.NewItemHandler() {
    public void addNewItem(String newItemCaption) {
        app.getDbHelp().addCity(newItemCaption);
    }
});
/* Add PersonForm as RowIdChangeListener to the CityContainer */
app.getDbHelp().getCityContainer().addListener(this);]]>
      </programlisting>
      
      <para>
        To implement the <classname>RowIdChangeListener</classname>, we first need to declare
        that the <classname>PersonForm</classname> class implements
        <classname>QueryDelegate.RowIdChangeListener</classname>. After the declaration, we must
        provide the implementation. In our implementation, we will make the cities
        <classname>ComboBox</classname> select the city that was just inserted; this
        <methodname>setValue()</methodname> call is necessary since the <varname>itemID</varname>
        of the city has just changed. Finally, we'll set the key of the added city to the person
        item that we are currently editing, so that its <literal>CITYID</literal> property will
        reference the correct city. The implementation can be done like this:
      </para>

      <programlisting>
<![CDATA[public void rowIdChange(RowIdChangeEvent event) {
    cities.setValue(event.getNewRowId());
    getItemDataSource().getItemProperty("CITYID").setValue(
            event.getNewRowId().getId()[0]);
}]]>
      </programlisting>

      <para>
        The final touch will be done in the <methodname>setItemDataSource()</methodname> method
        of the <classname>PersonForm</classname> class. Here we will add code that will select
        the correct city from the <classname>ComboBox</classname> every time a new item is set
        to the <classname>PersonForm</classname>. Since the item from the person container will
        only contain the key of the city, but the <classname>ComboBox</classname> requires a
        complete <classname>RowId</classname>, we will need to generate one. Add the following code
        to the <classname>PersonForm</classname><methodname>.setItemDataSource()</methodname>
        method, right after the call to
        <methodname>super.setItemDataSource(newDataSource, orderedProperties)</methodname>.
      </para>

      <programlisting>
<![CDATA[/* Select correct city from the cities ComboBox */
setReadOnly(false);
if (newDataSource.getItemProperty("CITYID").getValue() != null) {
    cities.select(new RowId(new Object[] { newDataSource
                  .getItemProperty("CITYID").getValue() }));
} else {
    cities.select(cities.getItemIds().iterator().next());
}]]>
      </programlisting>
      
      <para>
        If the value of the city reference is <literal>null</literal> (e.g. the item is new),
        the first item will be selected from the cities <classname>ComboBox</classname>.
      </para>
      
      <para>
        Try it out and make sure that creation of new contacts, editing of old ones and adding
        new cities works properly.
      </para>
    </section>
    
    <section>
      <title>Searching with the SQLContainer</title>
      
      <para>
        In order to make search work with the SQLContainer, we first add two fields to the
        <classname>SearchFilter</classname> class, after which the class will look like the
        following:
      </para>
      
      <programlisting>
<![CDATA[package com.vaadin.demo.tutorial.addressbook.data;
import java.io.Serializable;
public class SearchFilter implements Serializable {

      private final String term;
      private final Object propertyId;
      private String propertyIdDisplayName;
      private String termDisplayName;
      private String searchName;

      public SearchFilter(Object propertyId, String searchTerm, String name) {
            this.propertyId = propertyId;
            this.term = searchTerm;
            this.searchName = name;
      }

      public SearchFilter(Object propertyId, String searchTerm, String name,
            String propertyIdDisplayName, String termDisplayName) {
          this(propertyId, searchTerm, name);
          setPropertyIdDisplayName(propertyIdDisplayName);
          setTermDisplayName(termDisplayName);
      }

      // + getters and setters
}]]>
      </programlisting>
      
      <para>
        The <methodname>performSearch()</methodname> method also needs to be updated to check
        for illegal values that the SQLContainer won't accept.
      </para>
      
      <programlisting>
<![CDATA[private void performSearch() {
    String searchTerm = (String) tf.getValue();
    if (searchTerm == null || searchTerm.equals("")) {
        getWindow().showNotification("Search term cannot be empty!",
                Notification.TYPE_WARNING_MESSAGE);
        return;
    }
    List<SearchFilter> searchFilters = new ArrayList<SearchFilter>();
    searchFilters.add(new SearchFilter(fieldToSearch.getValue(),
                     searchTerm, (String) searchName.getValue(),                       
                     fieldToSearch.getItemCaption(fieldToSearch.getValue()),
                     searchTerm));

    /* If Save is checked, save the search through the main app. */
    if (saveSearch.booleanValue()) {
        if (searchName.getValue() == null
                || searchName.getValue().equals("")) {
            getWindow().showNotification(
                    "Please enter a name for your search!",
                    Notification.TYPE_WARNING_MESSAGE);
            return;
        }
        SearchFilter[] sf = {};
        app.saveSearch(searchFilters.toArray(sf));
    }
    SearchFilter[] sf = {};
    app.search(searchFilters.toArray(sf));
}]]>
      </programlisting>
      
      <para>
        Now we need to modify the <methodname>search</methodname> logic in the application
        class. Note that since the <class>PersonAddress</class> container contains both
        string and numeric properties, we cannot use the
        <methodname>addContainerFilter()</methodname> method. Instead, we must fetch the type
        of the column from the container and create an accordingly typed 
        <classname>Filter</classname> instance.
      </para>

      <programlisting>
<![CDATA[public void search(SearchFilter... searchFilters) {
    SQLContainer c = getDbHelp().getPersonContainer();
    /* Clear previous filters */
    c.removeAllContainerFilters();
    /* Add the filter(s) to the person container. */
    for (SearchFilter searchFilter : searchFilters) {
        Filter f = new Filter((String) searchFilter.getPropertyId(),
                   ComparisonType.CONTAINS, searchFilter.getTerm());
        if (Integer.class.equals(c.getType(searchFilter.getPropertyId()))) {
            try {
                f = new Filter((String) searchFilter.getPropertyId(),
                               ComparisonType.EQUALS, 
                               Integer.parseInt(searchFilter.getTerm()));
            } catch (NumberFormatException nfe) {
                return;
            }
        }
        getDbHelp().getPersonContainer().addFilter(f);
    }
    showListView();
}]]>
      </programlisting>
      
      <para>
        The logic for the "Show All" item in the tree also needs to be changed in order for the
        functionality to work with SQLContainer. Update the <methodname>itemClick()</methodname>
        and <methodname>addNewContact()</methodname> methods in the application class to the
        following:
      </para>

      <programlisting>
<![CDATA[[...]
if (NavigationTree.SHOW_ALL.equals(itemId)) {
    /* Clear all filters from person container */
    getDbHelp().getPersonContainer().removeAllContainerFilters();
    showListView();
}
[...]

private void addNewContact() {
    showListView();
    tree.select(NavigationTree.SHOW_ALL);
    /* Clear all filters from person container */
    getDbHelp().getPersonContainer().removeAllContainerFilters();
    personForm.addContact();
}]]>
      </programlisting>
      
      <section>
        <title>Implementing search based on a Foreign Key</title>
        
        <para>
          We have previously created a simple search view, implemented the search functionality
          and support for saving the searches. However you may have noted that currently only
          city Ids will be searched if the <classname>City</classname> field is used in the search,
          not the actual city names. Therefore we need to modify the search to first look up the
          correct IDs from the city container, and after that create the required amount of search
          filters for the person container. Now you will also see why earlier the search filters
          were passed around and saved in an array.
        </para>
        
        <para>
          We start from the <classname>SearchView</classname><methodname>.performSearch()</methodname>
          method and replace this:
        </para>

        <programlisting>
<![CDATA[searchFilters.add(new SearchFilter(fieldToSearch.getValue(),
        searchTerm, (String) searchName.getValue(), 
		    fieldToSearch.getItemCaption(fieldToSearch.getValue()),
        searchTerm));]]>
        </programlisting>

        <para>with this:</para>
        
        <programlisting>
<![CDATA[if (!"CITYID".equals(fieldToSearch.getValue())) {
   /* If this is NOT a City search, one filter is enough. */
   searchFilters.add(new SearchFilter(fieldToSearch.getValue(),
           searchTerm, (String) searchName.getValue(), fieldToSearch
                   .getItemCaption(fieldToSearch.getValue()),
           searchTerm));
} else {
   SQLContainer cc = app.getDbHelp().getCityContainer();
   cc.addContainerFilter("NAME", searchTerm, true, false);
   for (Object cityItemId : cc.getItemIds()) {
       searchFilters.add(new SearchFilter("CITYID",
               cc.getItem(cityItemId).getItemProperty("ID").getValue()
                       .toString(), (String) searchName.getValue(),
               fieldToSearch.getItemCaption(fieldToSearch.getValue()),
               searchTerm));
   }
   cc.removeAllContainerFilters();
}]]>
        </programlisting>

        <para>
          In the above code all the other fields are handled exactly as before, except for
          the <classname>City</classname> field. If a <classname>City</classname> search is made,
          we will fetch the city container and add a container filter to it. This filter will
          search for the term the user entered. Once the results are in we will generate
          <classname>SearchFilters</classname> with each of the matching cities' IDs.
        </para>
        
        <para>
          Finally the search method of the application class also requires a slight modification.
          The search mode of the person SQLContainer must be changed from inclusive
          (<literal>AND</literal>) to exclusive (<literal>OR</literal>) in order to get any results
          at all. This is done simply by adding the following code to the method, right before
          the for-loop which adds the containerfilters.
        </para>

        <programlisting>
<![CDATA[getDbHelp().getPersonContainer().setFilteringMode(
            FilteringMode.FILTERING_MODE_EXCLUSIVE);
]]>
        </programlisting>

      </section>
    </section>
    
  </section>

</chapter>


<!-- Keep this comment at the end of the file
Local variables:
mode: xml
sgml-omittag:nil
sgml-shorttag:nil
sgml-namecase-general:nil
sgml-general-insert-case:lower
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:4
sgml-indent-data:t
sgml-parent-document:nil
sgml-exposed-tags:nil
sgml-local-catalogs:("/etc/sgml/catalog" "/usr/share/xemacs21/xemacs-packages/etc/psgml-dtds/CATALOG")
sgml-local-ecat-files:("ECAT" "~/sgml/ECAT" "/usr/share/sgml/ECAT" "/usr/local/share/sgml/ECAT" "/usr/local/lib/sgml/ECAT")
End:
-->

